<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试的问题]]></title>
    <url>%2F2020%2F08%2F21%2F%E9%9D%A2%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近面试的问题进行归纳总结@Autowired与@Resource的不同一、@Autowired：1、Spring 2.5 引入了 @Autowired 注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。这个注解就是spring可以自动帮你把bean里面引用的对象的setter/getter方法省略，它会自动帮你set/get。这样你在userService里面要做一个userDao的setter/getter方法。但如果你用了@Autowired的话，你只需要在UserService的实现类中声明即可。@Autowiredprivate IUserDao userdao; PS： 1、@Autowired是根据类型进行自动装配的。 2、@Autowired也可以手动指定按照byName方式注入，使用@Qualifier标签，例如： @Autowired() @Qualifier(“baseDao”)private BaseDao baseDao; 二、@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入。 @Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。 @Resource装配顺序 1.如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常 \2. 如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常3.如果指定了type，则从上下文中找到类型匹配的唯一bean进行装配，找不到或者找到多个，都会抛出异常 4.如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配； 三、@Autowired与@Resource的区别 1、@Autowired与@Resource都可以用来装配bean. 都可以写在字段上,或写在setter方法上。2、@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果要允许null 值，可以设置它的required属性为false。 3、@Resource（这个注解属于J2EE的），默认安照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。 当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。 ps: @Resource注解在字段上，这样就不用写setter方法了，并且这个注解是属于J2EE的，减少了与spring的耦合。 转自：https://blog.csdn.net/u011067360/article/details/38873755 spring注入bean的几种方式平常的Java开发中，程序员在某个类中需要依赖其它类的方法。通常是new一个依赖类再调用类实例的方法，这种开发存在的问题是new的类实例不好统一管理。Spring提出了依赖注入的思想，即依赖类不由程序员实例化，而是通过Spring容器帮我们new指定实例并且将实例注入到需要该对象的类中。依赖注入的另一种说法是”控制反转”。通俗的理解是：平常我们new一个实例，这个实例的控制权是我们程序员。 而控制反转是指new实例工作不由我们程序员来做而是交给Spring容器来做。 Spring有多种依赖注入的形式，本篇文章仅介绍Spring通过xml进行IOC配置的方式。 1.Set注入 这是最简单的注入方式，假设有一个SpringAction，类中需要实例化一个SpringDao对象，那么就可以定义一个private的SpringDao成员变量，然后创建SpringDao的set方法（这是ioc的注入入口）： 12345678910111213package com.bless.springdemo.action; public class SpringAction &#123; //注入对象springDao private SpringDao springDao; //一定要写被注入对象的set方法 public void setSpringDao(SpringDao springDao) &#123; this.springDao = springDao; &#125; public void ok()&#123; springDao.ok(); &#125; &#125;12345678910111213 随后编写spring的xml文件，中的name属性是class属性的一个别名，class属性指类的全名，因为在SpringAction中有一个公共属性Springdao，所以要在标签中创建一个标签指定SpringDao。标签中的name就是SpringAction类中的SpringDao属性名，ref指下面，这样其实是spring将SpringDaoImpl对象实例化并且调用SpringAction的setSpringDao方法将SpringDao注入： 123456&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(1)依赖注入,配置当前类中相应的属性--&gt; &lt;property name=&quot;springDao&quot; ref=&quot;springDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt;123456 2.构造器注入 这种方式的注入是指带有参数的构造函数注入，看下面的例子，我创建了两个成员变量SpringDao和User，但是并未设置对象的set方法，所以就不能支持第一种注入方式，这里的注入方式是在SpringAction的构造函数中注入，也就是说在创建SpringAction对象时要将SpringDao和User两个参数值传进来： 12345678910111213141516public class SpringAction &#123; //注入对象springDao private SpringDao springDao; private User user; public SpringAction(SpringDao springDao,User user)&#123; this.springDao = springDao; this.user = user; System.out.println(&quot;构造方法调用springDao和user&quot;); &#125; public void save()&#123; user.setName(&quot;卡卡&quot;); springDao.save(user); &#125; &#125; 12345678910111213141516 在XML文件中同样不用的形式，而是使用标签，ref属性同样指向其它标签的name属性： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(2)创建构造器注入,如果主类有带参的构造方法则需添加此配置--&gt; &lt;constructor-arg ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean name=&quot;springDao&quot; class=&quot;com.bless.springdemo.dao.impl.SpringDaoImpl&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;user&quot; class=&quot;com.bless.springdemo.vo.User&quot;&gt;&lt;/bean&gt; 12345678 解决构造方法参数的不确定性，你可能会遇到构造方法传入的两参数都是同类型的，为了分清哪个该赋对应值，则需要进行一些小处理： 下面是设置index，就是参数位置： 1234&lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;constructor-arg index=&quot;0&quot; ref=&quot;springDao&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index=&quot;1&quot; ref=&quot;user&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 1234 另一种是设置参数类型： 1&lt;constructor-arg type=&quot;java.lang.String&quot; ref=&quot;&quot;/&gt;1 3.静态工厂的方法注入 静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取： 123456789101112package com.bless.springdemo.factory; import com.bless.springdemo.dao.FactoryDao; import com.bless.springdemo.dao.impl.FactoryDaoImpl; import com.bless.springdemo.dao.impl.StaticFacotryDaoImpl; public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125; &#125;123456789101112 同样看关键类，这里我需要注入一个FactoryDao对象，这里看起来跟第一种注入一模一样，但是看随后的xml会发现有很大差别: 123456789101112public class SpringAction &#123; //注入对象 private FactoryDao staticFactoryDao; public void staticFactoryOk()&#123; staticFactoryDao.saveFactory(); &#125; //注入对象的set方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125; &#125; 123456789101112 Spring的IOC配置文件，注意看指向的class并不是FactoryDao的实现类，而是指向静态工厂DaoFactory，并且配置 factory-method=”getStaticFactoryDaoImpl”指定调用哪个工厂方法： 12345678&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot; &gt; &lt;!--(3)使用静态工厂的方法注入对象,对应下面的配置文件(3)--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--(3)此处获取对象的方式是从工厂类中获取静态方法--&gt; &lt;bean name=&quot;staticFactoryDao&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 12345678 4.实例工厂的方法注入 实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法： 123456public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125; &#125;123456 那么下面这个类没什么说的，跟前面也很相似，但是我们需要通过实例工厂类创建FactoryDao对象： 123456789101112public class SpringAction &#123; //注入对象 private FactoryDao factoryDao; public void factoryOk()&#123; factoryDao.saveFactory(); &#125; public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125; &#125; 123456789101112 最后看spring配置文件： 12345678910&lt;!--配置bean,配置后该类由spring管理--&gt; &lt;bean name=&quot;springAction&quot; class=&quot;com.bless.springdemo.action.SpringAction&quot;&gt; &lt;!--(4)使用实例工厂的方法注入对象,对应下面的配置文件(4)--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--(4)此处获取对象的方式是从工厂类中获取实例方法--&gt; &lt;bean name=&quot;daoFactory&quot; class=&quot;com.bless.springdemo.factory.DaoFactory&quot;&gt;&lt;/bean&gt; &lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 12345678910 5.总结 Spring IOC注入方式用得最多的是(1)(2)种，多写多练就会非常熟练。 另外注意：通过Spring创建的对象默认是单例的，如果需要创建多实例对象可以在标签后面添加一个属性： 1&lt;bean name=&quot;...&quot; class=&quot;...&quot; scope=&quot;prototype&quot;&gt;1 转自：http://blessht.iteye.com/blog/1162131 @Qualifier有什么用 什么时候用使用@Autowired注释进行byType注入，如果需要byName（byName就是通过id去标识）注入，增加@Qualifier注释。一般在候选Bean数目不为1时应该加@Qualifier注释。 在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。当找不到一个匹配的 Bean 时，Spring 容器将抛出 BeanCreationException 异常，并指出必须至少拥有一个匹配的 Bean。 和找不到一个类型匹配 Bean 相反的一个错误是：如果 Spring 容器中拥有多个候选 Bean，Spring 容器在启动时也会抛出 BeanCreationException 异常。 Spring 允许我们通过 @Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，可以通过下面的方法解决异常： 12345@Autowiredpublic void setOffice(@Qualifier("office")Office office)&#123; this.office =office;&#125; 也可以直接注入到属性: 123@Autowired @Qualifier("office") **private** Office office; @Qualifier(“office”)中的office是Bean的名称，所以@Autowired和@Qualifier结合使用时，自动注入的策略就从byType转变成byName了。 @Autowired可以对成员变量、方法以及构造函数进行注释，而@Qualifier的标注对象是成员变量、方法入参、构造函数入参。正是由于注释对象的不同，所以Spring不将 @Autowired和@Qualifier统一成一个注释类。 @Qualifier 只能和@Autowired 结合使用，是对@Autowired有益的补充。 一般来讲，@Qualifier对方法签名中入参进行注释会降低代码的可读性，而对成员变量注释则相对好一些。 转自：https://blog.csdn.net/zhengyang7754/article/details/62216024 Java中基本数据类型和包装类型的区别1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址；基本类型不是2、包装类型是引用的传递；基本类型是值的传递3、声明方式不同： 基本数据类型不需要new关键字； 包装类型需要new在堆内存中进行new来分配内存空间4、存储位置不同： 基本数据类型直接将值保存在值栈中； 包装类型是把对象放在堆中，然后通过对象的引用来调用他们5、初始值不同： int的初始值为 0 、 boolean的初始值为false 包装类型的初始值为null6、使用方式不同： 基本数据类型直接赋值使用就好； 包装类型是在集合如 coolectionMap时使用 原文地址：http://www.manongjc.com/article/62313.html mybatis在mapper.xml中怎么处理大于、小于、不等于号第一种方法： 使用转义字符 大于号 &gt; &gt; 大于等于号 &gt;= &gt;= 小于号 &lt; &lt; 小于等于号 &lt;= &lt;= 与 &amp; &amp; 单引号 “ &apos; 双引号 ‘ &quot; 例如：sql如下： 1234567&gt; &lt;if test="beginTimeStr != null"&gt;&gt; and file.created_at &amp;gt;= '$&#123;beginTimeStr&#125;'&gt; &lt;/if&gt;&gt; &lt;if test="endTimeStr != null"&gt;&gt; and file.created_at &amp;lt;= '$&#123;endTimeStr&#125;'&gt; &lt;/if&gt;&gt; 第二种方法： 使用因为xml格式遇到这种格式会把方括号里的内容原样输出，不进行解析，如： 大于等于 小于等于 例如：sql如下： 1234567&gt; &lt;if test="beginTimeStr != null"&gt;&gt; &lt;![CDATA[ and file.created_at &gt;= '$&#123;beginTimeStr&#125;' ]]&gt;&gt; &lt;/if&gt;&gt; &lt;if test="endTimeStr != null"&gt;&gt; &lt;![CDATA[ and file.created_at &lt;= '$&#123;endTimeStr&#125;' ]]&gt;&gt; &lt;/if&gt;&gt; 转自：https://blog.csdn.net/l18848956739/article/details/88574820 PreparedStatement防止sql注入原理PreparedStatement类是java的一个类，准确说是jdbc规范中的一个接口，各个数据库产商的实现不同(即实现类不同)，今天我们就以mysql数据库来说，我已经下载了mysql数据库的驱动jar包和驱动程序的源代码. sql注入的时候，比如，有些用户就会在界面上输入anything’ OR ‘x’=’x这种东西，最后sql语句就是如下： SELECT * FROM users WHERE userName = ‘令狐冲’ AND password = ‘anything’ OR ‘x’=’x’ 其实 SELECT * FROM users WHERE userName = ? AND password = ? preparedStatement.setString(1,’XXX’); preparedStatement.setString(2,’XXX’); 我们可以看下mysql的底层的setString();方法，其实就是用值代替了？的位置，并且在值的两边加上了单引号，然后再把值当中的所有单引号替换成了斜杠单引号，说白了就是把值当中的所有单引号给转义了!这就达到了防止sql注入的目的，说白了mysql驱动的PreparedStatement实现类的setString();方法内部做了单引号的转义，而Statement不能防止sql注入，就是因为它没有把单引号做转义，而是简单粗暴的直接拼接字符串，所以达不到防止sql注入的目的。所以，不管是mysql数据库产商的PreparedStatement实现类还是sqlserver数据库产商的PreparedStatement实现类，其实底层的原理都差不多，当然啦，我们直接在java程序中把那些单引号直接转义也行，只不过比较繁琐一点罢了，既然各个数据库产商的PreparedStatement实现类的setString()方法中已经做了转义，我们何必在java程序中自己去做转义的这部分工作呢？ 你如果想看最后在数据库中执行的sql语句是什么的话，可以打印出来看看，如果是mysql数据库的话，直接System.out.println(preparedStatement.toString()); 你们可以直接看看打印出来是不是SELECT * FROM users WHERE userName = ‘令狐冲’ AND password = ‘anything&#39; OR&#39;x&#39;=&#39;x’ 不好意思，如果你们用的是mysql数据库的话，你们自己打印出来试一试，我没试过，但是我知道底层的原理的话，大概猜一下，只要方向猜对了，八九不离十，其实大家写程序写多了，写久了，你们就可以去猜一猜那些大牛或者是框架的底层的原理，只要方向猜对了，基本上八九不离十，所以，有时候还是要大胆的去猜测底层的原理和实现！(大胆猜测,小心求证!) 如果是sqlserver数据库的话， System.out.println(preparedStatement.toString()); 好像不会打印出具体的sql语句，因为sqlserver和mysql的preparedStatement实现类不同。至于oracle数据的话， System.out.println(preparedStatement.toString()); 会不会打印出具体的sql语句，我不太清楚，我没试过，你们可以试一试！ 以下是mysql数据库的PreparedStatement实现类的setString()方法(你们可以去网上下载mysql的驱动程序的源代码，源代码里面有jdbc的PreparedStatement实现类，去看看实现类中的setString()方法吧) mysql驱动程序和源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * Set a parameter to a Java String value. The driver converts this to a SQL * VARCHAR or LONGVARCHAR value (depending on the arguments size relative to * the driver&apos;s limits on VARCHARs) when it sends it to the database. * * @param parameterIndex * the first parameter is 1... * @param x * the parameter value * * @exception SQLException * if a database access error occurs */ public synchronized void setString(int parameterIndex, String x) throws SQLException &#123; // if the passed string is null, then set this column to null if (x == null) &#123; setNull(parameterIndex, Types.CHAR); &#125; else &#123; checkClosed(); int stringLength = x.length(); if (this.connection.isNoBackslashEscapesSet()) &#123; // Scan for any nasty chars boolean needsHexEscape = isEscapeNeededForString(x, stringLength); if (!needsHexEscape) &#123; byte[] parameterAsBytes = null; StringBuffer quotedString = new StringBuffer(x.length() + 2); quotedString.append(&apos;\&apos;&apos;); quotedString.append(x); quotedString.append(&apos;\&apos;&apos;); if (!this.isLoadDataQuery) &#123; parameterAsBytes = StringUtils.getBytes(quotedString.toString(), this.charConverter, this.charEncoding, this.connection.getServerCharacterEncoding(), this.connection.parserKnowsUnicode(), getExceptionInterceptor()); &#125; else &#123; // Send with platform character encoding parameterAsBytes = StringUtils.getBytes(quotedString.toString()); &#125; setInternal(parameterIndex, parameterAsBytes); &#125; else &#123; byte[] parameterAsBytes = null; if (!this.isLoadDataQuery) &#123; parameterAsBytes = StringUtils.getBytes(x, this.charConverter, this.charEncoding, this.connection.getServerCharacterEncoding(), this.connection.parserKnowsUnicode(), getExceptionInterceptor()); &#125; else &#123; // Send with platform character encoding parameterAsBytes = StringUtils.getBytes(x); &#125; setBytes(parameterIndex, parameterAsBytes); &#125; return; &#125; String parameterAsString = x; boolean needsQuoted = true; if (this.isLoadDataQuery || isEscapeNeededForString(x, stringLength)) &#123; needsQuoted = false; // saves an allocation later StringBuffer buf = new StringBuffer((int) (x.length() * 1.1)); buf.append(&apos;\&apos;&apos;); // // Note: buf.append(char) is _faster_ than // appending in blocks, because the block // append requires a System.arraycopy().... // go figure... // for (int i = 0; i &lt; stringLength; ++i) &#123; char c = x.charAt(i); switch (c) &#123; case 0: /* Must be escaped for &apos;mysql&apos; */ buf.append(&apos;\\&apos;); buf.append(&apos;0&apos;); break; case &apos;\n&apos;: /* Must be escaped for logs */ buf.append(&apos;\\&apos;); buf.append(&apos;n&apos;); break; case &apos;\r&apos;: buf.append(&apos;\\&apos;); buf.append(&apos;r&apos;); break; case &apos;\\&apos;: buf.append(&apos;\\&apos;); buf.append(&apos;\\&apos;); break; case &apos;\&apos;&apos;: buf.append(&apos;\\&apos;); buf.append(&apos;\&apos;&apos;); break; case &apos;&quot;&apos;: /* Better safe than sorry */ if (this.usingAnsiMode) &#123; buf.append(&apos;\\&apos;); &#125; buf.append(&apos;&quot;&apos;); break; case &apos;\032&apos;: /* This gives problems on Win32 */ buf.append(&apos;\\&apos;); buf.append(&apos;Z&apos;); break; case &apos;\u00a5&apos;: case &apos;\u20a9&apos;: // escape characters interpreted as backslash by mysql if(charsetEncoder != null) &#123; CharBuffer cbuf = CharBuffer.allocate(1); ByteBuffer bbuf = ByteBuffer.allocate(1); cbuf.put(c); cbuf.position(0); charsetEncoder.encode(cbuf, bbuf, true); if(bbuf.get(0) == &apos;\\&apos;) &#123; buf.append(&apos;\\&apos;); &#125; &#125; // fall through default: buf.append(c); &#125; &#125; buf.append(&apos;\&apos;&apos;); parameterAsString = buf.toString(); &#125; byte[] parameterAsBytes = null; if (!this.isLoadDataQuery) &#123; if (needsQuoted) &#123; parameterAsBytes = StringUtils.getBytesWrapped(parameterAsString, &apos;\&apos;&apos;, &apos;\&apos;&apos;, this.charConverter, this.charEncoding, this.connection .getServerCharacterEncoding(), this.connection .parserKnowsUnicode(), getExceptionInterceptor()); &#125; else &#123; parameterAsBytes = StringUtils.getBytes(parameterAsString, this.charConverter, this.charEncoding, this.connection .getServerCharacterEncoding(), this.connection .parserKnowsUnicode(), getExceptionInterceptor()); &#125; &#125; else &#123; // Send with platform character encoding parameterAsBytes = StringUtils.getBytes(parameterAsString); &#125; setInternal(parameterIndex, parameterAsBytes); this.parameterTypes[parameterIndex - 1 + getParameterIndexOffset()] = Types.VARCHAR; &#125; &#125; 转自：https://blog.csdn.net/czh500/article/details/78830636 java 创建线程的三种方式、创建线程池的四种方式java创建线程的三种方式： 继承Thread类创建线程类 实现Runnable接口 通过Callable和Future创建线程 java创建线程池的四种方式： newCachedThreadPool 创建一个可缓存的线程池，如果线程池长度超过处理需求，可灵活回收空闲线程，若无可回收，则新建线程 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行 newSingleThreadExecutor 创建一个单线程化的线程池，它只会唯一的工作线程来执行任务，保证所有任务按照指定 顺序（FIFO，LIFO，优先级）执行 线程池的优点： a. 重用存在的线程，减少对象创建、消亡的开销，性能佳。 b. 可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。 c. 提供定时执行、定期执行、单线程、并发数控制等功能。 转自：https://blog.csdn.net/qq_35275233/article/details/87893337]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Optional类]]></title>
    <url>%2F2020%2F07%2F23%2FOptional%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Optional类Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。创建Optional类对象的方法： Optional.of(T t) : 创建一个 Optional 实例，t必须非空； Optional.empty() : 创建一个空的 Optional 实例 Optional.ofNullable(T t)：t可以为null 123456@Testpublic void test1()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee()); Employee emp = op.get(); System.out.println(emp);&#125; 12345678@Testpublic void test2()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(null); System.out.println(op.get()); op = Optional.empty(); System.out.println(op.get());&#125; 判断Optional容器中是否包含对象： boolean isPresent() : 判断是否包含对象 void ifPresent(Consumer&lt;? super T&gt; consumer) ：如果有值，就执行Consumer 接口的实现代码，并且该值会作为参数传给它。 获取Optional容器的对象： T get(): 如果调用对象包含值，返回该值，否则抛异常 T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。 T orElseGet(Supplier&lt;? extends T&gt; other) ：如果有值则将其返回，否则返回由 Supplier接口实现提供的对象。 T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) ：如果有值则将其返 回，否则抛出由Supplier接口实现提供的异常。 1234567891011121314@Testpublic void test3()&#123; Optional&lt;Employee&gt; op = Optional.ofNullable(new Employee()); if(op.isPresent())&#123; System.out.println(op.get()); &#125; Employee emp = op.orElse(new Employee("张三")); System.out.println(emp); Employee emp2 = op.orElseGet(() -&gt; new Employee()); System.out.println(emp2);&#125; 12345678910@Testpublic void test4()&#123; Optional&lt;Employee&gt; op = Optional.of(new Employee(101, "张三", 18, 9999.99)); Optional&lt;String&gt; op2 = op.map(Employee::getName); System.out.println(op2.get()); Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName())); System.out.println(op3.get());&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stream]]></title>
    <url>%2F2020%2F07%2F23%2FStream%2F</url>
    <content type="text"><![CDATA[什么是StreamStream到底是什么呢？是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。“集合讲的是数据，Stream讲的是计算！”注意：①Stream 自己不会存储元素。②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。 Stream 的操作三个步骤1- 创建 Stream 一个数据源（如：集合、数组），获取一个流 2- 中间操作 一个中间操作链，对数据源的数据进行处理 3- 终止操作(终端操作) 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用 创建 Stream的方法 Collection 提供了两个方法 stream() 与 parallelStream() 通过 Arrays 中的 stream() 获取一个数组流 通过 Stream 类中静态方法 of() 创建无限流 12345678910111213141516171819202122232425//1. 创建 Stream@Testpublic void test1()&#123; //1. Collection 提供了两个方法 stream() 与 parallelStream() List&lt;String&gt; list = new ArrayList&lt;&gt;(); Stream&lt;String&gt; stream = list.stream(); //获取一个顺序流 Stream&lt;String&gt; parallelStream = list.parallelStream(); //获取一个并行流 //2. 通过 Arrays 中的 stream() 获取一个数组流 Integer[] nums = new Integer[10]; Stream&lt;Integer&gt; stream1 = Arrays.stream(nums); //3. 通过 Stream 类中静态方法 of() Stream&lt;Integer&gt; stream2 = Stream.of(1,2,3,4,5,6); //4. 创建无限流 //迭代 Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2).limit(10); stream3.forEach(System.out::println); //生成 Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(2); stream4.forEach(System.out::println); &#125; 中间操作筛选与切片filter——接收 Lambda ， 从流中排除某些元素。limit——截断流，使其元素不超过给定数量。skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 123456789101112131415161718192021222324@Testpublic void test4()&#123; emps.stream() .filter((e) -&gt; &#123; System.out.println("短路！"); // &amp;&amp; || return e.getSalary() &gt;= 5000; &#125;).limit(3) .forEach(System.out::println);&#125;@Testpublic void test5()&#123; emps.parallelStream() .filter((e) -&gt; e.getSalary() &gt;= 5000) .skip(2) .forEach(System.out::println);&#125;@Testpublic void test6()&#123; emps.stream() .distinct() .forEach(System.out::println);&#125; 映射map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 12345678910111213141516171819202122232425262728293031323334353637@Testpublic void test1()&#123; Stream&lt;String&gt; str = emps.stream() .map((e) -&gt; e.getName()); System.out.println("-------------------------------------------"); List&lt;String&gt; strList = Arrays.asList("aaa", "bbb", "ccc", "ddd", "eee"); Stream&lt;String&gt; stream = strList.stream() .map(String::toUpperCase); stream.forEach(System.out::println); Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream() .map(TestStreamAPI1::filterCharacter); stream2.forEach((sm) -&gt; &#123; sm.forEach(System.out::println); &#125;); System.out.println("---------------------------------------------"); Stream&lt;Character&gt; stream3 = strList.stream() .flatMap(TestStreamAPI1::filterCharacter); stream3.forEach(System.out::println);&#125;public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); for (Character ch : str.toCharArray()) &#123; list.add(ch); &#125; return list.stream(); &#125; 排序sorted()——自然排序sorted(Comparator com)——定制排序 123456789101112131415161718public void test2()&#123; emps.stream() .map(Employee::getName) .sorted() .forEach(System.out::println); System.out.println("------------------------------------"); emps.stream() .sorted((x, y) -&gt; &#123; if(x.getAge() == y.getAge())&#123; return x.getName().compareTo(y.getName()); &#125;else&#123; return Integer.compare(x.getAge(), y.getAge()); &#125; &#125;).forEach(System.out::println); &#125;&#125; 终止操作allMatch——检查是否匹配所有元素anyMatch——检查是否至少匹配一个元素noneMatch——检查是否没有匹配的元素findFirst——返回第一个元素findAny——返回当前流中的任意元素count——返回流中元素的总个数max——返回流中最大值min——返回流中最小值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263List&lt;Employee&gt; emps = Arrays.asList( new Employee(102, "李四", 59, 6666.66, Status.BUSY), new Employee(101, "张三", 18, 9999.99, Status.FREE), new Employee(103, "王五", 28, 3333.33, Status.VOCATION), new Employee(104, "赵六", 8, 7777.77, Status.BUSY), new Employee(104, "赵六", 8, 7777.77, Status.FREE), new Employee(104, "赵六", 8, 7777.77, Status.FREE), new Employee(105, "田七", 38, 5555.55, Status.BUSY) );@Testpublic void test1()&#123; boolean bl = emps.stream() .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl); boolean bl1 = emps.stream() .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl1); boolean bl2 = emps.stream() .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY)); System.out.println(bl2);&#125;@Testpublic void test2()&#123; Optional&lt;Employee&gt; op = emps.stream() .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())) .findFirst(); System.out.println(op.get()); System.out.println("--------------------------------"); Optional&lt;Employee&gt; op2 = emps.parallelStream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .findAny(); System.out.println(op2.get());&#125;@Testpublic void test3()&#123; long count = emps.stream() .filter((e) -&gt; e.getStatus().equals(Status.FREE)) .count(); System.out.println(count); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .max(Double::compare); System.out.println(op.get()); Optional&lt;Employee&gt; op2 = emps.stream() .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())); System.out.println(op2.get());&#125; 归约reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。 1234567891011121314151617@Testpublic void test1()&#123; List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,9,10); Integer sum = list.stream() .reduce(0, (x, y) -&gt; x + y); System.out.println(sum); System.out.println("----------------------------------------"); Optional&lt;Double&gt; op = emps.stream() .map(Employee::getSalary) .reduce(Double::sum); System.out.println(op.get());&#125; 收集collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Testpublic void test3()&#123; List&lt;String&gt; list = emps.stream() .map(Employee::getName) .collect(Collectors.toList()); list.forEach(System.out::println); System.out.println("----------------------------------"); Set&lt;String&gt; set = emps.stream() .map(Employee::getName) .collect(Collectors.toSet()); set.forEach(System.out::println); System.out.println("----------------------------------"); HashSet&lt;String&gt; hs = emps.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new)); hs.forEach(System.out::println);&#125;@Test public void test4()&#123; Optional&lt;Double&gt; max = emps.stream() .map(Employee::getSalary) .collect(Collectors.maxBy(Double::compare)); System.out.println(max.get()); Optional&lt;Employee&gt; op = emps.stream() .collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))); System.out.println(op.get()); Double sum = emps.stream() .collect(Collectors.summingDouble(Employee::getSalary)); System.out.println(sum); Double avg = emps.stream() .collect(Collectors.averagingDouble(Employee::getSalary)); System.out.println(avg); Long count = emps.stream() .collect(Collectors.counting()); System.out.println(count); System.out.println("--------------------------------------------"); DoubleSummaryStatistics dss = emps.stream() .collect(Collectors.summarizingDouble(Employee::getSalary)); System.out.println(dss.getMax()); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法引用与构造器引用]]></title>
    <url>%2F2020%2F07%2F23%2F%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[方法引用用法方法引用：若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式）主要的语法格式 对象的引用 :: 实例方法名 类名 :: 静态方法名 类名 :: 实例方法名 对象::实例方法名12345678910111213@Testpublic void test1()&#123; PrintStream ps = System.out; Consumer&lt;String&gt; con = (str) -&gt; ps.println(str); con.accept("Hello World！"); System.out.println("--------------------------------"); Consumer&lt;String&gt; con2 = ps::println; con2.accept("Hello Java8！"); Consumer&lt;String&gt; con3 = System.out::println;&#125; 类名 :: 静态方法名12345678@Testpublic void test4()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); System.out.println("-------------------------------------"); Comparator&lt;Integer&gt; com2 = Integer::compare;&#125; 类名 :: 实例方法名1234567891011121314151617181920@Testpublic void test5()&#123; BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y); System.out.println(bp.test("abcde", "abcde")); System.out.println("-----------------------------------------"); BiPredicate&lt;String, String&gt; bp2 = String::equals; System.out.println(bp2.test("abc", "abc")); System.out.println("-----------------------------------------"); Function&lt;Employee, String&gt; fun = (e) -&gt; e.show(); System.out.println(fun.apply(new Employee())); System.out.println("-----------------------------------------"); Function&lt;Employee, String&gt; fun2 = Employee::show; System.out.println(fun2.apply(new Employee())); 构造器引用构造器引用 :构造器的参数列表，需要与函数式接口中参数列表保持一致！ 类名 :: new123456789101112131415161718//构造器引用@Testpublic void test7()&#123; Function&lt;String, Employee&gt; fun = Employee::new; BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::new;&#125;@Testpublic void test6()&#123; Supplier&lt;Employee&gt; sup = () -&gt; new Employee(); System.out.println(sup.get()); System.out.println("------------------------------------"); Supplier&lt;Employee&gt; sup2 = Employee::new; System.out.println(sup2.get());&#125; 数组引用类型[] :: new12345678910111213//数组引用@Testpublic void test8()&#123; Function&lt;Integer, String[]&gt; fun = (args) -&gt; new String[args]; String[] strs = fun.apply(10); System.out.println(strs.length); System.out.println("--------------------------"); Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: new; Employee[] emps = fun2.apply(20); System.out.println(emps.length);&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解]]></title>
    <url>%2F2020%2F07%2F22%2F%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解 (Annotation) 概述从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。 Annotation 可以像修饰符一样被使用, 可用于修饰包,类,构造器,方法,成员变量, 参数,局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中 自定义 Annotation 定义新的 Annotation 类型使用 @interface 关键字 自定义注解自动继承了java.lang.annotation.Annotation接口 Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其 方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能 是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型以上所有类型的数组。 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始 值可使用 default 关键字 如果只有一个参数成员，建议使用参数名为value 如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认 值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value， 可以省略“value=” 没有成员定义的 Annotation 称为标记; 包含成员变量的 Annotation 称为元数 据 Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义。 1234567891011121314151617181920212223242526272829303132@Inherited@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)public @interface MyAnnotation &#123; String value() default "hello";&#125;//jdk 8之前的写法：//@MyAnnotations(&#123;@MyAnnotation(value="hi"),@MyAnnotation(value="hi")&#125;)@MyAnnotation(value="hi")@MyAnnotation(value="abc")class Person&#123; private String name; private int age; public Person() &#123; &#125; @MyAnnotation public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @MyAnnotation public void walk()&#123; System.out.println("人走路"); &#125; public void eat()&#123; System.out.println("人吃饭"); &#125;&#125; JDK中的元注解JDK 的元 Annotation 用于修饰其他 Annotation 定义JDK5.0提供了4个标准的meta-annotation类型，分别是：Retention Target Documented Inherited @Retention:只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命 周期, @Rentention 包含一个 RetentionPolicy 类型的成员变量, 使用 @Rentention 时必须为该 value 成员变量指定值: RetentionPolicy.SOURCE:在源文件中有效（即源文件保留），编译器直接丢弃这种策略的 注释 RetentionPolicy.CLASS:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM 不会保留注解。 这是默认值 RetentionPolicy.RUNTIME:在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会 保留注释。程序可以通过反射获取该注释。 @Target:用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。 @Documented:用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 定义为Documented的注解必须设置Retention值为RUNTIME。 @Inherited:被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。 比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以 继承父类类级别的注解]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举]]></title>
    <url>%2F2020%2F07%2F22%2F%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[当需要定义一组常量时，强烈建议使用枚举类使用说明使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类枚举类的构造器只能使用 private 权限修饰符枚举类的所有实例必须在枚举类中显式列出(, 分隔;结尾)。列出的实例系统会自动添加 public static final 修饰 必须在枚举类的第一行声明枚举类对象 JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。 Enum类的主要方法：values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。 valueOf(String str)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 toString()：返回当前枚举类对象常量的名称 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667interface Info&#123; void show();&#125;//使用enum关键字枚举类enum Season1 implements Info&#123; //1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束 SPRING("春天","春暖花开")&#123; @Override public void show() &#123; System.out.println("春天在哪里？"); &#125; &#125;, SUMMER("夏天","夏日炎炎")&#123; @Override public void show() &#123; System.out.println("宁夏"); &#125; &#125;, AUTUMN("秋天","秋高气爽")&#123; @Override public void show() &#123; System.out.println("秋天不回来"); &#125; &#125;, WINTER("冬天","冰天雪地")&#123; @Override public void show() &#123; System.out.println("大约在冬季"); &#125; &#125;; //2.声明Season对象的属性:private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器,并给对象属性赋值 private Season1(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125;// //4.其他诉求1：提供toString()//// @Override// public String toString() &#123;// return "Season1&#123;" +// "seasonName='" + seasonName + '\'' +// ", seasonDesc='" + seasonDesc + '\'' +// '&#125;';// &#125;// @Override// public void show() &#123;// System.out.println("这是一个季节");// &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛型]]></title>
    <url>%2F2020%2F07%2F21%2F%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[泛型的概念​ 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 ​ 从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念， 允许我们在创建集合时再指定集合元素的类型，正如：List，这表明 该List只能保存字符串类型的对象。 ​ JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持， 从而可以在声明集合变量、创建集合对象时传入类型实参。 在集合中使用泛型123456789101112131415161718192021222324252627 @Test public void test2()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); //编译时，就会进行类型检查，保证数据的安全// list.add("Tom"); //方式一：// for(Integer score : list)&#123;// //避免了强转操作// int stuScore = score;//// System.out.println(stuScore);//// &#125; //方式二： Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; int stuScore = iterator.next(); System.out.println(stuScore); &#125; &#125; Java泛型中的标记符含义： E - Element (在集合中使用，因为集合中存放的是元素) T - Type（Java 类） K - Key（键） V - Value（值） N - Number（数值类型） ？ - 表示不确定的java类型 Java继承父类泛型的情况：123456789101112131415161718192021222324252627282930313233class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father &#123;// 等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#125;// 2)部分保留class Son4&lt;T2&gt;** extends Father&lt;Integer, T2&gt; &#123;&#125;class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 泛型方法12345678910111213//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。//换句话说，泛型方法所属的类是不是泛型类都没有关系。//泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。public static &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); &#125; return list;&#125; 通配符的使用1234567891011121314151617181920212223242526272829303132333435363738394041 @Test public void test3()&#123; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; List&lt;?&gt; list = null; list = list1; list = list2; //编译通过// print(list1);// print(list2); // List&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add("AA"); list3.add("BB"); list3.add("CC"); list = list3; //添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。 //除了添加null之外。// list.add("DD");// list.add('?'); list.add(null); //获取(读取)：允许读取数据，读取的数据类型为Object。 Object o = list.get(0); System.out.println(o); &#125; public void print(List&lt;?&gt; list)&#123; Iterator&lt;?&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; Object obj = iterator.next(); System.out.println(obj); &#125; &#125; 有限制的通配符&lt;? extends Number&gt; (无穷小, Number]只允许泛型为Number及Number子类的引用调用 &lt;? super Number&gt; [Number , 无穷大)只允许泛型为Number及Number父类的引用调用 &lt;? extends Comparable&gt;只允许泛型为实现Comparable接口的实现类的引用调用 12345678910111213141516171819202122232425262728293031323334353637383940414243 public class Person &#123;&#125;public class Student extends Person &#123;&#125; @Test public void test4()&#123; List&lt;? extends Person&gt; list1 = null; List&lt;? super Person&gt; list2 = null; List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;(); List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;(); List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;(); list1 = list3; list1 = list4;// list1 = list5;// list2 = list3; list2 = list4; list2 = list5; //读取数据： list1 = list3; Person p = list1.get(0); //编译不通过 //Student s = list1.get(0); list2 = list4; Object obj = list2.get(0); ////编译不通过// Person obj = list2.get(0); //写入数据： //编译不通过// list1.add(new Student()); //编译通过 list2.add(new Person()); list2.add(new Student()); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用快捷键]]></title>
    <url>%2F2020%2F07%2F21%2FLinux%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Linux常用快捷键查看内存使用情况: top 和 freetop:命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.free:命令用来显示内存的使用情况Vim常用快捷键快速查询: /在normal模式下按下/即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下n查找下一个，按下N查找上一个。 快速到达顶部和底部: /在normal模式下按下G即可到达底部，双击两下g即可到达顶部。 未完待续。。。 不定期更新]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA常用快捷键]]></title>
    <url>%2F2020%2F07%2F21%2FIDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[IDEA常用快捷键打开的文件和工具窗口之间切换:Ctrl + Tab要在打开的文件和工具窗口之间切换，请使用切换器Ctrl + Tab。 要进行导航，请按住Ctrl键（Windows和Linux）或Command键（macOS）并使用向上和向下箭头键或Tab和Shift + Tab和Alt。按Delete或BackSpace关闭编辑器选项卡或隐藏工具窗口。 快速包装代码块: Ctrl+Alt+T要在结构中快速包装代码块，请在编辑器中将其选中，然后按Ctrl + Alt + T（“代码” |“环绕”）。可用选项（“包装器”）的列表是上下文相关的，并且取决于语言。 例如，您可以用标签将html块包围，依此类推。 使用UML类图探索包的结构: Ctrl + Alt + Shift + U使用UML类图探索包的结构，查看其组成类，子包和依赖项。 在“项目”视图中右键单击一个包，然后从上下文菜单中选择“显示类图”，或按Ctrl + Alt + Shift + U。您还可以使用“类”图创建可视模型，并用节点元素和成员填充该模型，并绘制链接。 IntelliJ IDEA将生成源代码，并使其始终与模型保持同步。 查看快捷键: Ctrl + Shift + A如果您不记得如何调用动作，请按Ctrl + Shift + A并开始输入动作名称。 跳转至下个TODO: Ctrl + ALT+向下箭头跳转至下一个TODO 快速找到所有在符号处引用该符号的代码: Alt + F7 按Alt + F7键可以快速找到所有在符号处引用该符号的代码，无论该符号是类，方法，字段，参数还是其他语句的一部分。 折叠所有代码: crtl + shift+ 减号 将所有代码折叠 折叠选中代码: crtl + 减号 将选中代码折叠 展开所有代码: crtl + shift+ 加号 将所有代码展开 展开选中代码: crtl + 加号 将选中代码展开 运行: shift+ F10 运行当前的程序 当前文件查找: ctrl+ F在当前文件查找 当前文件替换: ctrl+ R在当前文件替换 当前窗口全屏与原先大小切换: ctrl+ shift+F12使当前窗口全屏和缩小 使用快捷键查找错误和警告: F2我们可以用F2/Shift+F2来快速定位错误和警告，这在几百行代码中定位错误是非常方便的。 未完待续。。。 不定期更新]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lambda表达式]]></title>
    <url>%2F2020%2F07%2F21%2Flambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Lambal 表达式用法一、Lambda 表达式的基础语法：Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符箭头操作符将 Lambda 表达式拆分成两部分：左侧：Lambda 表达式的参数列表右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体 语法格式一：无参数，无返回值 () -&gt; System.out.println(“Hello Lambda!”); 语法格式二：有一个参数，并且无返回值 (x) -&gt; System.out.println(x) 语法格式三：若只有一个参数，小括号可以省略不写 x -&gt; System.out.println(x) 语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句 Comparator com = (x, y) -&gt; { System.out.println(“函数式接口”); return Integer.compare(x, y); }; 语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写 Comparator com = (x, y) -&gt; Integer.compare(x, y); 语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” (Integer x, Integer y) -&gt; Integer.compare(x, y); 上联：左右遇一括号省 下联：左侧推断类型省 横批：能省则省 二、Lambda 表达式需要“函数式接口”的支持函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰 可以检查是否是函数式接口 三、代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class TestLambda2 &#123; @Test public void test1()&#123; int num = 0;//jdk 1.7 前，必须是 final Runnable r = new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello World!" + num); &#125; &#125;; r.run(); System.out.println("-------------------------------"); Runnable r1 = () -&gt; System.out.println("Hello Lambda!"); r1.run(); &#125; @Test public void test2()&#123; Consumer&lt;String&gt; con = x -&gt; System.out.println(x); con.accept("我大尚硅谷威武！"); &#125; @Test public void test3()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("函数式接口"); return Integer.compare(x, y); &#125;; &#125; @Test public void test4()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y); &#125; @Test public void test5()&#123;// String[] strs;// strs = &#123;"aaa", "bbb", "ccc"&#125;; List&lt;String&gt; list = new ArrayList&lt;&gt;(); show(new HashMap&lt;&gt;()); &#125; public void show(Map&lt;String, Integer&gt; map)&#123; &#125; //需求：对一个数进行运算// @Test// public void test6()&#123;// Integer num = operation(100, (x) -&gt; x * x);// System.out.println(num);//// System.out.println(operation(200, (y) -&gt; y + 200));// &#125; // public Integer operation(Integer num, MyFun mf)&#123;// return mf.getValue(num);// &#125;&#125; Java8 内置的四大核心函数式接口Consumer : 消费型接口void accept(T t); 用来返回值为void 12345678@Testpublic void test1()&#123; happy(10000, (m) -&gt; System.out.println("你们刚哥喜欢大宝剑，每次消费：" + m + "元"));&#125; public void happy(double money, Consumer&lt;Double&gt; con)&#123; con.accept(money);&#125; Supplier 供给型接口T get(); 用来有返回值无传入值的接口 123456789101112131415161718192021//Supplier&lt;T&gt; 供给型接口 :@Testpublic void test2()&#123; List&lt;Integer&gt; numList = getNumList(10, () -&gt; (int)(Math.random() * 100)); for (Integer num : numList) &#123; System.out.println(num); &#125;&#125;//需求：产生指定个数的整数，并放入集合中public List&lt;Integer&gt; getNumList(int num, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) &#123; Integer n = sup.get(); list.add(n); &#125; return list;&#125; Function&lt;T, R&gt; : 函数型接口R apply(T t); 传入一个参数，返回一个对象 1234567891011121314//Function&lt;T, R&gt; 函数型接口：@Testpublic void test3()&#123; String newStr = strHandler("\t\t\t 我大尚硅谷威武 ", (str) -&gt; str.trim()); System.out.println(newStr); String subStr = strHandler("我大尚硅谷威武", (str) -&gt; str.substring(2, 5)); System.out.println(subStr);&#125;//需求：用于处理字符串public String strHandler(String str, Function&lt;String, String&gt; fun)&#123; return fun.apply(str);&#125; Predicate : 断言型接口boolean test(T t); 传入一个参数 ，返回一个boolean 1234567891011121314151617181920212223//Predicate&lt;T&gt; 断言型接口：@Testpublic void test4()&#123; List&lt;String&gt; list = Arrays.asList("Hello", "atguigu", "Lambda", "www", "ok"); List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; 3); for (String str : strList) &#123; System.out.println(str); &#125;&#125;//需求：将满足条件的字符串，放入集合中public List&lt;String&gt; filterStr(List&lt;String&gt; list, Predicate&lt;String&gt; pre)&#123; List&lt;String&gt; strList = new ArrayList&lt;&gt;(); for (String str : list) &#123; if(pre.test(str))&#123; strList.add(str); &#125; &#125; return strList;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程同步]]></title>
    <url>%2F2020%2F07%2F17%2F%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Synchronized的使用方法同步锁机制：同步机制中的锁​ 在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防​ 止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法​ 就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须 ​ 锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁 ​ 之时，另一个任务就可以锁定并使用它了。 synchronized的锁是什么？​ 任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class注意：​ 必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就 ​ 无法保证共享资源的安全 ​ 一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方 ​ 法共用同一把锁（this），同步代码块（指定需谨慎） 使用同步代码块的方式处理Runable方法的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式 * * 1.问题：卖票过程中，出现了重票、错票 --&gt;出现了线程的安全问题 * 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。 * 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他 * 线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。 * * * 4.在Java中，我们通过同步机制，来解决线程的安全问题。 * * 方式一：同步代码块 * * synchronized(同步监视器)&#123; * //需要被同步的代码 * * &#125; * 说明：1.操作共享数据的代码，即为需要被同步的代码。 --&gt;不能包含代码多了，也不能包含代码少了。 * 2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。 * 3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。 * 要求：多个线程必须要共用同一把锁。 * * 补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 * 方式二：同步方法。 * 如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。 * * * 5.同步的方式，解决了线程的安全问题。---好处 * 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性 * * @author shkstart * @create 2019-02-13 下午 4:47 */class Window1 implements Runnable&#123; private int ticket = 100;// Object obj = new Object();// Dog dog = new Dog(); @Override public void run() &#123;// Object obj = new Object(); while(true)&#123; synchronized (this)&#123;//此时的this:唯一的Window1的对象 //方式二：synchronized (dog) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window1 w = new Window1(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口1"); t2.setName("窗口2"); t3.setName("窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125;class Dog&#123;&#125; 使用同步代码块的方式处理继承方法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * @author shkstart * @create 2019-02-15 上午 11:15 *//** * 使用同步代码块解决继承Thread类的方式的线程安全问题 * * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。 * * @author shkstart * @create 2019-02-13 下午 4:20 */class Window2 extends Thread&#123; private static int ticket = 100; private static Object obj = new Object(); @Override public void run() &#123; while(true)&#123; //正确的// synchronized (obj)&#123; synchronized (Window2.class)&#123;//Class clazz = Window2.class,Window2.class只会加载一次 //错误的方式：this代表着t1,t2,t3三个对象// synchronized (this)&#123; if(ticket &gt; 0)&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + "：卖票，票号为：" + ticket); ticket--; &#125;else&#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName("窗口1"); t2.setName("窗口2"); t3.setName("窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125; 使用同步方法的方式处理Runable方法的12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用同步方法解决实现Runnable接口的线程安全问题 * * * 关于同步方法的总结： * 1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。 * 2. 非静态的同步方法，同步监视器是：this * 静态的同步方法，同步监视器是：当前类本身 * * @author shkstart * @create 2019-02-15 上午 11:35 */class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show()&#123;//同步监视器：this //synchronized (this)&#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + ":卖票，票号为：" + ticket); ticket--; &#125; //&#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 w = new Window3(); Thread t1 = new Thread(w); Thread t2 = new Thread(w); Thread t3 = new Thread(w); t1.setName("窗口1"); t2.setName("窗口2"); t3.setName("窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125; 使用同步方法的方式处理继承方法的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 使用同步方法处理继承Thread类的方式中的线程安全问题 * * @author shkstart * @create 2019-02-15 上午 11:43 */class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show()&#123;//同步监视器：Window4.class //private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "：卖票，票号为：" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName("窗口1"); t2.setName("窗口2"); t3.setName("窗口3"); t1.start(); t2.start(); t3.start(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2020%2F07%2F16%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式介绍所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory就够，这是就会使用到单例模式 单例设计模式八种方式单例模式有八种方式： 1) 饿汉式(静态常量) 2) 饿汉式（静态代码块） 3) 懒汉式(线程不安全) 4) 懒汉式(线程安全，同步方法) 5) 懒汉式(线程安全，同步代码块) 6) 双重检查 7) 静态内部类 8) 枚举 饿汉式（静态常量）123456789101112131415161718//饿汉式(静态变量)class Singleton &#123; //1. 构造器私有化, 外部能new private Singleton() &#123; &#125; //2.本类内部创建对象实例 private final static Singleton instance = new Singleton(); //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125; &#125; 饿汉式（静态代码块）123456789101112131415161718192021class Singleton &#123; //1. 构造器私有化, 外部能new private Singleton() &#123; &#125; //2.本类内部创建对象实例 private static Singleton instance; static &#123; // 在静态代码块中，创建单例对象 instance = new Singleton(); &#125; //3. 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125; &#125; 优缺点说明：1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同 ​ 步问题。 2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始 ​ 至终从未使用过这个实例，则会造成内存的浪费 3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载 ​ 时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载 ​ 的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类 ​ 装载，这时候初始化instance就没有达到lazy loading的效果 4) 结论：这种单例模式可用，可能造成内存浪费 懒汉式(线程不安全)1234567891011121314class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，当使用到该方法时，才去创建 instance //即懒汉式 public static Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优缺点说明：1) 起到了Lazy Loading的效果，但是只能在单线程下使用。 2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及 ​ 往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以 ​ 在多线程环境下不可使用这种方式 3) 结论：在实际开发中，不要使用这种方式. 懒汉式(线程安全，同步方法)123456789101112131415// 懒汉式(线程安全，同步方法)class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 //即懒汉式 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 优缺点说明：1) 解决了线程不安全问题 2) 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行 ​ 同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例， ​ 直接return就行了。方法进行同步效率太低 3) 结论：在实际开发中，不推荐使用这种方式 双重检查123456789101112131415161718192021// 懒汉式(线程安全，同步方法)class Singleton &#123; private static volatile Singleton instance; private Singleton() &#123;&#125; //提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题 //同时保证了效率, 推荐使用 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; synchronized (Singleton.class) &#123; if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 优缺点说明：1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两 ​ 次if (singleton == null)检查，这样就可以保证线程安全了。 2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)， ​ 直接return实例化对象，也避免的反复进行方法同步. 3) 线程安全；延迟加载；效率较高 4) 结论：在实际开发中，推荐使用这种单例设计模式 静态内部类12345678910111213141516171819// 静态内部类完成， 推荐使用class Singleton &#123; private static volatile Singleton instance; //构造器私有化 private Singleton() &#123;&#125; //写一个静态内部类,该类中有一个静态属性 Singleton private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; //提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE public static synchronized Singleton getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 优缺点说明：1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。 2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化 ​ 时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的 ​ 实例化。 3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们 ​ 保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 4) 优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高 5) 结论：推荐使用. 枚举1234567//使用枚举，可以实现单例, 推荐enum Singleton &#123; INSTANCE; //属性 public void sayOK() &#123; System.out.println("ok~"); &#125;&#125; 优缺点说明：1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而 ​ 且还能防止反序列化重新创建新的对象。 2) 这种方式是Effective Java作者Josh Bloch 提倡的方式 3) 结论：推荐使用]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程的基础]]></title>
    <url>%2F2020%2F07%2F15%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E9%94%AE%2F</url>
    <content type="text"><![CDATA[线程常用的方法 start():启动当前线程；调用当前线程的run() run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 currentThread():静态方法，返回执行当前代码的线程 getName():获取当前线程的名字 setName():设置当前线程的名字 yield():释放当前cpu的执行权 join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。 stop():已过时。当执行此方法时，强制结束当前线程。 sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前 线程是阻塞状态。 isAlive():判断当前线程是否存活 线程的优先级1.优先级 ​ MAX_PRIORITY：10 ​ MIN _PRIORITY：1 ​ NORM_PRIORITY：5 –&gt;默认优先级 2.如何获取和设置当前线程的优先级： ​ getPriority():获取线程的优先级 ​ setPriority(int p):设置线程的优先级 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。 用继承的方式创键线程 创建一个继承于Thread类的子类 重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start() 代码12345678910111213141516171819202122232425262728293031323334353637383940//1. 创建一个继承于Thread类的子类class MyThread extends Thread &#123; //2. 重写Thread类的run() @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125; &#125;&#125;public class ThreadTest &#123; public static void main(String[] args) &#123; //3. 创建Thread类的子类的对象 MyThread t1 = new MyThread(); //4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run() t1.start(); //问题一：我们不能通过直接调用run()的方式启动线程。// t1.run(); //问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException// t1.start(); //我们需要重新创建一个线程的对象 MyThread t2 = new MyThread(); t2.start(); //如下操作仍然是在main线程中执行的。 for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + ":" + i + "***********main()************"); &#125; &#125; &#125;&#125; 使用Runnable接口实现线程 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法：run() 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start() 123456789101112131415161718192021222324252627282930313233//1. 创建一个实现了Runnable接口的类class MThread implements Runnable&#123; //2. 实现类去实现Runnable中的抽象方法：run() @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0)&#123; System.out.println(Thread.currentThread().getName() + ":" + i); &#125; &#125; &#125;&#125;public class ThreadTest1 &#123; public static void main(String[] args) &#123; //3. 创建实现类的对象 MThread mThread = new MThread(); //4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 Thread t1 = new Thread(mThread); t1.setName("线程1"); //5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run() t1.start(); //再启动一个线程，遍历100以内的偶数 Thread t2 = new Thread(mThread); t2.setName("线程2"); t2.start(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。递归需要遵守的重要规则执行一个方法时，就创建一个新的受保护的独立空间(栈空间)方法的局部变量是独立的，不会相互影响, 比如n变量如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 递归-迷宫问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class MiGong &#123; public static void main(String[] args) &#123; // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1 表示墙 // 上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1;// map[1][2] = 1;// map[2][2] = 1; // 输出地图 System.out.println("地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 //setWay(map, 1, 1); setWay2(map, 1, 1); //输出新的地图, 小球走过，并标识过的递归 System.out.println("小球走过，并标识过的 地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[6][5] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) &#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay(map, i-1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125; //修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左 public static boolean setWay2(int[][] map, int i, int j) &#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 上-&gt;右-&gt;下-&gt;左 map[i][j] = 2; // 假定该点是可以走通. if(setWay2(map, i-1, j)) &#123;//向上走 return true; &#125; else if (setWay2(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay2(map, i+1, j)) &#123; //向下 return true; &#125; else if (setWay2(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;&#125; 递归-八皇后问题(回溯算法)八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max = 8; //定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; int[] array = new int[max]; static int count = 0; static int judgeCount = 0; public static void main(String[] args) &#123; //测试一把 ， 8皇后是否正确 Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf("一共有%d解法", count); System.out.printf("一共判断冲突的次数%d次", judgeCount); // 1.5w &#125; //编写一个方法，放置第n个皇后 //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) &#123; if(n == max) &#123; //n = 8 , 其实8个皇后就既然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i = 0; i &lt; max; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if(judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n+1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; //查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 /** * * @param n 表示第n个皇后 * @return */ private boolean judge(int n) &#123; judgeCount++; for(int i = 0; i &lt; n; i++) &#123; // 说明 //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 // n = 1 放置第 2列 1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀、中缀、后缀表达式]]></title>
    <url>%2F2020%2F07%2F03%2F%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取前缀表达式介绍前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈最后是-运算符，计算出35-6的值，即29，由此得出最终结果 中缀表达式介绍中缀表达式就是常见的运算表达式，如(3+4)×5-6 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.) 后缀表达式介绍后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 中举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 后缀表达式的计算机求值从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下: 从左至右扫描，将3和4压入堆栈；遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；将5入栈；接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；将6入栈；最后是-运算符，计算出35-6的值，即29，由此得出最终结果 逆波兰表达式计算器代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class ReversePolishMultiCalc &#123; /** * 匹配 + - * / ( ) 运算符 */ static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)"; static final String LEFT = "("; static final String RIGHT = ")"; static final String ADD = "+"; static final String MINUS= "-"; static final String TIMES = "*"; static final String DIVISION = "/"; /** * 加減 + - */ static final int LEVEL_01 = 1; /** * 乘除 * / */ static final int LEVEL_02 = 2; /** * 括号 */ static final int LEVEL_HIGH = Integer.MAX_VALUE; static Stack&lt;String&gt; stack = new Stack&lt;&gt;(); static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;()); /** * 去除所有空白符 * @param s * @return */ public static String replaceAllBlank(String s )&#123; // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v] return s.replaceAll("\\s+",""); &#125; /** * 判断是不是数字 int double long float * @param s * @return */ public static boolean isNumber(String s)&#123; Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$"); return pattern.matcher(s).matches(); &#125; /** * 判断是不是运算符 * @param s * @return */ public static boolean isSymbol(String s)&#123; return s.matches(SYMBOL); &#125; /** * 匹配运算等级 * @param s * @return */ public static int calcLevel(String s)&#123; if("+".equals(s) || "-".equals(s))&#123; return LEVEL_01; &#125; else if("*".equals(s) || "/".equals(s))&#123; return LEVEL_02; &#125; return LEVEL_HIGH; &#125; /** * 匹配 * @param s * @throws Exception */ public static List&lt;String&gt; doMatch (String s) throws Exception&#123; if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty"); if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number"); s = replaceAllBlank(s); String each; int start = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if(isSymbol(s.charAt(i)+""))&#123; each = s.charAt(i)+""; //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈 if(stack.isEmpty() || LEFT.equals(each) || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123; stack.push(each); &#125;else if( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123; //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈 while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123; if(calcLevel(stack.peek()) == LEVEL_HIGH)&#123; break; &#125; data.add(stack.pop()); &#125; stack.push(each); &#125;else if(RIGHT.equals(each))&#123; // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈 while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123; if(LEVEL_HIGH == calcLevel(stack.peek()))&#123; stack.pop(); break; &#125; data.add(stack.pop()); &#125; &#125; start = i ; //前一个运算符的位置 &#125;else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") )&#123; each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1); if(isNumber(each)) &#123; data.add(each); continue; &#125; throw new RuntimeException("data not match number"); &#125; &#125; //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列 Collections.reverse(stack); data.addAll(new ArrayList&lt;&gt;(stack)); System.out.println(data); return data; &#125; /** * 算出结果 * @param list * @return */ public static Double doCalc(List&lt;String&gt; list)&#123; Double d = 0d; if(list == null || list.isEmpty())&#123; return null; &#125; if (list.size() == 1)&#123; System.out.println(list); d = Double.valueOf(list.get(0)); return d; &#125; ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; list1.add(list.get(i)); if(isSymbol(list.get(i)))&#123; Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i)); list1.remove(i); list1.remove(i-1); list1.set(i-2,d1+""); list1.addAll(list.subList(i+1,list.size())); break; &#125; &#125; doCalc(list1); return d; &#125; /** * 运算 * @param s1 * @param s2 * @param symbol * @return */ public static Double doTheMath(String s1,String s2,String symbol)&#123; Double result ; switch (symbol)&#123; case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break; case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break; case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break; case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break; default : result = null; &#125; return result; &#125; public static void main(String[] args) &#123; //String math = "9+(3-1)*3+10/2"; String math = "12.8 + (2 - 3.55)*4+10/5.0"; try &#123; doCalc(doMatch(math)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 中缀表达式转换为后缀表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204public class PolandNotation &#123; public static void main(String[] args) &#123; //完成将一个中缀表达式转成后缀表达式的功能 //说明 //1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 – //2. 因为直接对str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的List // 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] //3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] String expression = "1+((2+3)*4)-5";//注意表达式 List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression); System.out.println("中缀表达式对应的List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList); System.out.println("后缀表达式对应的List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–] System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ? /* //先定义给逆波兰表达式 //(30+4)×5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164 // 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + //测试 //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -"; String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76 //思路 //1. 先将 "3 4 + 5 × 6 - " =&gt; 放到ArrayList中 //2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getListString(suffixExpression); System.out.println("rpnList=" + list); int res = calculate(list); System.out.println("计算的结果是=" + res); */ &#125; //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] //方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 //Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 储存中间结果的Lists2 //遍历ls for(String item: ls) &#123; //如果是一个数，加入s2 if(item.matches("\\d+")) &#123; s2.add(item); &#125; else if (item.equals("(")) &#123; s1.push(item); &#125; else if (item.equals(")")) &#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while(!s1.peek().equals("(")) &#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125; else &#123; //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 //问题：我们缺少一个比较优先级高低的方法 while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123; s2.add(s1.pop()); &#125; //还需要将item压入栈 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List &#125; //方法：将 中缀表达式转成对应的List // s="1+((2+3)×4)-5"; public static List&lt;String&gt; toInfixExpressionList(String s) &#123; //定义一个List,存放中缀表达式 对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串 String str; // 对多位数的拼接 char c; // 每遍历到一个字符，就放入到c do &#123; //如果c是一个非数字，我需要加入到ls if((c=s.charAt(i)) &lt; 48 || (c=s.charAt(i)) &gt; 57) &#123; ls.add("" + c); i++; //i需要后移 &#125; else &#123; //如果是一个数，需要考虑多位数 str = ""; //先将str 置成"" '0'[48]-&gt;'9'[57] while(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= 48 &amp;&amp; (c=s.charAt(i)) &lt;= 57) &#123; str += c;//拼接 i++; &#125; ls.add(str); &#125; &#125;while(i &lt; s.length()); return ls;//返回 &#125; //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getListString(String suffixExpression) &#123; //将 suffixExpression 分割 String[] split = suffixExpression.split(" "); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele: split) &#123; list.add(ele); &#125; return list; &#125; //完成对逆波兰表达式的运算 /* * 1)从左至右扫描，将3和4压入堆栈； 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 3)将5入栈； 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5)将6入栈； 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls) &#123; // 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 ls for (String item : ls) &#123; // 这里使用正则表达式来取出数 if (item.matches("\\d+")) &#123; // 匹配的是多位数 // 入栈 stack.push(item); &#125; else &#123; // pop出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals("+")) &#123; res = num1 + num2; &#125; else if (item.equals("-")) &#123; res = num1 - num2; &#125; else if (item.equals("*")) &#123; res = num1 * num2; &#125; else if (item.equals("/")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException("运算符有误"); &#125; //把res 入栈 stack.push("" + res); &#125; &#125; //最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125;//编写一个类 Operation 可以返回一个运算符 对应的优先级class Operation &#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回对应的优先级数字 public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case "+": result = ADD; break; case "-": result = SUB; break; case "*": result = MUL; break; case "/": result = DIV; break; default: System.out.println("不存在该运算符" + operation); break; &#125; return result; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍栈的英文为(stack)栈是一个先入后出(FILO-First In Last Out)的有序列表。栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class ArrayStackDemo &#123; public static void main(String[] args) &#123; //测试一下ArrayStack 是否正确 //先创建一个ArrayStack对象-&gt;表示栈 ArrayStack stack = new ArrayStack(4); String key = ""; boolean loop = true; //控制是否退出菜单 Scanner scanner = new Scanner(System.in); while(loop) &#123; System.out.println("show: 表示显示栈"); System.out.println("exit: 退出程序"); System.out.println("push: 表示添加数据到栈(入栈)"); System.out.println("pop: 表示从栈取出数据(出栈)"); System.out.println("请输入你的选择"); key = scanner.next(); switch (key) &#123; case "show": stack.list(); break; case "push": System.out.println("请输入一个数"); int value = scanner.nextInt(); stack.push(value); break; case "pop": try &#123; int res = stack.pop(); System.out.printf("出栈的数据是 %d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case "exit": scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~~"); &#125;&#125;//定义一个 ArrayStack 表示栈class ArrayStack &#123; private int maxSize; // 栈的大小 private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top表示栈顶，初始化为-1 //构造器 public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //栈满 public boolean isFull() &#123; return top == maxSize - 1; &#125; //栈空 public boolean isEmpty() &#123; return top == -1; &#125; //入栈-push public void push(int value) &#123; //先判断栈是否满 if(isFull()) &#123; System.out.println("栈满"); return; &#125; top++; stack[top] = value; &#125; //出栈-pop, 将栈顶的数据返回 public int pop() &#123; //先判断栈是否空 if(isEmpty()) &#123; //抛出异常 throw new RuntimeException("栈空，没有数据~"); &#125; int value = stack[top]; top--; return value; &#125; //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() &#123; if(isEmpty()) &#123; System.out.println("栈空，没有数据~~"); return; &#125; //需要从栈顶开始显示数据 for(int i = top; i &gt;= 0 ; i--) &#123; System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F03%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍链表是以节点的方式来存储,是链式存储每个节点包含 data 域， next 域：指向下一个节点.如图：发现链表的各个节点不一定是连续存储.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表介绍 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; //进行测试 //先创建节点 HeroNode hero1 = new HeroNode(1, "宋江", "及时雨"); HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟"); HeroNode hero3 = new HeroNode(3, "吴用", "智多星"); HeroNode hero4 = new HeroNode(4, "林冲", "豹子头"); //创建要给链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 singleLinkedList.add(hero1); singleLinkedList.add(hero4); singleLinkedList.add(hero2); singleLinkedList.add(hero3); // 测试一下单链表的反转功能 System.out.println("原来链表的情况~~"); singleLinkedList.list(); // System.out.println("反转单链表~~");// reversetList(singleLinkedList.getHead());// singleLinkedList.list(); System.out.println("测试逆序打印单链表, 没有改变链表的结构~~"); reversePrint(singleLinkedList.getHead()); /* //加入按照编号的顺序 singleLinkedList.addByOrder(hero1); singleLinkedList.addByOrder(hero4); singleLinkedList.addByOrder(hero2); singleLinkedList.addByOrder(hero3); //显示一把 singleLinkedList.list(); //测试修改节点的代码 HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~"); singleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况~~"); singleLinkedList.list(); //删除一个节点 singleLinkedList.del(1); singleLinkedList.del(4); System.out.println("删除后的链表情况~~"); singleLinkedList.list(); //测试一下 求单链表中有效节点的个数 System.out.println("有效的节点个数=" + getLength(singleLinkedList.getHead()));//2 //测试一下看看是否得到了倒数第K个节点 HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3); System.out.println("res=" + res);*/ &#125; //方式2： //可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode head) &#123; if(head.next == null) &#123; return;//空链表，不能打印 &#125; //创建要给一个栈，将各个节点压入栈 Stack&lt;HeroNode&gt; stack = new Stack&lt;HeroNode&gt;(); HeroNode cur = head.next; //将链表的所有节点压入栈 while(cur != null) &#123; stack.push(cur); cur = cur.next; //cur后移，这样就可以压入下一个节点 &#125; //将栈中的节点进行打印,pop 出栈 while (stack.size() &gt; 0) &#123; System.out.println(stack.pop()); //stack的特点是先进后出 &#125; &#125; //将单链表反转 public static void reversetList(HeroNode head) &#123; //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if(head.next == null || head.next.next == null) &#123; return ; &#125; //定义一个辅助的指针(变量)，帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next = null;// 指向当前节点[cur]的下一个节点 HeroNode reverseHead = new HeroNode(0, "", ""); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur != null) &#123; next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next = cur; //将cur 连接到新的链表上 cur = next;//让cur后移 &#125; //将head.next 指向 reverseHead.next , 实现单链表的反转 head.next = reverseHead.next; &#125; //查找单链表中的倒数第k个结点 【新浪面试题】 //思路 //1. 编写一个方法，接收head节点，同时接收一个index //2. index 表示是倒数第index个节点 //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 //5. 如果找到了，则返回该节点，否则返回nulll public static HeroNode findLastIndexNode(HeroNode head, int index) &#123; //判断如果链表为空，返回null if(head.next == null) &#123; return null;//没有找到 &#125; //第一个遍历得到链表的长度(节点个数) int size = getLength(head); //第二次遍历 size-index 位置，就是我们倒数的第K个节点 //先做一个index的校验 if(index &lt;=0 || index &gt; size) &#123; return null; &#125; //定义给辅助变量， for 循环定位到倒数的index HeroNode cur = head.next; //3 // 3 - 1 = 2 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; &#125; //方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) /** * * @param head 链表的头节点 * @return 返回的就是有效节点的个数 */ public static int getLength(HeroNode head) &#123; if(head.next == null) &#123; //空链表 return 0; &#125; int length = 0; //定义一个辅助的变量, 这里我们没有统计头节点 HeroNode cur = head.next; while(cur != null) &#123; length++; cur = cur.next; //遍历 &#125; return length; &#125;&#125;//定义SingleLinkedList 管理我们的英雄class SingleLinkedList &#123; //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode head = new HeroNode(0, "", ""); //返回头节点 public HeroNode getHead() &#123; return head; &#125; //添加节点到单向链表 //思路，当不考虑编号顺序时 //1. 找到当前链表的最后节点 //2. 将最后这个节点的next 指向 新的节点 public void add(HeroNode heroNode) &#123; //因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode temp = head; //遍历链表，找到最后 while(true) &#123; //找到链表的最后 if(temp.next == null) &#123;// break; &#125; //如果没有找到最后, 将将temp后移 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 //将最后这个节点的next 指向 新的节点 temp.next = heroNode; &#125; //第二种方式在添加英雄时，根据排名将英雄插入到指定位置 //(如果有这个排名，则添加失败，并给出提示) public void addByOrder(HeroNode heroNode) &#123; //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = head; boolean flag = false; // flag标志添加的编号是否存在，默认为false while(true) &#123; if(temp.next == null) &#123;//说明temp已经在链表的最后 break; // &#125; if(temp.next.no &gt; heroNode.no) &#123; //位置找到，就在temp的后面插入 break; &#125; else if (temp.next.no == heroNode.no) &#123;//说明希望添加的heroNode的编号已然存在 flag = true; //说明编号存在 break; &#125; temp = temp.next; //后移，遍历当前链表 &#125; //判断flag 的值 if(flag) &#123; //不能添加，说明编号存在 System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no); &#125; else &#123; //插入到链表中, temp的后面 heroNode.next = temp.next; temp.next = heroNode; &#125; &#125; //修改节点的信息, 根据no编号来修改，即no编号不能改. //说明 //1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode newHeroNode) &#123; //判断是否空 if(head.next == null) &#123; System.out.println("链表为空~"); return; &#125; //找到需要修改的节点, 根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false; //表示是否找到该节点 while(true) &#123; if (temp == null) &#123; break; //已经遍历完链表 &#125; if(temp.no == newHeroNode.no) &#123; //找到 flag = true; break; &#125; temp = temp.next; &#125; //根据flag 判断是否找到要修改的节点 if(flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; //没有找到 System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; //删除节点 //思路 //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点 //2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较 public void del(int no) &#123; HeroNode temp = head; boolean flag = false; // 标志是否找到待删除节点的 while(true) &#123; if(temp.next == null) &#123; //已经到链表的最后 break; &#125; if(temp.next.no == no) &#123; //找到的待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; //temp后移，遍历 &#125; //判断flag if(flag) &#123; //找到 //可以删除 temp.next = temp.next.next; &#125;else &#123; System.out.printf("要删除的 %d 节点不存在\n", no); &#125; &#125; //显示链表[遍历] public void list() &#123; //判断链表是否为空 if(head.next == null) &#123; System.out.println("链表为空"); return; &#125; //因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true) &#123; //判断是否到链表最后 if(temp == null) &#123; break; &#125; //输出节点的信息 System.out.println(temp); //将temp后移， 一定小心 temp = temp.next; &#125; &#125;&#125;//定义HeroNode ， 每个HeroNode 对象就是一个节点class HeroNode &#123; public int no; public String name; public String nickname; public HeroNode next; //指向下一个节点 //构造器 public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; //为了显示方法，我们重新toString @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + "]"; &#125; &#125; 双向链表介绍 双向链表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186public class DoubleLinkedListDemo &#123; public static void main(String[] args) &#123; // 测试 System.out.println("双向链表的测试"); // 先创建节点 HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨"); HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟"); HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星"); HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头"); // 创建一个双向链表 DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(hero1); doubleLinkedList.add(hero2); doubleLinkedList.add(hero3); doubleLinkedList.add(hero4); doubleLinkedList.list(); // 修改 HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙"); doubleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况"); doubleLinkedList.list(); // 删除 doubleLinkedList.del(3); System.out.println("删除后的链表情况~~"); doubleLinkedList.list(); &#125;&#125;// 创建一个双向链表的类class DoubleLinkedList &#123; // 先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode2 head = new HeroNode2(0, "", ""); // 返回头节点 public HeroNode2 getHead() &#123; return head; &#125; // 遍历双向链表的方法 // 显示链表[遍历] public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode2 temp = head.next; while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点的信息 System.out.println(temp); // 将temp后移， 一定小心 temp = temp.next; &#125; &#125; // 添加一个节点到双向链表的最后. public void add(HeroNode2 heroNode) &#123; // 因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode2 temp = head; // 遍历链表，找到最后 while (true) &#123; // 找到链表的最后 if (temp.next == null) &#123;// break; &#125; // 如果没有找到最后, 将将temp后移 temp = temp.next; &#125; // 当退出while循环时，temp就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; &#125; // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样 // 只是 节点类型改成 HeroNode2 public void update(HeroNode2 newHeroNode) &#123; // 判断是否空 if (head.next == null) &#123; System.out.println("链表为空~"); return; &#125; // 找到需要修改的节点, 根据no编号 // 定义一个辅助变量 HeroNode2 temp = head.next; boolean flag = false; // 表示是否找到该节点 while (true) &#123; if (temp == null) &#123; break; // 已经遍历完链表 &#125; if (temp.no == newHeroNode.no) &#123; // 找到 flag = true; break; &#125; temp = temp.next; &#125; // 根据flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; // 没有找到 System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; // 从双向链表中删除一个节点, // 说明 // 1 对于双向链表，我们可以直接找到要删除的这个节点 // 2 找到后，自我删除即可 public void del(int no) &#123; // 判断当前链表是否为空 if (head.next == null) &#123;// 空链表 System.out.println("链表为空，无法删除"); return; &#125; HeroNode2 temp = head.next; // 辅助变量(指针) boolean flag = false; // 标志是否找到待删除节点的 while (true) &#123; if (temp == null) &#123; // 已经到链表的最后 break; &#125; if (temp.no == no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; // temp后移，遍历 &#125; // 判断flag if (flag) &#123; // 找到 // 可以删除 // temp.next = temp.next.next;[单向链表] temp.pre.next = temp.next; // 这里我们的代码有问题? // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) &#123; temp.next.pre = temp.pre; &#125; &#125; else &#123; System.out.printf("要删除的 %d 节点不存在\n", no); &#125; &#125;&#125;// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点class HeroNode2 &#123; public int no; public String name; public String nickname; public HeroNode2 next; // 指向下一个节点, 默认为null public HeroNode2 pre; // 指向前一个节点, 默认为null // 构造器 public HeroNode2(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; // 为了显示方法，我们重新toString @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + "]"; &#125;&#125; 单向环形链表介绍 单向环形链表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class Josepfu &#123; public static void main(String[] args) &#123; // 测试一把看看构建环形链表，和遍历是否ok CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addBoy(125);// 加入5个小孩节点 circleSingleLinkedList.showBoy(); //测试一把小孩出圈是否正确 circleSingleLinkedList.countBoy(10, 20, 125); // 2-&gt;4-&gt;1-&gt;5-&gt;3 //String str = "7*2*2-5+1-5+3-3"; &#125;&#125;// 创建一个环形的单向链表class CircleSingleLinkedList &#123; // 创建一个first节点,当前没有编号 private Boy first = null; // 添加小孩节点，构建成一个环形的链表 public void addBoy(int nums) &#123; // nums 做一个数据校验 if (nums &lt; 1) &#123; System.out.println("nums的值不正确"); return; &#125; Boy curBoy = null; // 辅助指针，帮助构建环形链表 // 使用for来创建我们的环形链表 for (int i = 1; i &lt;= nums; i++) &#123; // 根据编号，创建小孩节点 Boy boy = new Boy(i); // 如果是第一个小孩 if (i == 1) &#123; first = boy; first.setNext(first); // 构成环 curBoy = first; // 让curBoy指向第一个小孩 &#125; else &#123; curBoy.setNext(boy);// boy.setNext(first);// curBoy = boy; &#125; &#125; &#125; // 遍历当前的环形链表 public void showBoy() &#123; // 判断链表是否为空 if (first == null) &#123; System.out.println("没有任何小孩~~"); return; &#125; // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) &#123; System.out.printf("小孩的编号 %d \n", curBoy.getNo()); if (curBoy.getNext() == first) &#123;// 说明已经遍历完毕 break; &#125; curBoy = curBoy.getNext(); // curBoy后移 &#125; &#125; // 根据用户的输入，计算出小孩出圈的顺序 /** * * @param startNo * 表示从第几个小孩开始数数 * @param countNum * 表示数几下 * @param nums * 表示最初有多少小孩在圈中 */ public void countBoy(int startNo, int countNum, int nums) &#123; // 先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println("参数输入有误， 请重新输入"); return; &#125; // 创建要给辅助指针,帮助完成小孩出圈 Boy helper = first; // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) &#123; if (helper.getNext() == first) &#123; // 说明helper指向最后小孩节点 break; &#125; helper = helper.getNext(); &#125; //小孩报数前，先让 first 和 helper 移动 k - 1次 for(int j = 0; j &lt; startNo - 1; j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈 //这里是一个循环操作，知道圈中只有一个节点 while(true) &#123; if(helper == first) &#123; //说明圈中只有一个节点 break; &#125; //让 first 和 helper 指针同时 的移动 countNum - 1 for(int j = 0; j &lt; countNum - 1; j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //这时first指向的节点，就是要出圈的小孩节点 System.out.printf("小孩%d出圈\n", first.getNo()); //这时将first指向的小孩节点出圈 first = first.getNext(); helper.setNext(first); // &#125; System.out.printf("最后留在圈中的小孩编号%d \n", first.getNo()); &#125;&#125;// 创建一个Boy类，表示一个节点class Boy &#123; private int no;// 编号 private Boy next; // 指向下一个节点,默认null public Boy(int no) &#123; this.no = no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; ##]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F03%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍队列是一个有序列表，可以用数组或是链表来实现。遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出数组模拟队列队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //测试一把 //创建一个队列 ArrayQueue queue = new ArrayQueue(3); char key = ' '; //接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;// 使用数组模拟队列-编写一个ArrayQueue类class ArrayQueue &#123; private int maxSize; // 表示数组的最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 // 创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; // 指向队列头部，分析出front是指向队列头的前一个位置. rear = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据) &#125; // 判断队列是否满 public boolean isFull() &#123; return rear == maxSize - 1; &#125; // 判断队列是否为空 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; rear++; // 让rear 后移 arr[rear] = n; &#125; // 获取队列的数据, 出队列 public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; front++; // front后移 return arr[front]; &#125; // 显示队列的所有数据 public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf("arr[%d]=%d\n", i, arr[i]); &#125; &#125; // 显示队列的头数据， 注意不是取出数据 public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front + 1]; &#125;&#125; 数组模拟环形队列尾索引的下一个为头索引时表示队列满，即将队 列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满]rear == front [空] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class CircleArrayQueueDemo &#123; public static void main(String[] args) &#123; //测试一把 System.out.println("测试数组模拟环形队列的案例~~~"); // 创建一个环形队列 CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3 char key = ' '; // 接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); key = scanner.next().charAt(0);// 接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': // 取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': // 查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': // 退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;class CircleArray &#123; private int maxSize; // 表示数组的最大容量 //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 //front 的初始值 = 0 private int front; //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定. //rear 的初始值 = 0 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; // 判断队列是否满 public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; // 判断队列是否为空 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; //直接将数据加入 arr[rear] = n; //将 rear 后移, 这里必须考虑取模 rear = (rear + 1) % maxSize; &#125; // 获取队列的数据, 出队列 public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; // 这里需要分析出 front是指向队列的第一个元素 // 1. 先把 front 对应的值保留到一个临时变量 // 2. 将 front 后移, 考虑取模 // 3. 将临时保存的变量返回 int value = arr[front]; front = (front + 1) % maxSize; return value; &#125; // 显示队列的所有数据 public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; // 思路：从front开始遍历，遍历多少个元素 // 动脑筋 for (int i = front; i &lt; front + size() ; i++) &#123; System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]); &#125; &#125; // 求出当前队列有效数据的个数 public int size() &#123; // rear = 2 // front = 1 // maxSize = 3 return (rear + maxSize - front) % maxSize; &#125; // 显示队列的头数据， 注意不是取出数据 public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组]]></title>
    <url>%2F2020%2F07%2F03%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是:记录数组一共有几行几列，有多少个不同的值把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class SparseArray &#123; public static void main(String[] args) &#123; // 创建一个原始的二维数组 11 * 11 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 输出原始的二维数组 System.out.println("原始的二维数组~~"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; // 将二维数组 转 稀疏数组的思 // 1. 先遍历二维数组 得到非0数据的个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; // 2. 创建对应的稀疏数组 int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非0的值存放到 sparseArr中 int count = 0; //count 用于记录是第几个非0数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; // 输出稀疏数组的形式 System.out.println(); System.out.println("得到稀疏数组为~~~~"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); //将稀疏数组 --》 恢复成 原始的二维数组 /* * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可. */ //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可 for(int i = 1; i &lt; sparseArr.length; i++) &#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; // 输出恢复后的二维数组 System.out.println(); System.out.println("恢复后的二维数组"); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波拉契查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class FibonacciSearch &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int [] arr = &#123;1,8, 10, 89, 1000, 1234&#125;; System.out.println("index=" + fibSearch(arr, 189));// 0 &#125; //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; //编写斐波那契查找算法 //使用非递归的方式编写算法 /** * * @param a 数组 * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1 */ public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; int k = 0; //表示斐波那契分割数值的下标 int mid = 0; //存放mid值 int f[] = fib(); //获取到斐波那契数列 //获取到斐波那契分割数值的下标 while(high &gt; f[k] - 1) &#123; k++; &#125; //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a数组最后的数填充 temp //举例: //temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125; for(int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; // 使用while来循环处理，找到我们的数 key while (low &lt;= high) &#123; // 只要这个条件满足，就可以找 mid = low + f[k - 1] - 1; if(key &lt; temp[mid]) &#123; //我们应该继续向数组的前面查找(左边) high = mid - 1; //为甚是 k-- //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3] //即 在 f[k-1] 的前面继续查找 k-- //即下次循环 mid = f[k-1-1]-1 k--; &#125; else if ( key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边) low = mid + 1; //为什么是k -=2 //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4] //4. 即在f[k-2] 的前面进行查找 k -=2 //5. 即下次循环 mid = f[k - 1 - 2] - 1 k -= 2; &#125; else &#123; //找到 //需要确定，返回的是哪个下标 if(mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class InsertValueSearch &#123; public static void main(String[] args) &#123; // int [] arr = new int[100];// for(int i = 0; i &lt; 100; i++) &#123;// arr[i] = i + 1;// &#125; int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;; int index = insertValueSearch(arr, 0, arr.length - 1, 1234); //int index = binarySearch(arr, 0, arr.length, 1); System.out.println("index = " + index); //System.out.println(Arrays.toString(arr)); &#125; public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; System.out.println("二分查找被调用~"); // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; //编写插值查找算法 //说明：插值查找算法，也要求数组是有序的 /** * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到，返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; System.out.println("插值查找次数~~"); //注意：findVal &lt; arr[0] 和 findVal &gt; arr[arr.length - 1] 必须需要 //否则我们得到的 mid 可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123; return -1; &#125; // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 递归代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class BinarySearch &#123; public static void main(String[] args) &#123; //int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 &#125;; //// int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);// System.out.println("resIndex=" + resIndex); List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1); System.out.println("resIndexList=" + resIndexList); &#125; // 二分查找算法 /** * * @param arr * 数组 * @param left * 左边的索引 * @param right * 右边的索引 * @param findVal * 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回 -1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; //完成一个课后思考题: /* * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000 * * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123; System.out.println("hello~"); // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch2(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch2(arr, left, mid - 1, findVal); &#125; else &#123;// * 思路分析// * 1. 在找到mid 索引值，不要马上返回// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList// * 4. 将Arraylist返回 List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); //向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList int temp = mid - 1; while(true) &#123; if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出 break; &#125; //否则，就temp 放入到 resIndexlist resIndexlist.add(temp); temp -= 1; //temp左移 &#125; resIndexlist.add(mid); // //向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList temp = mid + 1; while(true) &#123; if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123;//退出 break; &#125; //否则，就temp 放入到 resIndexlist resIndexlist.add(temp); temp += 1; //temp右移 &#125; return resIndexlist; &#125; &#125;&#125; 非递归代码12345678910111213141516171819202122232425262728293031323334public class BinarySearchNoRecur &#123; public static void main(String[] args) &#123; //测试 int[] arr = &#123;1,3, 8, 10, 11, 67, 100&#125;; int index = binarySearch(arr, 100); System.out.println("index=" + index);// &#125; //二分查找的非递归实现 /** * * @param arr 待查找的数组, arr是升序排序 * @param target 需要查找的数 * @return 返回对应下标，-1表示没有找到 */ public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while(left &lt;= right) &#123; //说明继续查找 int mid = (left + right) / 2; if(arr[mid] == target) &#123; return mid; &#125; else if ( arr[mid] &gt; target) &#123; right = mid - 1;//需要向左边查找 &#125; else &#123; left = mid + 1; //需要向右边查找 &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 时间复杂度与空间复杂度和稳定性它的最坏，最好，平均时间复杂度均为O(nlogn)，。空间复杂度是 O(1)，稳定性为不稳定 排序思想堆排序的基本思想是：将待排序序列构造成一个大顶堆此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class HeapSort &#123; public static void main(String[] args) &#123; //要求将数组进行升序排序 //int arr[] = &#123;4, 6, 8, 5, 9&#125;; // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); heapSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("排序后=" + Arrays.toString(arr)); &#125; //编写一个堆排序的方法 public static void heapSort(int arr[]) &#123; int temp = 0; System.out.println("堆排序!!"); // //分步完成// adjustHeap(arr, 1, arr.length);// System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6// // adjustHeap(arr, 0, arr.length);// System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for(int i = arr.length / 2 -1; i &gt;=0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; /* * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for(int j = arr.length-1;j &gt;0; j--) &#123; //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); &#125; //System.out.println("数组=" + Arrays.toString(arr)); &#125; //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125; * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) &#123; int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for(int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) &#123; if(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) &#123; //说明左子结点的值小于右子结点的值 k++; // k 指向右子结点 &#125; if(arr[k] &gt; temp) &#123; //如果子结点大于父结点 arr[i] = arr[k]; //把较大的值赋给当前结点 i = k; //!!! i 指向 k,继续循环比较 &#125; else &#123; break;//! &#125; &#125; //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法基数排序(Radix Sort)是桶排序的扩展基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 时间复杂度与空间复杂度和稳定性基数排序在最坏，平均情况下时间复杂度为O(d(r+n))，最好情况为O(d(n+rd))，空间复杂度是 O(rd+n)，稳定性为稳定 排序思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123; 53, 3, 542, 748, 14, 214&#125;; // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G // int[] arr = new int[8000000];// for (int i = 0; i &lt; 8000000; i++) &#123;// arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数// &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); radixSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); System.out.println("基数排序后 " + Arrays.toString(arr)); &#125; //基数排序方法 public static void radixSort(int[] arr) &#123; //根据前面的推导过程，我们可以得到最终的基数排序代码 //1. 得到数组中最大的数的位数 int max = arr[0]; //假设第一数就是最大数 for(int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //得到最大数是几位数 int maxLength = (max + "").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 名明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; //这里我们使用循环将代码处理 for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123; //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位.. for(int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; //放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放入到原数组 if(bucketElementCounts[k] != 0) &#123; //循环该桶即第k个桶(即第k个一维数组), 放入 for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; //System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr)); &#125; /* //第1轮(针对每个元素的个位进行排序处理) for(int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的个位的值 int digitOfElement = arr[j] / 1 % 10; //放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放入到原数组 if(bucketElementCounts[k] != 0) &#123; //循环该桶即第k个桶(即第k个一维数组), 放入 for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr)); //========================================== //第2轮(针对每个元素的十位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的十位的值 int digitOfElement = arr[j] / 10 % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(即第k个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr)); //第3轮(针对每个元素的百位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的百位的值 int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(即第k个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 时间复杂度与空间复杂度和稳定性归并排序在平均和最好及最坏情况下的时间复杂度是 O(nlog2n)，空间复杂度是 O(1)，稳定性为稳定 排序思想 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MergetSort &#123; public static void main(String[] args) &#123; //int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; // //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); int temp[] = new int[arr.length]; //归并排序需要一个额外空间 mergeSort(arr, 0, arr.length - 1, temp); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("归并排序后=" + Arrays.toString(arr)); &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if(left &lt; right) &#123; int mid = (left + right) / 2; //中间索引 //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; //合并的方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i, 左边有序序列的初始索引 int j = mid + 1; //初始化j, 右边有序序列的初始索引 int t = 0; // 指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续 //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if(arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; //(二) //把有剩余数据的一边的数据依次全部填充到temp while( i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while( j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; &#125; //(三) //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t = 0; int tempLeft = left; // //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3 //最后一次 tempLeft = 0 right = 7 while(tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍快速排序（Quicksort）是对冒泡排序的一种改进时间复杂度与空间复杂度和稳定性快速排序在最坏情况下的时间复杂度是 O(n^2)，最好和平均情况下是 O(nlog2n)，空间复杂度是 O(nlog2n)，稳定性为不稳定 排序思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class QuickSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;; //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); quickSort(arr, 0, arr.length-1); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("arr=" + Arrays.toString(arr)); &#125; public static void quickSort(int[] arr,int left, int right) &#123; int l = left; //左下标 int r = right; //右下标 //pivot 中轴值 int pivot = arr[(left + right) / 2]; int temp = 0; //临时变量，作为交换时使用 //while循环的目的是让比pivot 值小放到左边 //比pivot 值大放到右边 while( l &lt; r) &#123; //在pivot的左边一直找,找到大于等于pivot值,才退出 while( arr[l] &lt; pivot) &#123; l += 1; &#125; //在pivot的右边一直找,找到小于等于pivot值,才退出 while(arr[r] &gt; pivot) &#123; r -= 1; &#125; //如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值 if( l &gt;= r) &#123; break; &#125; //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移 if(arr[l] == pivot) &#123; r -= 1; &#125; //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移 if(arr[r] == pivot) &#123; l += 1; &#125; &#125; // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if(left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if(right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。时间复杂度与空间复杂度和稳定性希尔排序在最坏情况时间复杂度是 O(n^2)，在最好情况下是O(n^1.3),平均为O(n),空间复杂度是 O(1），稳定性为不稳定 排序思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ShellSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;; // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); //shellSort(arr); //交换式 shellSort2(arr);//移位方式 Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println(Arrays.toString(arr)); &#125; // 使用逐步推导的方式来编写希尔排序 // 希尔排序时， 对有序序列在插入时采用交换法, // 思路(算法) ===&gt; 代码 public static void shellSort(int[] arr) &#123; int temp = 0; int count = 0; // 根据前面的逐步分析，使用循环处理 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap for (int j = i - gap; j &gt;= 0; j -= gap) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; //System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr)); &#125; /* // 希尔排序的第1轮排序 // 因为第1轮排序，是将10个数据分成了 5组 for (int i = 5; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 5; j &gt;= 0; j -= 5) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 5]) &#123; temp = arr[j]; arr[j] = arr[j + 5]; arr[j + 5] = temp; &#125; &#125; &#125; System.out.println("希尔排序1轮后=" + Arrays.toString(arr));// // 希尔排序的第2轮排序 // 因为第2轮排序，是将10个数据分成了 5/2 = 2组 for (int i = 2; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 2; j &gt;= 0; j -= 2) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 2]) &#123; temp = arr[j]; arr[j] = arr[j + 2]; arr[j + 2] = temp; &#125; &#125; &#125; System.out.println("希尔排序2轮后=" + Arrays.toString(arr));// // 希尔排序的第3轮排序 // 因为第3轮排序，是将10个数据分成了 2/2 = 1组 for (int i = 1; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 1; j &gt;= 0; j -= 1) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println("希尔排序3轮后=" + Arrays.toString(arr));// */ &#125; //对交换式的希尔排序进行优化-&gt;移位法 public static void shellSort2(int[] arr) &#123; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j-gap]; j -= gap; &#125; //当退出while后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。时间复杂度与空间复杂度和稳定性插入排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 排序思想把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class InsertSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123;101, 34, 119, 1, -1, 89&#125;; // 创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("插入排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); insertSort(arr); //调用插入排序算法 Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println(Arrays.toString(arr)); &#125; //插入排序 public static void insertSort(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; //使用for循环来把代码简化 for(int i = 1; i &lt; arr.length; i++) &#123; //定义待插入的数 insertVal = arr[i]; insertIndex = i - 1; // 即arr[1]的前面这个数的下标 // 给insertVal 找到插入的位置 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; // 当退出while循环时，说明插入的位置找到, insertIndex + 1 // 举例：理解不了，我们一会 debug //这里我们判断是否需要赋值 if(insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; //System.out.println("第"+i+"轮插入"); //System.out.println(Arrays.toString(arr)); &#125; /* //使用逐步推导的方式来讲解，便利理解 //第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125; //&#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125; //定义待插入的数 int insertVal = arr[1]; int insertIndex = 1 - 1; //即arr[1]的前面这个数的下标 //给insertVal 找到插入的位置 //说明 //1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 //2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 //3. 就需要将 arr[insertIndex] 后移 while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; //当退出while循环时，说明插入的位置找到, insertIndex + 1 //举例：理解不了，我们一会 debug arr[insertIndex + 1] = insertVal; System.out.println("第1轮插入"); System.out.println(Arrays.toString(arr)); //第2轮 insertVal = arr[2]; insertIndex = 2 - 1; while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println("第2轮插入"); System.out.println(Arrays.toString(arr)); //第3轮 insertVal = arr[3]; insertIndex = 3 - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println("第3轮插入"); System.out.println(Arrays.toString(arr)); */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。时间复杂度与空间复杂度和稳定性选择排序在平均和最坏情况下及最好情况下的时间复杂度是 O(n^2)，空间复杂度是 O(1），稳定性为不稳定 排序思想第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class SelectSort &#123; public static void main(String[] args) &#123; //int [] arr = &#123;101, 34, 119, 1, -1, 90, 123&#125;; //创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); //System.out.println(Arrays.toString(arr)); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); selectSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("排序后"); //System.out.println(Arrays.toString(arr)); &#125; //选择排序 public static void selectSort(int[] arr) &#123; //在推导的过程，我们发现了规律，因此，可以使用for来解决 //选择排序时间复杂度是 O(n^2) for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; //System.out.println("第"+(i+1)+"轮后~~"); //System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 &#125; /* //使用逐步推导的方式来，讲解选择排序 //第1轮 //原始的数组 ： 101, 34, 119, 1 //第一轮排序 : 1, 34, 119, 101 //算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决 //第1轮 int minIndex = 0; int min = arr[0]; for(int j = 0 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小 min = arr[j]; //重置min minIndex = j; //重置minIndex &#125; &#125; //将最小值，放在arr[0], 即交换 if(minIndex != 0) &#123; arr[minIndex] = arr[0]; arr[0] = min; &#125; System.out.println("第1轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第2轮 minIndex = 1; min = arr[1]; for (int j = 1 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if(minIndex != 1) &#123; arr[minIndex] = arr[1]; arr[1] = min; &#125; System.out.println("第2轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第3轮 minIndex = 2; min = arr[2]; for (int j = 2 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if (minIndex != 2) &#123; arr[minIndex] = arr[2]; arr[2] = min; &#125; System.out.println("第3轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。时间复杂度与空间复杂度和稳定性 冒泡排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class BubbleSort &#123; public static void main(String[] args) &#123;// int arr[] = &#123;3, 9, -1, 10, 20&#125;;// // System.out.println("排序前");// System.out.println(Arrays.toString(arr)); //为了容量理解，我们把冒泡排序的演变过程，给大家展示 //测试一下冒泡排序的速度O(n^2), 给80000个数据，测试 //创建要给80000个的随机的数组 int[] arr = new int[80000]; for(int i =0; i &lt; 80000;i++) &#123; arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数 &#125; Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); //测试冒泡排序 bubbleSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序后的时间是=" + date2Str); //System.out.println("排序后"); //System.out.println(Arrays.toString(arr)); /* // 第二趟排序，就是将第二大的数排在倒数第二位 for (int j = 0; j &lt; arr.length - 1 - 1 ; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第二趟排序后的数组"); System.out.println(Arrays.toString(arr)); // 第三趟排序，就是将第三大的数排在倒数第三位 for (int j = 0; j &lt; arr.length - 1 - 2; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第三趟排序后的数组"); System.out.println(Arrays.toString(arr)); // 第四趟排序，就是将第4大的数排在倒数第4位 for (int j = 0; j &lt; arr.length - 1 - 3; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第四趟排序后的数组"); System.out.println(Arrays.toString(arr)); */ &#125; // 将前面额冒泡排序算法，封装成一个方法 public static void bubbleSort(int[] arr) &#123; // 冒泡排序 的时间复杂度 O(n^2), 自己写出 int temp = 0; // 临时变量 boolean flag = false; // 标识变量，表示是否进行过交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; //System.out.println("第" + (i + 1) + "趟排序后的数组"); //System.out.println(Arrays.toString(arr)); if (!flag) &#123; // 在一趟排序中，一次交换都没有发生过 break; &#125; else &#123; flag = false; // 重置flag!!!, 进行下次判断 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 如何集成 Swagger]]></title>
    <url>%2F2019%2F09%2F26%2FSpringboot-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90-Swagger%2F</url>
    <content type="text"><![CDATA[随着本人摸鱼天数的增加，本人开始学习各种东西，今天说一个比较好用的工具Swagger。这个工具的好处是可以将后台的API接口直接暴露出来，这样前端工程师写接口传参的时候，就可以很快也很方便了。Springboot如何集成Swagger首先你需要在pom.xml中加入以下代码123456789101112&lt;!-- 集成swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 具体要加入什么版本，大家自己可以去maven仓库中寻找，本人写的时候最新是2.9.2就用它了。 然后创建一个配置类Swagger2Config.java 123456789101112131415161718192021222324252627282930313233343536package com.nano.roupian.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.nano.roupian")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("肉片系统Restful API") .description("肉片系统Restful API") .termsOfServiceUrl("http://127.0.0.1:8080/") .version("1.0") .build(); &#125; &#125; 其中basePackage后面 跟的参数是你要扫描的包，而termsofServiceUrl后面跟的是swaggerUI展示的地址，这些搞好后你，你只需要去http://localhost:8080/swagger-ui.html 中就能查看到后台API了。更多详情请大家自己去官网学习把。]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Springboot</tag>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat 怎么将属性值设为null]]></title>
    <url>%2F2019%2F09%2F26%2FNavicat-%E6%80%8E%E4%B9%88%E5%B0%86%E5%B1%9E%E6%80%A7%E5%80%BC%E8%AE%BE%E4%B8%BAnull%2F</url>
    <content type="text"><![CDATA[最近本人在搞代码自测时，被一个很蠢的坑搞了，故今天分享并mark，以让自己以后不犯傻。这个坑，主要形成是这样的，作者将mysql表中的一个属性的属性值删除了，结果以为这个属性值为空了，却没想到其实为空串，于是让本人犯了一个较为愚蠢的NullPoint异常，现在就说下怎么才能删的干净。怎么用navicat改为null 由于这是涉及简单操作的事情，所以我就用图来解释把。 First Second鼠标点击那个值然后右击]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Java连接微信公众号后台，获取接口，与token]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8Etoken%2F</url>
    <content type="text"><![CDATA[如何打开微信公众号开发者模式相信如果如果玩过公众号都知道，要打开公众号配置，需要一个服务器地址，不过大部分人玩它是用来搞测试的，所以我就介绍一个免费的用来反向代理的软件 ngork，用它你就可以将自己8080 端口暴露给外网，而且使用简单，只需要打开它然后输入ngrok http 8080 命令就行了 java来写接入代码这代码我是从网上看哔哩哔哩写的 如果，有兴趣可以直接哔哩哔哩 java微信公众号就能收到了，首先创建一个servlet，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package WeiXinServlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import Service.WxService;/** * Servlet implementation class wxServlet */@WebServlet("/wxServlet")public class wxServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public wxServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.print("--------------------------------------"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); String echostr = request.getParameter("echostr"); //较验证请求 if(WxService.check(timestamp,nonce,signature)) &#123; PrintWriter out = response.getWriter(); //原样返回echostr参数 out.println(echostr); out.flush(); out.close(); System.out.println("接入成功"); &#125;else &#123; System.out.println("接入失败"); &#125; &#125;&#125; 通过get方法来接收传来的参数，因为微信公众号开发需要通过这三个参数，通过SHA1加密认证. 再写个service来做SHA1加密认证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String APPID = "wxf2a10b83349c22a3"; //这个为你在配置页得到的自己的APPID private static final String APPSECRET = "749b5f9f551d30723a7d20646749cddb"; //这个为你在配置页得到的自己的APPSECRE private static final String TOKEN = "abc"; //这个为你在配置页提阿涅的TOKEN&#125;/** * * 验证签名 */ public static boolean check(String timestamp,String nonce , String signature) &#123; //1. 将token、timestamp、nonce三个蚕食进行字典序排序 String[] strs = new String[] &#123;TOKEN,timestamp,nonce&#125;; Arrays.sort(strs); //2. 将三个参数字符串拼接成一个字符串进行sha1加密 String str = strs[0]+strs[1]+strs[2]; String mysia = sha1(str); System.out.println("到达check方法中！"); System.out.println(mysia); System.out.println(signature); //3. 开发者获得加密后的字符串与signature对比，标识该请求来源于微信 return mysia.equalsIgnoreCase(signature); &#125; private static String sha1(String src) &#123; try &#123; //获取加密对象 MessageDigest md = MessageDigest.getInstance("sha1"); //加密 byte[] digest = md.digest(src.getBytes()); char[] chars = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; StringBuilder sb = new StringBuilder(); //处理加密结果 for(byte b:digest) &#123; sb.append(chars[(b&gt;&gt;4)&amp;15]); sb.append(chars[b&amp;15]); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println("error:"+e.getMessage()); &#125; return null; &#125; /** * 获取signature * 特别注意的是调用微信js，url必须是当前页面(转发的不行) * @throws Exception */ public static String getSignature(String url) throws Exception&#123;// 第三步:对密钥进行sha1加密 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String ticket = getJsApiTicket(); long time = System.currentTimeMillis()/1000; String randomStr = "1485965214789631"; String str = "jsapi_ticket=" + ticket + "&amp;noncestr=" + randomStr+ "&amp;timestamp=" + time + "&amp;url="+url; String signature = ""; try &#123; MessageDigest crypt = MessageDigest.getInstance("SHA-1"); crypt.reset(); crypt.update(str.getBytes("UTF-8")); //对string1 字符串进行SHA-1加密处理 signature = byteToHex(crypt.digest()); //对加密后字符串转成16进制// signature = sha1(str); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("signature生成失败!"); &#125; map.put("timeStamp", String.valueOf(time)); map.put("randomStr", randomStr); map.put("signature", signature); System.out.println("ticket:"+ticket+",result:"+com.alibaba.fastjson.JSONObject.toJSONString(map)); return com.alibaba.fastjson.JSON.toJSONString(map); &#125; private static String byteToHex(final byte[] hash) &#123; Formatter formatter = new Formatter(); for (byte b : hash) &#123; formatter.format("%02x", b); &#125; String result = formatter.toString(); formatter.close(); return result; &#125; 然后再接口配置信息填写ngrok改的URL 再点击确认 就可以了，这期间需要点时间等候 用java写获取token的方法因为微信公众号大部分功能需要获取token才能搞的，所以这里写下方法 创建个AccessToken的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.whale.weixin.entity;/** * 保存Token（只有俩个小时的时限） * * */public class AccessToken &#123; private String accessToken; //计算过期时间 private long expireTime; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(long expireTime) &#123; this.expireTime = expireTime; &#125; public AccessToken(String accessToken, String expireIn) &#123; super(); this.accessToken = accessToken; this.expireTime = System.currentTimeMillis()+Integer.parseInt(expireIn)*1000; &#125; /** * 判断token是否过期 * @return */ public boolean isExpired() &#123; return System.currentTimeMillis()&gt;expireTime; &#125; &#125; 创建个工具类来发get与post 请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.whale.weixin.util;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class Util &#123; // 用于存储token /** * 向指定的地址发送get请求 用于获取微信Token * * @param url * @return */ public static String get(String url) &#123; try &#123; URL urlObj = new URL(url); // 开链接 URLConnection connection = urlObj.openConnection(); InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125; /** * 向指定地址发送一个post请求，待着data数据 * * @param url * @param data * @return */ public static String post(String url, String data) &#123; try &#123; URL urlObject = new URL(url); URLConnection connection = urlObject.openConnection(); // 要发鸿数据出去，必须要发送可发送数据状态 connection.setDoOutput(true); // 获取输出流 OutputStream os = connection.getOutputStream(); // 写出数据 os.write(data.getBytes()); os.close(); // 获取输入流 InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125;&#125; 在service中编写获取token的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String GET_TOKENURL_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET"; //用于存储token private static AccessToken at; /** * 获取token */ private static void getToken() &#123; String url = GET_TOKENURL_URL.replace("APPID", APPID).replace("APPSECRET", APPSECRET); String tokenStr = Utils.get(url);// System.out.println(tokenStr); JSONObject jsonObject = JSONObject.fromObject(tokenStr); String token = jsonObject.getString("access_token"); String expireIn = jsonObject.getString("expires_in"); //创建token对象，并存起来。 at = new AccessToken(token, expireIn); &#125; /** * 向外暴露的获取token的方法 * @return */ public static String getAccessToken() &#123; if(null==at||at.isExpired()) &#123; getToken(); &#125; return at.getAccessToken(); &#125;&#125; 以上便是简易的java来写微信后台的代码，由于大部分代码我是通过看别人视频获得的，所以也不详细写了，有兴趣的话可以去bilibli上搜索看看]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信公众号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用springboot快速建立helloworld项目]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%A6%82%E4%BD%95%E7%94%A8springboot%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8Bhelloworld%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[什么是springbootspringboot是一个spring微服务框架，具体是什么，大家可以去spring官网上进行了解如何快速的创建helloworld项目通过springboot快速构建网站创建maven项目进入springboot快速建立网站，Project选择Maven Project，SpringBoot版本选择2.1.7，我写这篇的时候，2.1.7为稳定版，请大家自行选择当前稳定版，如不知道可以去springboot指南中去看，看见红色GA结尾的就是稳定版，然后选择依赖，也就是Dependencies，这里我们只选择Web中的SpringWebStarter。 创建helloworld将刚刚创建出来的maven项目解压缩，并导入项目，修改主目录自动生成的Application.java中的代码如下 1234567891011121314@Controller@EnableAutoConfiguration@SpringBootApplicationpublic class TestApplication &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 然后右键项目-&gt;Run as-&gt;Spring Boot App 进入localhost:8080下就能看到helloworld了]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用maven快速建立个web工程]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A6%82%E4%BD%95%E7%94%A8maven%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E4%B8%AAweb%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事天天看视频，发现自己以前用maven建工程方式貌似有点瓜皮，所以写个文章在记录，也方便工作学习什么是maven工程maven是一个很方便构建项目的工具，有了它就可以不用到处找jar包了，而且现在越来越多的技术，貌似都是直接用maven导入的所以，我觉得还是需要搞的，而它中配置jar的地方主要是在pom.xml中写，而如果你想找要加什么东西进去，可以去maven市场中寻找。 如何配置maven环境maven是一个java搞的东西，所以你要配置java环境，不过我觉得这个东西大家估计都会就不说了，然后是配置maven的环境，感觉和配置java一样简单，所以也不说了 如何配置maven为阿里私服由于默认maven服务器下载起来很慢，所以一般国内我还是推荐修改为阿里的私服，这样会快点，修改文件为maven解压路径下conf目录下的setting文件，需要在mirrors节点加入 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如下图所示 如何在eclipse中配置maven环境点击window-&gt;preferences-&gt;maven这里需要修改的配置有两个地方，一个在Installations，一个在User Settings中， 如何用eclipse快速建立maven的web工程点击 File-&gt;New-&gt;Maven Project，然后弹出页面记得勾选Create a simple project 的选项，操作如下图然后点击finish，就创建好了项目，这时候你发现很坑爹怎么没有WEB-INF与META-INF目录，没事你只要右击项目选择properties-&gt;Project Facets，然后勾选掉Dynamic Web Module 点击Apply，再点击 Dynamic Web Module ，就出现了 Futher configuration available… 的字眼，点击它 然后点击OK，一个Maven项目的web目录就搭建好了]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
</search>
