<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[递归]]></title>
    <url>%2F2020%2F07%2F13%2F%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。递归需要遵守的重要规则执行一个方法时，就创建一个新的受保护的独立空间(栈空间)方法的局部变量是独立的，不会相互影响, 比如n变量如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。 递归-迷宫问题 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class MiGong &#123; public static void main(String[] args) &#123; // 先创建一个二维数组，模拟迷宫 // 地图 int[][] map = new int[8][7]; // 使用1 表示墙 // 上下全部置为1 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; // 左右全部置为1 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置挡板, 1 表示 map[3][1] = 1; map[3][2] = 1;// map[1][2] = 1;// map[2][2] = 1; // 输出地图 System.out.println("地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; //使用递归回溯给小球找路 //setWay(map, 1, 1); setWay2(map, 1, 1); //输出新的地图, 小球走过，并标识过的递归 System.out.println("小球走过，并标识过的 地图的情况"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + " "); &#125; System.out.println(); &#125; &#125; //使用递归回溯来给小球找路 //说明 //1. map 表示地图 //2. i,j 表示从地图的哪个位置开始出发 (1,1) //3. 如果小球能到 map[6][5] 位置，则说明通路找到. //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙 ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通 //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯 /** * * @param map 表示地图 * @param i 从哪个位置开始找 * @param j * @return 如果找到通路，就返回true, 否则返回false */ public static boolean setWay(int[][] map, int i, int j) &#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 下-&gt;右-&gt;上-&gt;左 走 map[i][j] = 2; // 假定该点是可以走通. if(setWay(map, i+1, j)) &#123;//向下走 return true; &#125; else if (setWay(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay(map, i-1, j)) &#123; //向上 return true; &#125; else if (setWay(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125; //修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左 public static boolean setWay2(int[][] map, int i, int j) &#123; if(map[6][5] == 2) &#123; // 通路已经找到ok return true; &#125; else &#123; if(map[i][j] == 0) &#123; //如果当前这个点还没有走过 //按照策略 上-&gt;右-&gt;下-&gt;左 map[i][j] = 2; // 假定该点是可以走通. if(setWay2(map, i-1, j)) &#123;//向上走 return true; &#125; else if (setWay2(map, i, j+1)) &#123; //向右走 return true; &#125; else if (setWay2(map, i+1, j)) &#123; //向下 return true; &#125; else if (setWay2(map, i, j-1))&#123; // 向左走 return true; &#125; else &#123; //说明该点是走不通，是死路 map[i][j] = 3; return false; &#125; &#125; else &#123; // 如果map[i][j] != 0 , 可能是 1， 2， 3 return false; &#125; &#125; &#125;&#125; 递归-八皇后问题(回溯算法)八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Queue8 &#123; //定义一个max表示共有多少个皇后 int max = 8; //定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; int[] array = new int[max]; static int count = 0; static int judgeCount = 0; public static void main(String[] args) &#123; //测试一把 ， 8皇后是否正确 Queue8 queue8 = new Queue8(); queue8.check(0); System.out.printf("一共有%d解法", count); System.out.printf("一共判断冲突的次数%d次", judgeCount); // 1.5w &#125; //编写一个方法，放置第n个皇后 //特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯 private void check(int n) &#123; if(n == max) &#123; //n = 8 , 其实8个皇后就既然放好 print(); return; &#125; //依次放入皇后，并判断是否冲突 for(int i = 0; i &lt; max; i++) &#123; //先把当前这个皇后 n , 放到该行的第1列 array[n] = i; //判断当放置第n个皇后到i列时，是否冲突 if(judge(n)) &#123; // 不冲突 //接着放n+1个皇后,即开始递归 check(n+1); // &#125; //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置 &#125; &#125; //查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突 /** * * @param n 表示第n个皇后 * @return */ private boolean judge(int n) &#123; judgeCount++; for(int i = 0; i &lt; n; i++) &#123; // 说明 //1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列 //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线 // n = 1 放置第 2列 1 n = 1 array[1] = 1 // Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1 //3. 判断是否在同一行, 没有必要，n 每次都在递增 if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123; return false; &#125; &#125; return true; &#125; //写一个方法，可以将皇后摆放的位置输出 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + " "); &#125; System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前缀、中缀、后缀表达式]]></title>
    <url>%2F2020%2F07%2F03%2F%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取前缀表达式介绍前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6前缀表达式的计算机求值从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下: 从右至左扫描，将6、5、4、3压入堆栈遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈最后是-运算符，计算出35-6的值，即29，由此得出最终结果 中缀表达式介绍中缀表达式就是常见的运算表达式，如(3+4)×5-6 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.) 后缀表达式介绍后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后 中举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 – 后缀表达式的计算机求值从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果 例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下: 从左至右扫描，将3和4压入堆栈；遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；将5入栈；接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；将6入栈；最后是-运算符，计算出35-6的值，即29，由此得出最终结果 逆波兰表达式计算器代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196public class ReversePolishMultiCalc &#123; /** * 匹配 + - * / ( ) 运算符 */ static final String SYMBOL = "\\+|-|\\*|/|\\(|\\)"; static final String LEFT = "("; static final String RIGHT = ")"; static final String ADD = "+"; static final String MINUS= "-"; static final String TIMES = "*"; static final String DIVISION = "/"; /** * 加減 + - */ static final int LEVEL_01 = 1; /** * 乘除 * / */ static final int LEVEL_02 = 2; /** * 括号 */ static final int LEVEL_HIGH = Integer.MAX_VALUE; static Stack&lt;String&gt; stack = new Stack&lt;&gt;(); static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;()); /** * 去除所有空白符 * @param s * @return */ public static String replaceAllBlank(String s )&#123; // \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v] return s.replaceAll("\\s+",""); &#125; /** * 判断是不是数字 int double long float * @param s * @return */ public static boolean isNumber(String s)&#123; Pattern pattern = Pattern.compile("^[-\\+]?[.\\d]*$"); return pattern.matcher(s).matches(); &#125; /** * 判断是不是运算符 * @param s * @return */ public static boolean isSymbol(String s)&#123; return s.matches(SYMBOL); &#125; /** * 匹配运算等级 * @param s * @return */ public static int calcLevel(String s)&#123; if("+".equals(s) || "-".equals(s))&#123; return LEVEL_01; &#125; else if("*".equals(s) || "/".equals(s))&#123; return LEVEL_02; &#125; return LEVEL_HIGH; &#125; /** * 匹配 * @param s * @throws Exception */ public static List&lt;String&gt; doMatch (String s) throws Exception&#123; if(s == null || "".equals(s.trim())) throw new RuntimeException("data is empty"); if(!isNumber(s.charAt(0)+"")) throw new RuntimeException("data illeagle,start not with a number"); s = replaceAllBlank(s); String each; int start = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if(isSymbol(s.charAt(i)+""))&#123; each = s.charAt(i)+""; //栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈 if(stack.isEmpty() || LEFT.equals(each) || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123; stack.push(each); &#125;else if( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123; //栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈 while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123; if(calcLevel(stack.peek()) == LEVEL_HIGH)&#123; break; &#125; data.add(stack.pop()); &#125; stack.push(each); &#125;else if(RIGHT.equals(each))&#123; // ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈 while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123; if(LEVEL_HIGH == calcLevel(stack.peek()))&#123; stack.pop(); break; &#125; data.add(stack.pop()); &#125; &#125; start = i ; //前一个运算符的位置 &#125;else if( i == s.length()-1 || isSymbol(s.charAt(i+1)+"") )&#123; each = start == 0 ? s.substring(start,i+1) : s.substring(start+1,i+1); if(isNumber(each)) &#123; data.add(each); continue; &#125; throw new RuntimeException("data not match number"); &#125; &#125; //如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列 Collections.reverse(stack); data.addAll(new ArrayList&lt;&gt;(stack)); System.out.println(data); return data; &#125; /** * 算出结果 * @param list * @return */ public static Double doCalc(List&lt;String&gt; list)&#123; Double d = 0d; if(list == null || list.isEmpty())&#123; return null; &#125; if (list.size() == 1)&#123; System.out.println(list); d = Double.valueOf(list.get(0)); return d; &#125; ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; list1.add(list.get(i)); if(isSymbol(list.get(i)))&#123; Double d1 = doTheMath(list.get(i - 2), list.get(i - 1), list.get(i)); list1.remove(i); list1.remove(i-1); list1.set(i-2,d1+""); list1.addAll(list.subList(i+1,list.size())); break; &#125; &#125; doCalc(list1); return d; &#125; /** * 运算 * @param s1 * @param s2 * @param symbol * @return */ public static Double doTheMath(String s1,String s2,String symbol)&#123; Double result ; switch (symbol)&#123; case ADD : result = Double.valueOf(s1) + Double.valueOf(s2); break; case MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); break; case TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); break; case DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); break; default : result = null; &#125; return result; &#125; public static void main(String[] args) &#123; //String math = "9+(3-1)*3+10/2"; String math = "12.8 + (2 - 3.55)*4+10/5.0"; try &#123; doCalc(doMatch(math)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 中缀表达式转换为后缀表达式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204public class PolandNotation &#123; public static void main(String[] args) &#123; //完成将一个中缀表达式转成后缀表达式的功能 //说明 //1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 – //2. 因为直接对str 进行操作，不方便，因此 先将 "1+((2+3)×4)-5" =》 中缀的表达式对应的List // 即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] //3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List // 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] String expression = "1+((2+3)*4)-5";//注意表达式 List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression); System.out.println("中缀表达式对应的List=" + infixExpressionList); // ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList); System.out.println("后缀表达式对应的List" + suffixExpreesionList); //ArrayList [1,2,3,+,4,*,+,5,–] System.out.printf("expression=%d", calculate(suffixExpreesionList)); // ? /* //先定义给逆波兰表达式 //(30+4)×5-6 =&gt; 30 4 + 5 × 6 - =&gt; 164 // 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + //测试 //说明为了方便，逆波兰表达式 的数字和符号使用空格隔开 //String suffixExpression = "30 4 + 5 * 6 -"; String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76 //思路 //1. 先将 "3 4 + 5 × 6 - " =&gt; 放到ArrayList中 //2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算 List&lt;String&gt; list = getListString(suffixExpression); System.out.println("rpnList=" + list); int res = calculate(list); System.out.println("计算的结果是=" + res); */ &#125; //即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–] //方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List public static List&lt;String&gt; parseSuffixExpreesionList(List&lt;String&gt; ls) &#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); // 符号栈 //说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出 //因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2 //Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); // 储存中间结果的Lists2 //遍历ls for(String item: ls) &#123; //如果是一个数，加入s2 if(item.matches("\\d+")) &#123; s2.add(item); &#125; else if (item.equals("(")) &#123; s1.push(item); &#125; else if (item.equals(")")) &#123; //如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 while(!s1.peek().equals("(")) &#123; s2.add(s1.pop()); &#125; s1.pop();//!!! 将 ( 弹出 s1栈， 消除小括号 &#125; else &#123; //当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较 //问题：我们缺少一个比较优先级高低的方法 while(s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123; s2.add(s1.pop()); &#125; //还需要将item压入栈 s1.push(item); &#125; &#125; //将s1中剩余的运算符依次弹出并加入s2 while(s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2; //注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List &#125; //方法：将 中缀表达式转成对应的List // s="1+((2+3)×4)-5"; public static List&lt;String&gt; toInfixExpressionList(String s) &#123; //定义一个List,存放中缀表达式 对应的内容 List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0; //这时是一个指针，用于遍历 中缀表达式字符串 String str; // 对多位数的拼接 char c; // 每遍历到一个字符，就放入到c do &#123; //如果c是一个非数字，我需要加入到ls if((c=s.charAt(i)) &lt; 48 || (c=s.charAt(i)) &gt; 57) &#123; ls.add("" + c); i++; //i需要后移 &#125; else &#123; //如果是一个数，需要考虑多位数 str = ""; //先将str 置成"" '0'[48]-&gt;'9'[57] while(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= 48 &amp;&amp; (c=s.charAt(i)) &lt;= 57) &#123; str += c;//拼接 i++; &#125; ls.add(str); &#125; &#125;while(i &lt; s.length()); return ls;//返回 &#125; //将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中 public static List&lt;String&gt; getListString(String suffixExpression) &#123; //将 suffixExpression 分割 String[] split = suffixExpression.split(" "); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(String ele: split) &#123; list.add(ele); &#125; return list; &#125; //完成对逆波兰表达式的运算 /* * 1)从左至右扫描，将3和4压入堆栈； 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 3)将5入栈； 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5)将6入栈； 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果 */ public static int calculate(List&lt;String&gt; ls) &#123; // 创建给栈, 只需要一个栈即可 Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); // 遍历 ls for (String item : ls) &#123; // 这里使用正则表达式来取出数 if (item.matches("\\d+")) &#123; // 匹配的是多位数 // 入栈 stack.push(item); &#125; else &#123; // pop出两个数，并运算， 再入栈 int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals("+")) &#123; res = num1 + num2; &#125; else if (item.equals("-")) &#123; res = num1 - num2; &#125; else if (item.equals("*")) &#123; res = num1 * num2; &#125; else if (item.equals("/")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException("运算符有误"); &#125; //把res 入栈 stack.push("" + res); &#125; &#125; //最后留在stack中的数据是运算结果 return Integer.parseInt(stack.pop()); &#125;&#125;//编写一个类 Operation 可以返回一个运算符 对应的优先级class Operation &#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; //写一个方法，返回对应的优先级数字 public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case "+": result = ADD; break; case "-": result = SUB; break; case "*": result = MUL; break; case "/": result = DIV; break; default: System.out.println("不存在该运算符" + operation); break; &#125; return result; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%A0%88%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍栈的英文为(stack)栈是一个先入后出(FILO-First In Last Out)的有序列表。栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class ArrayStackDemo &#123; public static void main(String[] args) &#123; //测试一下ArrayStack 是否正确 //先创建一个ArrayStack对象-&gt;表示栈 ArrayStack stack = new ArrayStack(4); String key = ""; boolean loop = true; //控制是否退出菜单 Scanner scanner = new Scanner(System.in); while(loop) &#123; System.out.println("show: 表示显示栈"); System.out.println("exit: 退出程序"); System.out.println("push: 表示添加数据到栈(入栈)"); System.out.println("pop: 表示从栈取出数据(出栈)"); System.out.println("请输入你的选择"); key = scanner.next(); switch (key) &#123; case "show": stack.list(); break; case "push": System.out.println("请输入一个数"); int value = scanner.nextInt(); stack.push(value); break; case "pop": try &#123; int res = stack.pop(); System.out.printf("出栈的数据是 %d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case "exit": scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~~"); &#125;&#125;//定义一个 ArrayStack 表示栈class ArrayStack &#123; private int maxSize; // 栈的大小 private int[] stack; // 数组，数组模拟栈，数据就放在该数组 private int top = -1;// top表示栈顶，初始化为-1 //构造器 public ArrayStack(int maxSize) &#123; this.maxSize = maxSize; stack = new int[this.maxSize]; &#125; //栈满 public boolean isFull() &#123; return top == maxSize - 1; &#125; //栈空 public boolean isEmpty() &#123; return top == -1; &#125; //入栈-push public void push(int value) &#123; //先判断栈是否满 if(isFull()) &#123; System.out.println("栈满"); return; &#125; top++; stack[top] = value; &#125; //出栈-pop, 将栈顶的数据返回 public int pop() &#123; //先判断栈是否空 if(isEmpty()) &#123; //抛出异常 throw new RuntimeException("栈空，没有数据~"); &#125; int value = stack[top]; top--; return value; &#125; //显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据 public void list() &#123; if(isEmpty()) &#123; System.out.println("栈空，没有数据~~"); return; &#125; //需要从栈顶开始显示数据 for(int i = top; i &gt;= 0 ; i--) &#123; System.out.printf("stack[%d]=%d\n", i, stack[i]); &#125; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表]]></title>
    <url>%2F2020%2F07%2F03%2F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍链表是以节点的方式来存储,是链式存储每个节点包含 data 域， next 域：指向下一个节点.如图：发现链表的各个节点不一定是连续存储.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定 单链表介绍 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323public class SingleLinkedListDemo &#123; public static void main(String[] args) &#123; //进行测试 //先创建节点 HeroNode hero1 = new HeroNode(1, "宋江", "及时雨"); HeroNode hero2 = new HeroNode(2, "卢俊义", "玉麒麟"); HeroNode hero3 = new HeroNode(3, "吴用", "智多星"); HeroNode hero4 = new HeroNode(4, "林冲", "豹子头"); //创建要给链表 SingleLinkedList singleLinkedList = new SingleLinkedList(); //加入 singleLinkedList.add(hero1); singleLinkedList.add(hero4); singleLinkedList.add(hero2); singleLinkedList.add(hero3); // 测试一下单链表的反转功能 System.out.println("原来链表的情况~~"); singleLinkedList.list(); // System.out.println("反转单链表~~");// reversetList(singleLinkedList.getHead());// singleLinkedList.list(); System.out.println("测试逆序打印单链表, 没有改变链表的结构~~"); reversePrint(singleLinkedList.getHead()); /* //加入按照编号的顺序 singleLinkedList.addByOrder(hero1); singleLinkedList.addByOrder(hero4); singleLinkedList.addByOrder(hero2); singleLinkedList.addByOrder(hero3); //显示一把 singleLinkedList.list(); //测试修改节点的代码 HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~"); singleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况~~"); singleLinkedList.list(); //删除一个节点 singleLinkedList.del(1); singleLinkedList.del(4); System.out.println("删除后的链表情况~~"); singleLinkedList.list(); //测试一下 求单链表中有效节点的个数 System.out.println("有效的节点个数=" + getLength(singleLinkedList.getHead()));//2 //测试一下看看是否得到了倒数第K个节点 HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3); System.out.println("res=" + res);*/ &#125; //方式2： //可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果 public static void reversePrint(HeroNode head) &#123; if(head.next == null) &#123; return;//空链表，不能打印 &#125; //创建要给一个栈，将各个节点压入栈 Stack&lt;HeroNode&gt; stack = new Stack&lt;HeroNode&gt;(); HeroNode cur = head.next; //将链表的所有节点压入栈 while(cur != null) &#123; stack.push(cur); cur = cur.next; //cur后移，这样就可以压入下一个节点 &#125; //将栈中的节点进行打印,pop 出栈 while (stack.size() &gt; 0) &#123; System.out.println(stack.pop()); //stack的特点是先进后出 &#125; &#125; //将单链表反转 public static void reversetList(HeroNode head) &#123; //如果当前链表为空，或者只有一个节点，无需反转，直接返回 if(head.next == null || head.next.next == null) &#123; return ; &#125; //定义一个辅助的指针(变量)，帮助我们遍历原来的链表 HeroNode cur = head.next; HeroNode next = null;// 指向当前节点[cur]的下一个节点 HeroNode reverseHead = new HeroNode(0, "", ""); //遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端 //动脑筋 while(cur != null) &#123; next = cur.next;//先暂时保存当前节点的下一个节点，因为后面需要使用 cur.next = reverseHead.next;//将cur的下一个节点指向新的链表的最前端 reverseHead.next = cur; //将cur 连接到新的链表上 cur = next;//让cur后移 &#125; //将head.next 指向 reverseHead.next , 实现单链表的反转 head.next = reverseHead.next; &#125; //查找单链表中的倒数第k个结点 【新浪面试题】 //思路 //1. 编写一个方法，接收head节点，同时接收一个index //2. index 表示是倒数第index个节点 //3. 先把链表从头到尾遍历，得到链表的总的长度 getLength //4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到 //5. 如果找到了，则返回该节点，否则返回nulll public static HeroNode findLastIndexNode(HeroNode head, int index) &#123; //判断如果链表为空，返回null if(head.next == null) &#123; return null;//没有找到 &#125; //第一个遍历得到链表的长度(节点个数) int size = getLength(head); //第二次遍历 size-index 位置，就是我们倒数的第K个节点 //先做一个index的校验 if(index &lt;=0 || index &gt; size) &#123; return null; &#125; //定义给辅助变量， for 循环定位到倒数的index HeroNode cur = head.next; //3 // 3 - 1 = 2 for(int i =0; i&lt; size - index; i++) &#123; cur = cur.next; &#125; return cur; &#125; //方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点) /** * * @param head 链表的头节点 * @return 返回的就是有效节点的个数 */ public static int getLength(HeroNode head) &#123; if(head.next == null) &#123; //空链表 return 0; &#125; int length = 0; //定义一个辅助的变量, 这里我们没有统计头节点 HeroNode cur = head.next; while(cur != null) &#123; length++; cur = cur.next; //遍历 &#125; return length; &#125;&#125;//定义SingleLinkedList 管理我们的英雄class SingleLinkedList &#123; //先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode head = new HeroNode(0, "", ""); //返回头节点 public HeroNode getHead() &#123; return head; &#125; //添加节点到单向链表 //思路，当不考虑编号顺序时 //1. 找到当前链表的最后节点 //2. 将最后这个节点的next 指向 新的节点 public void add(HeroNode heroNode) &#123; //因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode temp = head; //遍历链表，找到最后 while(true) &#123; //找到链表的最后 if(temp.next == null) &#123;// break; &#125; //如果没有找到最后, 将将temp后移 temp = temp.next; &#125; //当退出while循环时，temp就指向了链表的最后 //将最后这个节点的next 指向 新的节点 temp.next = heroNode; &#125; //第二种方式在添加英雄时，根据排名将英雄插入到指定位置 //(如果有这个排名，则添加失败，并给出提示) public void addByOrder(HeroNode heroNode) &#123; //因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置 //因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了 HeroNode temp = head; boolean flag = false; // flag标志添加的编号是否存在，默认为false while(true) &#123; if(temp.next == null) &#123;//说明temp已经在链表的最后 break; // &#125; if(temp.next.no &gt; heroNode.no) &#123; //位置找到，就在temp的后面插入 break; &#125; else if (temp.next.no == heroNode.no) &#123;//说明希望添加的heroNode的编号已然存在 flag = true; //说明编号存在 break; &#125; temp = temp.next; //后移，遍历当前链表 &#125; //判断flag 的值 if(flag) &#123; //不能添加，说明编号存在 System.out.printf("准备插入的英雄的编号 %d 已经存在了, 不能加入\n", heroNode.no); &#125; else &#123; //插入到链表中, temp的后面 heroNode.next = temp.next; temp.next = heroNode; &#125; &#125; //修改节点的信息, 根据no编号来修改，即no编号不能改. //说明 //1. 根据 newHeroNode 的 no 来修改即可 public void update(HeroNode newHeroNode) &#123; //判断是否空 if(head.next == null) &#123; System.out.println("链表为空~"); return; &#125; //找到需要修改的节点, 根据no编号 //定义一个辅助变量 HeroNode temp = head.next; boolean flag = false; //表示是否找到该节点 while(true) &#123; if (temp == null) &#123; break; //已经遍历完链表 &#125; if(temp.no == newHeroNode.no) &#123; //找到 flag = true; break; &#125; temp = temp.next; &#125; //根据flag 判断是否找到要修改的节点 if(flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; //没有找到 System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; //删除节点 //思路 //1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点 //2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较 public void del(int no) &#123; HeroNode temp = head; boolean flag = false; // 标志是否找到待删除节点的 while(true) &#123; if(temp.next == null) &#123; //已经到链表的最后 break; &#125; if(temp.next.no == no) &#123; //找到的待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; //temp后移，遍历 &#125; //判断flag if(flag) &#123; //找到 //可以删除 temp.next = temp.next.next; &#125;else &#123; System.out.printf("要删除的 %d 节点不存在\n", no); &#125; &#125; //显示链表[遍历] public void list() &#123; //判断链表是否为空 if(head.next == null) &#123; System.out.println("链表为空"); return; &#125; //因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode temp = head.next; while(true) &#123; //判断是否到链表最后 if(temp == null) &#123; break; &#125; //输出节点的信息 System.out.println(temp); //将temp后移， 一定小心 temp = temp.next; &#125; &#125;&#125;//定义HeroNode ， 每个HeroNode 对象就是一个节点class HeroNode &#123; public int no; public String name; public String nickname; public HeroNode next; //指向下一个节点 //构造器 public HeroNode(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; //为了显示方法，我们重新toString @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + "]"; &#125; &#125; 双向链表介绍 双向链表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186public class DoubleLinkedListDemo &#123; public static void main(String[] args) &#123; // 测试 System.out.println("双向链表的测试"); // 先创建节点 HeroNode2 hero1 = new HeroNode2(1, "宋江", "及时雨"); HeroNode2 hero2 = new HeroNode2(2, "卢俊义", "玉麒麟"); HeroNode2 hero3 = new HeroNode2(3, "吴用", "智多星"); HeroNode2 hero4 = new HeroNode2(4, "林冲", "豹子头"); // 创建一个双向链表 DoubleLinkedList doubleLinkedList = new DoubleLinkedList(); doubleLinkedList.add(hero1); doubleLinkedList.add(hero2); doubleLinkedList.add(hero3); doubleLinkedList.add(hero4); doubleLinkedList.list(); // 修改 HeroNode2 newHeroNode = new HeroNode2(4, "公孙胜", "入云龙"); doubleLinkedList.update(newHeroNode); System.out.println("修改后的链表情况"); doubleLinkedList.list(); // 删除 doubleLinkedList.del(3); System.out.println("删除后的链表情况~~"); doubleLinkedList.list(); &#125;&#125;// 创建一个双向链表的类class DoubleLinkedList &#123; // 先初始化一个头节点, 头节点不要动, 不存放具体的数据 private HeroNode2 head = new HeroNode2(0, "", ""); // 返回头节点 public HeroNode2 getHead() &#123; return head; &#125; // 遍历双向链表的方法 // 显示链表[遍历] public void list() &#123; // 判断链表是否为空 if (head.next == null) &#123; System.out.println("链表为空"); return; &#125; // 因为头节点，不能动，因此我们需要一个辅助变量来遍历 HeroNode2 temp = head.next; while (true) &#123; // 判断是否到链表最后 if (temp == null) &#123; break; &#125; // 输出节点的信息 System.out.println(temp); // 将temp后移， 一定小心 temp = temp.next; &#125; &#125; // 添加一个节点到双向链表的最后. public void add(HeroNode2 heroNode) &#123; // 因为head节点不能动，因此我们需要一个辅助遍历 temp HeroNode2 temp = head; // 遍历链表，找到最后 while (true) &#123; // 找到链表的最后 if (temp.next == null) &#123;// break; &#125; // 如果没有找到最后, 将将temp后移 temp = temp.next; &#125; // 当退出while循环时，temp就指向了链表的最后 // 形成一个双向链表 temp.next = heroNode; heroNode.pre = temp; &#125; // 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样 // 只是 节点类型改成 HeroNode2 public void update(HeroNode2 newHeroNode) &#123; // 判断是否空 if (head.next == null) &#123; System.out.println("链表为空~"); return; &#125; // 找到需要修改的节点, 根据no编号 // 定义一个辅助变量 HeroNode2 temp = head.next; boolean flag = false; // 表示是否找到该节点 while (true) &#123; if (temp == null) &#123; break; // 已经遍历完链表 &#125; if (temp.no == newHeroNode.no) &#123; // 找到 flag = true; break; &#125; temp = temp.next; &#125; // 根据flag 判断是否找到要修改的节点 if (flag) &#123; temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname; &#125; else &#123; // 没有找到 System.out.printf("没有找到 编号 %d 的节点，不能修改\n", newHeroNode.no); &#125; &#125; // 从双向链表中删除一个节点, // 说明 // 1 对于双向链表，我们可以直接找到要删除的这个节点 // 2 找到后，自我删除即可 public void del(int no) &#123; // 判断当前链表是否为空 if (head.next == null) &#123;// 空链表 System.out.println("链表为空，无法删除"); return; &#125; HeroNode2 temp = head.next; // 辅助变量(指针) boolean flag = false; // 标志是否找到待删除节点的 while (true) &#123; if (temp == null) &#123; // 已经到链表的最后 break; &#125; if (temp.no == no) &#123; // 找到的待删除节点的前一个节点temp flag = true; break; &#125; temp = temp.next; // temp后移，遍历 &#125; // 判断flag if (flag) &#123; // 找到 // 可以删除 // temp.next = temp.next.next;[单向链表] temp.pre.next = temp.next; // 这里我们的代码有问题? // 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针 if (temp.next != null) &#123; temp.next.pre = temp.pre; &#125; &#125; else &#123; System.out.printf("要删除的 %d 节点不存在\n", no); &#125; &#125;&#125;// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点class HeroNode2 &#123; public int no; public String name; public String nickname; public HeroNode2 next; // 指向下一个节点, 默认为null public HeroNode2 pre; // 指向前一个节点, 默认为null // 构造器 public HeroNode2(int no, String name, String nickname) &#123; this.no = no; this.name = name; this.nickname = nickname; &#125; // 为了显示方法，我们重新toString @Override public String toString() &#123; return "HeroNode [no=" + no + ", name=" + name + ", nickname=" + nickname + "]"; &#125;&#125; 单向环形链表介绍 单向环形链表代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142public class Josepfu &#123; public static void main(String[] args) &#123; // 测试一把看看构建环形链表，和遍历是否ok CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList(); circleSingleLinkedList.addBoy(125);// 加入5个小孩节点 circleSingleLinkedList.showBoy(); //测试一把小孩出圈是否正确 circleSingleLinkedList.countBoy(10, 20, 125); // 2-&gt;4-&gt;1-&gt;5-&gt;3 //String str = "7*2*2-5+1-5+3-3"; &#125;&#125;// 创建一个环形的单向链表class CircleSingleLinkedList &#123; // 创建一个first节点,当前没有编号 private Boy first = null; // 添加小孩节点，构建成一个环形的链表 public void addBoy(int nums) &#123; // nums 做一个数据校验 if (nums &lt; 1) &#123; System.out.println("nums的值不正确"); return; &#125; Boy curBoy = null; // 辅助指针，帮助构建环形链表 // 使用for来创建我们的环形链表 for (int i = 1; i &lt;= nums; i++) &#123; // 根据编号，创建小孩节点 Boy boy = new Boy(i); // 如果是第一个小孩 if (i == 1) &#123; first = boy; first.setNext(first); // 构成环 curBoy = first; // 让curBoy指向第一个小孩 &#125; else &#123; curBoy.setNext(boy);// boy.setNext(first);// curBoy = boy; &#125; &#125; &#125; // 遍历当前的环形链表 public void showBoy() &#123; // 判断链表是否为空 if (first == null) &#123; System.out.println("没有任何小孩~~"); return; &#125; // 因为first不能动，因此我们仍然使用一个辅助指针完成遍历 Boy curBoy = first; while (true) &#123; System.out.printf("小孩的编号 %d \n", curBoy.getNo()); if (curBoy.getNext() == first) &#123;// 说明已经遍历完毕 break; &#125; curBoy = curBoy.getNext(); // curBoy后移 &#125; &#125; // 根据用户的输入，计算出小孩出圈的顺序 /** * * @param startNo * 表示从第几个小孩开始数数 * @param countNum * 表示数几下 * @param nums * 表示最初有多少小孩在圈中 */ public void countBoy(int startNo, int countNum, int nums) &#123; // 先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println("参数输入有误， 请重新输入"); return; &#125; // 创建要给辅助指针,帮助完成小孩出圈 Boy helper = first; // 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点 while (true) &#123; if (helper.getNext() == first) &#123; // 说明helper指向最后小孩节点 break; &#125; helper = helper.getNext(); &#125; //小孩报数前，先让 first 和 helper 移动 k - 1次 for(int j = 0; j &lt; startNo - 1; j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈 //这里是一个循环操作，知道圈中只有一个节点 while(true) &#123; if(helper == first) &#123; //说明圈中只有一个节点 break; &#125; //让 first 和 helper 指针同时 的移动 countNum - 1 for(int j = 0; j &lt; countNum - 1; j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //这时first指向的节点，就是要出圈的小孩节点 System.out.printf("小孩%d出圈\n", first.getNo()); //这时将first指向的小孩节点出圈 first = first.getNext(); helper.setNext(first); // &#125; System.out.printf("最后留在圈中的小孩编号%d \n", first.getNo()); &#125;&#125;// 创建一个Boy类，表示一个节点class Boy &#123; private int no;// 编号 private Boy next; // 指向下一个节点,默认null public Boy(int no) &#123; this.no = no; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public Boy getNext() &#123; return next; &#125; public void setNext(Boy next) &#123; this.next = next; &#125;&#125; ##]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2020%2F07%2F03%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍队列是一个有序列表，可以用数组或是链表来实现。遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出数组模拟队列队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。 因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class ArrayQueueDemo &#123; public static void main(String[] args) &#123; //测试一把 //创建一个队列 ArrayQueue queue = new ArrayQueue(3); char key = ' '; //接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; //输出一个菜单 while(loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); key = scanner.next().charAt(0);//接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': //取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': //查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': //退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;// 使用数组模拟队列-编写一个ArrayQueue类class ArrayQueue &#123; private int maxSize; // 表示数组的最大容量 private int front; // 队列头 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 // 创建队列的构造器 public ArrayQueue(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; front = -1; // 指向队列头部，分析出front是指向队列头的前一个位置. rear = -1; // 指向队列尾，指向队列尾的数据(即就是队列最后一个数据) &#125; // 判断队列是否满 public boolean isFull() &#123; return rear == maxSize - 1; &#125; // 判断队列是否为空 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; rear++; // 让rear 后移 arr[rear] = n; &#125; // 获取队列的数据, 出队列 public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; front++; // front后移 return arr[front]; &#125; // 显示队列的所有数据 public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.printf("arr[%d]=%d\n", i, arr[i]); &#125; &#125; // 显示队列的头数据， 注意不是取出数据 public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front + 1]; &#125;&#125; 数组模拟环形队列尾索引的下一个为头索引时表示队列满，即将队 列容量空出一个作为约定,这个在做判断队列满的 时候需要注意 (rear + 1) % maxSize == front 满]rear == front [空] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public class CircleArrayQueueDemo &#123; public static void main(String[] args) &#123; //测试一把 System.out.println("测试数组模拟环形队列的案例~~~"); // 创建一个环形队列 CircleArray queue = new CircleArray(4); //说明设置4, 其队列的有效数据最大是3 char key = ' '; // 接收用户输入 Scanner scanner = new Scanner(System.in);// boolean loop = true; // 输出一个菜单 while (loop) &#123; System.out.println("s(show): 显示队列"); System.out.println("e(exit): 退出程序"); System.out.println("a(add): 添加数据到队列"); System.out.println("g(get): 从队列取出数据"); System.out.println("h(head): 查看队列头的数据"); key = scanner.next().charAt(0);// 接收一个字符 switch (key) &#123; case 's': queue.showQueue(); break; case 'a': System.out.println("输出一个数"); int value = scanner.nextInt(); queue.addQueue(value); break; case 'g': // 取出数据 try &#123; int res = queue.getQueue(); System.out.printf("取出的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'h': // 查看队列头的数据 try &#123; int res = queue.headQueue(); System.out.printf("队列头的数据是%d\n", res); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println(e.getMessage()); &#125; break; case 'e': // 退出 scanner.close(); loop = false; break; default: break; &#125; &#125; System.out.println("程序退出~~"); &#125;&#125;class CircleArray &#123; private int maxSize; // 表示数组的最大容量 //front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 //front 的初始值 = 0 private int front; //rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定. //rear 的初始值 = 0 private int rear; // 队列尾 private int[] arr; // 该数据用于存放数据, 模拟队列 public CircleArray(int arrMaxSize) &#123; maxSize = arrMaxSize; arr = new int[maxSize]; &#125; // 判断队列是否满 public boolean isFull() &#123; return (rear + 1) % maxSize == front; &#125; // 判断队列是否为空 public boolean isEmpty() &#123; return rear == front; &#125; // 添加数据到队列 public void addQueue(int n) &#123; // 判断队列是否满 if (isFull()) &#123; System.out.println("队列满，不能加入数据~"); return; &#125; //直接将数据加入 arr[rear] = n; //将 rear 后移, 这里必须考虑取模 rear = (rear + 1) % maxSize; &#125; // 获取队列的数据, 出队列 public int getQueue() &#123; // 判断队列是否空 if (isEmpty()) &#123; // 通过抛出异常 throw new RuntimeException("队列空，不能取数据"); &#125; // 这里需要分析出 front是指向队列的第一个元素 // 1. 先把 front 对应的值保留到一个临时变量 // 2. 将 front 后移, 考虑取模 // 3. 将临时保存的变量返回 int value = arr[front]; front = (front + 1) % maxSize; return value; &#125; // 显示队列的所有数据 public void showQueue() &#123; // 遍历 if (isEmpty()) &#123; System.out.println("队列空的，没有数据~~"); return; &#125; // 思路：从front开始遍历，遍历多少个元素 // 动脑筋 for (int i = front; i &lt; front + size() ; i++) &#123; System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]); &#125; &#125; // 求出当前队列有效数据的个数 public int size() &#123; // rear = 2 // front = 1 // maxSize = 3 return (rear + maxSize - front) % maxSize; &#125; // 显示队列的头数据， 注意不是取出数据 public int headQueue() &#123; // 判断 if (isEmpty()) &#123; throw new RuntimeException("队列空的，没有数据~~"); &#125; return arr[front]; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稀疏数组]]></title>
    <url>%2F2020%2F07%2F03%2F%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。稀疏数组的处理方法是:记录数组一共有几行几列，有多少个不同的值把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class SparseArray &#123; public static void main(String[] args) &#123; // 创建一个原始的二维数组 11 * 11 // 0: 表示没有棋子， 1 表示 黑子 2 表蓝子 int chessArr1[][] = new int[11][11]; chessArr1[1][2] = 1; chessArr1[2][3] = 2; chessArr1[4][5] = 2; // 输出原始的二维数组 System.out.println("原始的二维数组~~"); for (int[] row : chessArr1) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; // 将二维数组 转 稀疏数组的思 // 1. 先遍历二维数组 得到非0数据的个数 int sum = 0; for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; sum++; &#125; &#125; &#125; // 2. 创建对应的稀疏数组 int sparseArr[][] = new int[sum + 1][3]; // 给稀疏数组赋值 sparseArr[0][0] = 11; sparseArr[0][1] = 11; sparseArr[0][2] = sum; // 遍历二维数组，将非0的值存放到 sparseArr中 int count = 0; //count 用于记录是第几个非0数据 for (int i = 0; i &lt; 11; i++) &#123; for (int j = 0; j &lt; 11; j++) &#123; if (chessArr1[i][j] != 0) &#123; count++; sparseArr[count][0] = i; sparseArr[count][1] = j; sparseArr[count][2] = chessArr1[i][j]; &#125; &#125; &#125; // 输出稀疏数组的形式 System.out.println(); System.out.println("得到稀疏数组为~~~~"); for (int i = 0; i &lt; sparseArr.length; i++) &#123; System.out.printf("%d\t%d\t%d\t\n", sparseArr[i][0], sparseArr[i][1], sparseArr[i][2]); &#125; System.out.println(); //将稀疏数组 --》 恢复成 原始的二维数组 /* * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可. */ //1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组 int chessArr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]]; //2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可 for(int i = 1; i &lt; sparseArr.length; i++) &#123; chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2]; &#125; // 输出恢复后的二维数组 System.out.println(); System.out.println("恢复后的二维数组"); for (int[] row : chessArr2) &#123; for (int data : row) &#123; System.out.printf("%d\t", data); &#125; System.out.println(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波拉契查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class FibonacciSearch &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int [] arr = &#123;1,8, 10, 89, 1000, 1234&#125;; System.out.println("index=" + fibSearch(arr, 189));// 0 &#125; //因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列 //非递归方法得到一个斐波那契数列 public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; //编写斐波那契查找算法 //使用非递归的方式编写算法 /** * * @param a 数组 * @param key 我们需要查找的关键码(值) * @return 返回对应的下标，如果没有-1 */ public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; int k = 0; //表示斐波那契分割数值的下标 int mid = 0; //存放mid值 int f[] = fib(); //获取到斐波那契数列 //获取到斐波那契分割数值的下标 while(high &gt; f[k] - 1) &#123; k++; &#125; //因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[] //不足的部分会使用0填充 int[] temp = Arrays.copyOf(a, f[k]); //实际上需求使用a数组最后的数填充 temp //举例: //temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125; for(int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; // 使用while来循环处理，找到我们的数 key while (low &lt;= high) &#123; // 只要这个条件满足，就可以找 mid = low + f[k - 1] - 1; if(key &lt; temp[mid]) &#123; //我们应该继续向数组的前面查找(左边) high = mid - 1; //为甚是 k-- //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3] //即 在 f[k-1] 的前面继续查找 k-- //即下次循环 mid = f[k-1-1]-1 k--; &#125; else if ( key &gt; temp[mid]) &#123; // 我们应该继续向数组的后面查找(右边) low = mid + 1; //为什么是k -=2 //说明 //1. 全部元素 = 前面的元素 + 后边元素 //2. f[k] = f[k-1] + f[k-2] //3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4] //4. 即在f[k-2] 的前面进行查找 k -=2 //5. 即下次循环 mid = f[k - 1 - 2] - 1 k -= 2; &#125; else &#123; //找到 //需要确定，返回的是哪个下标 if(mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取 基本介绍 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class InsertValueSearch &#123; public static void main(String[] args) &#123; // int [] arr = new int[100];// for(int i = 0; i &lt; 100; i++) &#123;// arr[i] = i + 1;// &#125; int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;; int index = insertValueSearch(arr, 0, arr.length - 1, 1234); //int index = binarySearch(arr, 0, arr.length, 1); System.out.println("index = " + index); //System.out.println(Arrays.toString(arr)); &#125; public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; System.out.println("二分查找被调用~"); // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; //编写插值查找算法 //说明：插值查找算法，也要求数组是有序的 /** * * @param arr 数组 * @param left 左边索引 * @param right 右边索引 * @param findVal 查找值 * @return 如果找到，就返回对应的下标，如果没有找到，返回-1 */ public static int insertValueSearch(int[] arr, int left, int right, int findVal) &#123; System.out.println("插值查找次数~~"); //注意：findVal &lt; arr[0] 和 findVal &gt; arr[arr.length - 1] 必须需要 //否则我们得到的 mid 可能越界 if (left &gt; right || findVal &lt; arr[0] || findVal &gt; arr[arr.length - 1]) &#123; return -1; &#125; // 求出mid, 自适应 int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]); int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 说明应该向右边递归 return insertValueSearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 说明向左递归查找 return insertValueSearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2020%2F07%2F03%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 递归代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class BinarySearch &#123; public static void main(String[] args) &#123; //int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;; int arr[] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 , 11, 12, 13,14,15,16,17,18,19,20 &#125;; //// int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);// System.out.println("resIndex=" + resIndex); List&lt;Integer&gt; resIndexList = binarySearch2(arr, 0, arr.length - 1, 1); System.out.println("resIndexList=" + resIndexList); &#125; // 二分查找算法 /** * * @param arr * 数组 * @param left * 左边的索引 * @param right * 右边的索引 * @param findVal * 要查找的值 * @return 如果找到就返回下标，如果没有找到，就返回 -1 */ public static int binarySearch(int[] arr, int left, int right, int findVal) &#123; // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch(arr, left, mid - 1, findVal); &#125; else &#123; return mid; &#125; &#125; //完成一个课后思考题: /* * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000 * * 思路分析 * 1. 在找到mid 索引值，不要马上返回 * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList * 4. 将Arraylist返回 */ public static List&lt;Integer&gt; binarySearch2(int[] arr, int left, int right, int findVal) &#123; System.out.println("hello~"); // 当 left &gt; right 时，说明递归整个数组，但是没有找到 if (left &gt; right) &#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid = (left + right) / 2; int midVal = arr[mid]; if (findVal &gt; midVal) &#123; // 向 右递归 return binarySearch2(arr, mid + 1, right, findVal); &#125; else if (findVal &lt; midVal) &#123; // 向左递归 return binarySearch2(arr, left, mid - 1, findVal); &#125; else &#123;// * 思路分析// * 1. 在找到mid 索引值，不要马上返回// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList// * 4. 将Arraylist返回 List&lt;Integer&gt; resIndexlist = new ArrayList&lt;Integer&gt;(); //向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList int temp = mid - 1; while(true) &#123; if (temp &lt; 0 || arr[temp] != findVal) &#123;//退出 break; &#125; //否则，就temp 放入到 resIndexlist resIndexlist.add(temp); temp -= 1; //temp左移 &#125; resIndexlist.add(mid); // //向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList temp = mid + 1; while(true) &#123; if (temp &gt; arr.length - 1 || arr[temp] != findVal) &#123;//退出 break; &#125; //否则，就temp 放入到 resIndexlist resIndexlist.add(temp); temp += 1; //temp右移 &#125; return resIndexlist; &#125; &#125;&#125; 非递归代码12345678910111213141516171819202122232425262728293031323334public class BinarySearchNoRecur &#123; public static void main(String[] args) &#123; //测试 int[] arr = &#123;1,3, 8, 10, 11, 67, 100&#125;; int index = binarySearch(arr, 100); System.out.println("index=" + index);// &#125; //二分查找的非递归实现 /** * * @param arr 待查找的数组, arr是升序排序 * @param target 需要查找的数 * @return 返回对应下标，-1表示没有找到 */ public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while(left &lt;= right) &#123; //说明继续查找 int mid = (left + right) / 2; if(arr[mid] == target) &#123; return mid; &#125; else if ( arr[mid] &gt; target) &#123; right = mid - 1;//需要向左边查找 &#125; else &#123; left = mid + 1; //需要向右边查找 &#125; &#125; return -1; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 时间复杂度与空间复杂度和稳定性它的最坏，最好，平均时间复杂度均为O(nlogn)，。空间复杂度是 O(1)，稳定性为不稳定 排序思想堆排序的基本思想是：将待排序序列构造成一个大顶堆此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了. 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class HeapSort &#123; public static void main(String[] args) &#123; //要求将数组进行升序排序 //int arr[] = &#123;4, 6, 8, 5, 9&#125;; // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); heapSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("排序后=" + Arrays.toString(arr)); &#125; //编写一个堆排序的方法 public static void heapSort(int arr[]) &#123; int temp = 0; System.out.println("堆排序!!"); // //分步完成// adjustHeap(arr, 1, arr.length);// System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6// // adjustHeap(arr, 0, arr.length);// System.out.println("第2次" + Arrays.toString(arr)); // 9,6,8,5,4 //完成我们最终代码 //将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆 for(int i = arr.length / 2 -1; i &gt;=0; i--) &#123; adjustHeap(arr, i, arr.length); &#125; /* * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端; 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 */ for(int j = arr.length-1;j &gt;0; j--) &#123; //交换 temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr, 0, j); &#125; //System.out.println("数组=" + Arrays.toString(arr)); &#125; //将一个数组(二叉树), 调整成一个大顶堆 /** * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 * 举例 int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt; adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; * 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125; * @param arr 待调整的数组 * @param i 表示非叶子结点在数组中索引 * @param lenght 表示对多少个元素继续调整， length 是在逐渐的减少 */ public static void adjustHeap(int arr[], int i, int lenght) &#123; int temp = arr[i];//先取出当前元素的值，保存在临时变量 //开始调整 //说明 //1. k = i * 2 + 1 k 是 i结点的左子结点 for(int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) &#123; if(k+1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k+1]) &#123; //说明左子结点的值小于右子结点的值 k++; // k 指向右子结点 &#125; if(arr[k] &gt; temp) &#123; //如果子结点大于父结点 arr[i] = arr[k]; //把较大的值赋给当前结点 i = k; //!!! i 指向 k,继续循环比较 &#125; else &#123; break;//! &#125; &#125; //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部) arr[i] = temp;//将temp值放到调整后的位置 &#125; &#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法基数排序(Radix Sort)是桶排序的扩展基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 时间复杂度与空间复杂度和稳定性基数排序在最坏，平均情况下时间复杂度为O(d(r+n))，最好情况为O(d(n+rd))，空间复杂度是 O(rd+n)，稳定性为稳定 排序思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123; 53, 3, 542, 748, 14, 214&#125;; // 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G // int[] arr = new int[8000000];// for (int i = 0; i &lt; 8000000; i++) &#123;// arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数// &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); radixSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); System.out.println("基数排序后 " + Arrays.toString(arr)); &#125; //基数排序方法 public static void radixSort(int[] arr) &#123; //根据前面的推导过程，我们可以得到最终的基数排序代码 //1. 得到数组中最大的数的位数 int max = arr[0]; //假设第一数就是最大数 for(int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //得到最大数是几位数 int maxLength = (max + "").length(); //定义一个二维数组，表示10个桶, 每个桶就是一个一维数组 //说明 //1. 二维数组包含10个一维数组 //2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length //3. 名明确，基数排序是使用空间换时间的经典算法 int[][] bucket = new int[10][arr.length]; //为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数 //可以这里理解 //比如：bucketElementCounts[0] , 记录的就是 bucket[0] 桶的放入数据个数 int[] bucketElementCounts = new int[10]; //这里我们使用循环将代码处理 for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) &#123; //(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位.. for(int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的对应位的值 int digitOfElement = arr[j] / n % 10; //放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放入到原数组 if(bucketElementCounts[k] != 0) &#123; //循环该桶即第k个桶(即第k个一维数组), 放入 for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; //System.out.println("第"+(i+1)+"轮，对个位的排序处理 arr =" + Arrays.toString(arr)); &#125; /* //第1轮(针对每个元素的个位进行排序处理) for(int j = 0; j &lt; arr.length; j++) &#123; //取出每个元素的个位的值 int digitOfElement = arr[j] / 1 % 10; //放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; //按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) int index = 0; //遍历每一桶，并将桶中是数据，放入到原数组 for(int k = 0; k &lt; bucketElementCounts.length; k++) &#123; //如果桶中，有数据，我们才放入到原数组 if(bucketElementCounts[k] != 0) &#123; //循环该桶即第k个桶(即第k个一维数组), 放入 for(int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第1轮，对个位的排序处理 arr =" + Arrays.toString(arr)); //========================================== //第2轮(针对每个元素的十位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的十位的值 int digitOfElement = arr[j] / 10 % 10; //748 / 10 =&gt; 74 % 10 =&gt; 4 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(即第k个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第2轮，对个位的排序处理 arr =" + Arrays.toString(arr)); //第3轮(针对每个元素的百位进行排序处理) for (int j = 0; j &lt; arr.length; j++) &#123; // 取出每个元素的百位的值 int digitOfElement = arr[j] / 100 % 10; // 748 / 100 =&gt; 7 % 10 = 7 // 放入到对应的桶中 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; // 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组) index = 0; // 遍历每一桶，并将桶中是数据，放入到原数组 for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; // 如果桶中，有数据，我们才放入到原数组 if (bucketElementCounts[k] != 0) &#123; // 循环该桶即第k个桶(即第k个一维数组), 放入 for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; // 取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; //第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！ bucketElementCounts[k] = 0; &#125; System.out.println("第3轮，对个位的排序处理 arr =" + Arrays.toString(arr)); */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 时间复杂度与空间复杂度和稳定性归并排序在平均和最好及最坏情况下的时间复杂度是 O(nlog2n)，空间复杂度是 O(1)，稳定性为稳定 排序思想 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106public class MergetSort &#123; public static void main(String[] args) &#123; //int arr[] = &#123; 8, 4, 5, 7, 1, 3, 6, 2 &#125;; // //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); int temp[] = new int[arr.length]; //归并排序需要一个额外空间 mergeSort(arr, 0, arr.length - 1, temp); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("归并排序后=" + Arrays.toString(arr)); &#125; //分+合方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if(left &lt; right) &#123; int mid = (left + right) / 2; //中间索引 //向左递归进行分解 mergeSort(arr, left, mid, temp); //向右递归进行分解 mergeSort(arr, mid + 1, right, temp); //合并 merge(arr, left, mid, right, temp); &#125; &#125; //合并的方法 /** * * @param arr 排序的原始数组 * @param left 左边有序序列的初始索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 做中转的数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i, 左边有序序列的初始索引 int j = mid + 1; //初始化j, 右边有序序列的初始索引 int t = 0; // 指向temp数组的当前索引 //(一) //先把左右两边(有序)的数据按照规则填充到temp数组 //直到左右两边的有序序列，有一边处理完毕为止 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123;//继续 //如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素 //即将左边的当前元素，填充到 temp数组 //然后 t++, i++ if(arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; //反之,将右边有序序列的当前元素，填充到temp数组 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; //(二) //把有剩余数据的一边的数据依次全部填充到temp while( i &lt;= mid) &#123; //左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while( j &lt;= right) &#123; //右边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[j]; t += 1; j += 1; &#125; //(三) //将temp数组的元素拷贝到arr //注意，并不是每次都拷贝所有 t = 0; int tempLeft = left; // //第一次合并 tempLeft = 0 , right = 1 // tempLeft = 2 right = 3 // tL=0 ri=3 //最后一次 tempLeft = 0 right = 7 while(tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍快速排序（Quicksort）是对冒泡排序的一种改进时间复杂度与空间复杂度和稳定性快速排序在最坏情况下的时间复杂度是 O(n^2)，最好和平均情况下是 O(nlog2n)，空间复杂度是 O(nlog2n)，稳定性为不稳定 排序思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class QuickSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123;-9,78,0,23,-567,70, -1,900, 4561&#125;; //测试快排的执行速度 // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); quickSort(arr, 0, arr.length-1); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("arr=" + Arrays.toString(arr)); &#125; public static void quickSort(int[] arr,int left, int right) &#123; int l = left; //左下标 int r = right; //右下标 //pivot 中轴值 int pivot = arr[(left + right) / 2]; int temp = 0; //临时变量，作为交换时使用 //while循环的目的是让比pivot 值小放到左边 //比pivot 值大放到右边 while( l &lt; r) &#123; //在pivot的左边一直找,找到大于等于pivot值,才退出 while( arr[l] &lt; pivot) &#123; l += 1; &#125; //在pivot的右边一直找,找到小于等于pivot值,才退出 while(arr[r] &gt; pivot) &#123; r -= 1; &#125; //如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是 //小于等于pivot值，右边全部是大于等于pivot值 if( l &gt;= r) &#123; break; &#125; //交换 temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移 if(arr[l] == pivot) &#123; r -= 1; &#125; //如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移 if(arr[r] == pivot) &#123; l += 1; &#125; &#125; // 如果 l == r, 必须l++, r--, 否则为出现栈溢出 if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if(left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if(right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。时间复杂度与空间复杂度和稳定性希尔排序在最坏情况时间复杂度是 O(n^2)，在最好情况下是O(n^1.3),平均为O(n),空间复杂度是 O(1），稳定性为不稳定 排序思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ShellSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123; 8, 9, 1, 7, 2, 3, 5, 4, 6, 0 &#125;; // 创建要给80000个的随机的数组 int[] arr = new int[8000000]; for (int i = 0; i &lt; 8000000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); //shellSort(arr); //交换式 shellSort2(arr);//移位方式 Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println(Arrays.toString(arr)); &#125; // 使用逐步推导的方式来编写希尔排序 // 希尔排序时， 对有序序列在插入时采用交换法, // 思路(算法) ===&gt; 代码 public static void shellSort(int[] arr) &#123; int temp = 0; int count = 0; // 根据前面的逐步分析，使用循环处理 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共gap组，每组有个元素), 步长gap for (int j = i - gap; j &gt;= 0; j -= gap) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; //System.out.println("希尔排序第" + (++count) + "轮 =" + Arrays.toString(arr)); &#125; /* // 希尔排序的第1轮排序 // 因为第1轮排序，是将10个数据分成了 5组 for (int i = 5; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 5; j &gt;= 0; j -= 5) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 5]) &#123; temp = arr[j]; arr[j] = arr[j + 5]; arr[j + 5] = temp; &#125; &#125; &#125; System.out.println("希尔排序1轮后=" + Arrays.toString(arr));// // 希尔排序的第2轮排序 // 因为第2轮排序，是将10个数据分成了 5/2 = 2组 for (int i = 2; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 2; j &gt;= 0; j -= 2) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 2]) &#123; temp = arr[j]; arr[j] = arr[j + 2]; arr[j + 2] = temp; &#125; &#125; &#125; System.out.println("希尔排序2轮后=" + Arrays.toString(arr));// // 希尔排序的第3轮排序 // 因为第3轮排序，是将10个数据分成了 2/2 = 1组 for (int i = 1; i &lt; arr.length; i++) &#123; // 遍历各组中所有的元素(共5组，每组有2个元素), 步长5 for (int j = i - 1; j &gt;= 0; j -= 1) &#123; // 如果当前元素大于加上步长后的那个元素，说明交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; System.out.println("希尔排序3轮后=" + Arrays.toString(arr));// */ &#125; //对交换式的希尔排序进行优化-&gt;移位法 public static void shellSort2(int[] arr) &#123; // 增量gap, 并逐步的缩小增量 for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; // 从第gap个元素，逐个对其所在的组进行直接插入排序 for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; //移动 arr[j] = arr[j-gap]; j -= gap; &#125; //当退出while后，就给temp找到插入的位置 arr[j] = temp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。时间复杂度与空间复杂度和稳定性插入排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 排序思想把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class InsertSort &#123; public static void main(String[] args) &#123; //int[] arr = &#123;101, 34, 119, 1, -1, 89&#125;; // 创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("插入排序前"); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); insertSort(arr); //调用插入排序算法 Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println(Arrays.toString(arr)); &#125; //插入排序 public static void insertSort(int[] arr) &#123; int insertVal = 0; int insertIndex = 0; //使用for循环来把代码简化 for(int i = 1; i &lt; arr.length; i++) &#123; //定义待插入的数 insertVal = arr[i]; insertIndex = i - 1; // 即arr[1]的前面这个数的下标 // 给insertVal 找到插入的位置 // 说明 // 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 // 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 // 3. 就需要将 arr[insertIndex] 后移 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; // 当退出while循环时，说明插入的位置找到, insertIndex + 1 // 举例：理解不了，我们一会 debug //这里我们判断是否需要赋值 if(insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; //System.out.println("第"+i+"轮插入"); //System.out.println(Arrays.toString(arr)); &#125; /* //使用逐步推导的方式来讲解，便利理解 //第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125; //&#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125; //定义待插入的数 int insertVal = arr[1]; int insertIndex = 1 - 1; //即arr[1]的前面这个数的下标 //给insertVal 找到插入的位置 //说明 //1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界 //2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置 //3. 就需要将 arr[insertIndex] 后移 while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; //当退出while循环时，说明插入的位置找到, insertIndex + 1 //举例：理解不了，我们一会 debug arr[insertIndex + 1] = insertVal; System.out.println("第1轮插入"); System.out.println(Arrays.toString(arr)); //第2轮 insertVal = arr[2]; insertIndex = 2 - 1; while(insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex] ) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println("第2轮插入"); System.out.println(Arrays.toString(arr)); //第3轮 insertVal = arr[3]; insertIndex = 3 - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex];// arr[insertIndex] insertIndex--; &#125; arr[insertIndex + 1] = insertVal; System.out.println("第3轮插入"); System.out.println(Arrays.toString(arr)); */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。时间复杂度与空间复杂度和稳定性选择排序在平均和最坏情况下及最好情况下的时间复杂度是 O(n^2)，空间复杂度是 O(1），稳定性为不稳定 排序思想第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class SelectSort &#123; public static void main(String[] args) &#123; //int [] arr = &#123;101, 34, 119, 1, -1, 90, 123&#125;; //创建要给80000个的随机的数组 int[] arr = new int[80000]; for (int i = 0; i &lt; 80000; i++) &#123; arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数 &#125; System.out.println("排序前"); //System.out.println(Arrays.toString(arr)); Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); selectSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序前的时间是=" + date2Str); //System.out.println("排序后"); //System.out.println(Arrays.toString(arr)); &#125; //选择排序 public static void selectSort(int[] arr) &#123; //在推导的过程，我们发现了规律，因此，可以使用for来解决 //选择排序时间复杂度是 O(n^2) for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; //System.out.println("第"+(i+1)+"轮后~~"); //System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 &#125; /* //使用逐步推导的方式来，讲解选择排序 //第1轮 //原始的数组 ： 101, 34, 119, 1 //第一轮排序 : 1, 34, 119, 101 //算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决 //第1轮 int minIndex = 0; int min = arr[0]; for(int j = 0 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; //说明假定的最小值，并不是最小 min = arr[j]; //重置min minIndex = j; //重置minIndex &#125; &#125; //将最小值，放在arr[0], 即交换 if(minIndex != 0) &#123; arr[minIndex] = arr[0]; arr[0] = min; &#125; System.out.println("第1轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第2轮 minIndex = 1; min = arr[1]; for (int j = 1 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if(minIndex != 1) &#123; arr[minIndex] = arr[1]; arr[1] = min; &#125; System.out.println("第2轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 119, 101 //第3轮 minIndex = 2; min = arr[2]; for (int j = 2 + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; // 说明假定的最小值，并不是最小 min = arr[j]; // 重置min minIndex = j; // 重置minIndex &#125; &#125; // 将最小值，放在arr[0], 即交换 if (minIndex != 2) &#123; arr[minIndex] = arr[2]; arr[2] = min; &#125; System.out.println("第3轮后~~"); System.out.println(Arrays.toString(arr));// 1, 34, 101, 119 */ &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。时间复杂度与空间复杂度和稳定性 冒泡排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109public class BubbleSort &#123; public static void main(String[] args) &#123;// int arr[] = &#123;3, 9, -1, 10, 20&#125;;// // System.out.println("排序前");// System.out.println(Arrays.toString(arr)); //为了容量理解，我们把冒泡排序的演变过程，给大家展示 //测试一下冒泡排序的速度O(n^2), 给80000个数据，测试 //创建要给80000个的随机的数组 int[] arr = new int[80000]; for(int i =0; i &lt; 80000;i++) &#123; arr[i] = (int)(Math.random() * 8000000); //生成一个[0, 8000000) 数 &#125; Date data1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String date1Str = simpleDateFormat.format(data1); System.out.println("排序前的时间是=" + date1Str); //测试冒泡排序 bubbleSort(arr); Date data2 = new Date(); String date2Str = simpleDateFormat.format(data2); System.out.println("排序后的时间是=" + date2Str); //System.out.println("排序后"); //System.out.println(Arrays.toString(arr)); /* // 第二趟排序，就是将第二大的数排在倒数第二位 for (int j = 0; j &lt; arr.length - 1 - 1 ; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第二趟排序后的数组"); System.out.println(Arrays.toString(arr)); // 第三趟排序，就是将第三大的数排在倒数第三位 for (int j = 0; j &lt; arr.length - 1 - 2; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第三趟排序后的数组"); System.out.println(Arrays.toString(arr)); // 第四趟排序，就是将第4大的数排在倒数第4位 for (int j = 0; j &lt; arr.length - 1 - 3; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第四趟排序后的数组"); System.out.println(Arrays.toString(arr)); */ &#125; // 将前面额冒泡排序算法，封装成一个方法 public static void bubbleSort(int[] arr) &#123; // 冒泡排序 的时间复杂度 O(n^2), 自己写出 int temp = 0; // 临时变量 boolean flag = false; // 标识变量，表示是否进行过交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; // 如果前面的数比后面的数大，则交换 if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; //System.out.println("第" + (i + 1) + "趟排序后的数组"); //System.out.println(Arrays.toString(arr)); if (!flag) &#123; // 在一趟排序中，一次交换都没有发生过 break; &#125; else &#123; flag = false; // 重置flag!!!, 进行下次判断 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新开始]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[好久没写博客，发现写博客还是一个比较好的 学习方法，从今天起开始更新 立个flag]]></content>
      <categories>
        <category>杂说</category>
      </categories>
      <tags>
        <tag>个人瞎说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好东西分享下]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%A5%BD%E4%B8%9C%E8%A5%BF%E5%88%86%E4%BA%AB%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事，想搞下安全，权限框架，然后发现springsecurity以我现在的水平学来，很吃力，于是网上搜索，发现有一个博主写的springsecurity的文章很适合新手上手，故来分享下，只能待我日后搞明白了自己再专门写篇文章。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring，springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 如何集成 Swagger]]></title>
    <url>%2F2019%2F09%2F26%2FSpringboot-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90-Swagger%2F</url>
    <content type="text"><![CDATA[随着本人摸鱼天数的增加，本人开始学习各种东西，今天说一个比较好用的工具Swagger。这个工具的好处是可以将后台的API接口直接暴露出来，这样前端工程师写接口传参的时候，就可以很快也很方便了。Springboot如何集成Swagger首先你需要在pom.xml中加入以下代码123456789101112&lt;!-- 集成swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 具体要加入什么版本，大家自己可以去maven仓库中寻找，本人写的时候最新是2.9.2就用它了。 然后创建一个配置类Swagger2Config.java 123456789101112131415161718192021222324252627282930313233343536package com.nano.roupian.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.nano.roupian")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("肉片系统Restful API") .description("肉片系统Restful API") .termsOfServiceUrl("http://127.0.0.1:8080/") .version("1.0") .build(); &#125; &#125; 其中basePackage后面 跟的参数是你要扫描的包，而termsofServiceUrl后面跟的是swaggerUI展示的地址，这些搞好后你，你只需要去http://localhost:8080/swagger-ui.html 中就能查看到后台API了。更多详情请大家自己去官网学习把。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat 怎么将属性值设为null]]></title>
    <url>%2F2019%2F09%2F26%2FNavicat-%E6%80%8E%E4%B9%88%E5%B0%86%E5%B1%9E%E6%80%A7%E5%80%BC%E8%AE%BE%E4%B8%BAnull%2F</url>
    <content type="text"><![CDATA[最近本人在搞代码自测时，被一个很蠢的坑搞了，故今天分享并mark，以让自己以后不犯傻。这个坑，主要形成是这样的，作者将mysql表中的一个属性的属性值删除了，结果以为这个属性值为空了，却没想到其实为空串，于是让本人犯了一个较为愚蠢的NullPoint异常，现在就说下怎么才能删的干净。怎么用navicat改为null 由于这是涉及简单操作的事情，所以我就用图来解释把。 First Second鼠标点击那个值然后右击]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Java连接微信公众号后台，获取接口，与token]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8Etoken%2F</url>
    <content type="text"><![CDATA[如何打开微信公众号开发者模式相信如果如果玩过公众号都知道，要打开公众号配置，需要一个服务器地址，不过大部分人玩它是用来搞测试的，所以我就介绍一个免费的用来反向代理的软件 ngork，用它你就可以将自己8080 端口暴露给外网，而且使用简单，只需要打开它然后输入ngrok http 8080 命令就行了 java来写接入代码这代码我是从网上看哔哩哔哩写的 如果，有兴趣可以直接哔哩哔哩 java微信公众号就能收到了，首先创建一个servlet，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package WeiXinServlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import Service.WxService;/** * Servlet implementation class wxServlet */@WebServlet("/wxServlet")public class wxServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public wxServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.print("--------------------------------------"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); String echostr = request.getParameter("echostr"); //较验证请求 if(WxService.check(timestamp,nonce,signature)) &#123; PrintWriter out = response.getWriter(); //原样返回echostr参数 out.println(echostr); out.flush(); out.close(); System.out.println("接入成功"); &#125;else &#123; System.out.println("接入失败"); &#125; &#125;&#125; 通过get方法来接收传来的参数，因为微信公众号开发需要通过这三个参数，通过SHA1加密认证. 再写个service来做SHA1加密认证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String APPID = "wxf2a10b83349c22a3"; //这个为你在配置页得到的自己的APPID private static final String APPSECRET = "749b5f9f551d30723a7d20646749cddb"; //这个为你在配置页得到的自己的APPSECRE private static final String TOKEN = "abc"; //这个为你在配置页提阿涅的TOKEN&#125;/** * * 验证签名 */ public static boolean check(String timestamp,String nonce , String signature) &#123; //1. 将token、timestamp、nonce三个蚕食进行字典序排序 String[] strs = new String[] &#123;TOKEN,timestamp,nonce&#125;; Arrays.sort(strs); //2. 将三个参数字符串拼接成一个字符串进行sha1加密 String str = strs[0]+strs[1]+strs[2]; String mysia = sha1(str); System.out.println("到达check方法中！"); System.out.println(mysia); System.out.println(signature); //3. 开发者获得加密后的字符串与signature对比，标识该请求来源于微信 return mysia.equalsIgnoreCase(signature); &#125; private static String sha1(String src) &#123; try &#123; //获取加密对象 MessageDigest md = MessageDigest.getInstance("sha1"); //加密 byte[] digest = md.digest(src.getBytes()); char[] chars = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; StringBuilder sb = new StringBuilder(); //处理加密结果 for(byte b:digest) &#123; sb.append(chars[(b&gt;&gt;4)&amp;15]); sb.append(chars[b&amp;15]); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println("error:"+e.getMessage()); &#125; return null; &#125; /** * 获取signature * 特别注意的是调用微信js，url必须是当前页面(转发的不行) * @throws Exception */ public static String getSignature(String url) throws Exception&#123;// 第三步:对密钥进行sha1加密 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String ticket = getJsApiTicket(); long time = System.currentTimeMillis()/1000; String randomStr = "1485965214789631"; String str = "jsapi_ticket=" + ticket + "&amp;noncestr=" + randomStr+ "&amp;timestamp=" + time + "&amp;url="+url; String signature = ""; try &#123; MessageDigest crypt = MessageDigest.getInstance("SHA-1"); crypt.reset(); crypt.update(str.getBytes("UTF-8")); //对string1 字符串进行SHA-1加密处理 signature = byteToHex(crypt.digest()); //对加密后字符串转成16进制// signature = sha1(str); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("signature生成失败!"); &#125; map.put("timeStamp", String.valueOf(time)); map.put("randomStr", randomStr); map.put("signature", signature); System.out.println("ticket:"+ticket+",result:"+com.alibaba.fastjson.JSONObject.toJSONString(map)); return com.alibaba.fastjson.JSON.toJSONString(map); &#125; private static String byteToHex(final byte[] hash) &#123; Formatter formatter = new Formatter(); for (byte b : hash) &#123; formatter.format("%02x", b); &#125; String result = formatter.toString(); formatter.close(); return result; &#125; 然后再接口配置信息填写ngrok改的URL 再点击确认 就可以了，这期间需要点时间等候 用java写获取token的方法因为微信公众号大部分功能需要获取token才能搞的，所以这里写下方法 创建个AccessToken的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.whale.weixin.entity;/** * 保存Token（只有俩个小时的时限） * * */public class AccessToken &#123; private String accessToken; //计算过期时间 private long expireTime; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(long expireTime) &#123; this.expireTime = expireTime; &#125; public AccessToken(String accessToken, String expireIn) &#123; super(); this.accessToken = accessToken; this.expireTime = System.currentTimeMillis()+Integer.parseInt(expireIn)*1000; &#125; /** * 判断token是否过期 * @return */ public boolean isExpired() &#123; return System.currentTimeMillis()&gt;expireTime; &#125; &#125; 创建个工具类来发get与post 请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.whale.weixin.util;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class Util &#123; // 用于存储token /** * 向指定的地址发送get请求 用于获取微信Token * * @param url * @return */ public static String get(String url) &#123; try &#123; URL urlObj = new URL(url); // 开链接 URLConnection connection = urlObj.openConnection(); InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125; /** * 向指定地址发送一个post请求，待着data数据 * * @param url * @param data * @return */ public static String post(String url, String data) &#123; try &#123; URL urlObject = new URL(url); URLConnection connection = urlObject.openConnection(); // 要发鸿数据出去，必须要发送可发送数据状态 connection.setDoOutput(true); // 获取输出流 OutputStream os = connection.getOutputStream(); // 写出数据 os.write(data.getBytes()); os.close(); // 获取输入流 InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125;&#125; 在service中编写获取token的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String GET_TOKENURL_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET"; //用于存储token private static AccessToken at; /** * 获取token */ private static void getToken() &#123; String url = GET_TOKENURL_URL.replace("APPID", APPID).replace("APPSECRET", APPSECRET); String tokenStr = Utils.get(url);// System.out.println(tokenStr); JSONObject jsonObject = JSONObject.fromObject(tokenStr); String token = jsonObject.getString("access_token"); String expireIn = jsonObject.getString("expires_in"); //创建token对象，并存起来。 at = new AccessToken(token, expireIn); &#125; /** * 向外暴露的获取token的方法 * @return */ public static String getAccessToken() &#123; if(null==at||at.isExpired()) &#123; getToken(); &#125; return at.getAccessToken(); &#125;&#125; 以上便是简易的java来写微信后台的代码，由于大部分代码我是通过看别人视频获得的，所以也不详细写了，有兴趣的话可以去bilibli上搜索看看]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用springboot快速建立helloworld项目]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%A6%82%E4%BD%95%E7%94%A8springboot%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8Bhelloworld%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[什么是springbootspringboot是一个spring微服务框架，具体是什么，大家可以去spring官网上进行了解如何快速的创建helloworld项目通过springboot快速构建网站创建maven项目进入springboot快速建立网站，Project选择Maven Project，SpringBoot版本选择2.1.7，我写这篇的时候，2.1.7为稳定版，请大家自行选择当前稳定版，如不知道可以去springboot指南中去看，看见红色GA结尾的就是稳定版，然后选择依赖，也就是Dependencies，这里我们只选择Web中的SpringWebStarter。 创建helloworld将刚刚创建出来的maven项目解压缩，并导入项目，修改主目录自动生成的Application.java中的代码如下 1234567891011121314@Controller@EnableAutoConfiguration@SpringBootApplicationpublic class TestApplication &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 然后右键项目-&gt;Run as-&gt;Spring Boot App 进入localhost:8080下就能看到helloworld了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用maven快速建立个web工程]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A6%82%E4%BD%95%E7%94%A8maven%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E4%B8%AAweb%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事天天看视频，发现自己以前用maven建工程方式貌似有点瓜皮，所以写个文章在记录，也方便工作学习什么是maven工程maven是一个很方便构建项目的工具，有了它就可以不用到处找jar包了，而且现在越来越多的技术，貌似都是直接用maven导入的所以，我觉得还是需要搞的，而它中配置jar的地方主要是在pom.xml中写，而如果你想找要加什么东西进去，可以去maven市场中寻找。 如何配置maven环境maven是一个java搞的东西，所以你要配置java环境，不过我觉得这个东西大家估计都会就不说了，然后是配置maven的环境，感觉和配置java一样简单，所以也不说了 如何配置maven为阿里私服由于默认maven服务器下载起来很慢，所以一般国内我还是推荐修改为阿里的私服，这样会快点，修改文件为maven解压路径下conf目录下的setting文件，需要在mirrors节点加入 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如下图所示 如何在eclipse中配置maven环境点击window-&gt;preferences-&gt;maven这里需要修改的配置有两个地方，一个在Installations，一个在User Settings中， 如何用eclipse快速建立maven的web工程点击 File-&gt;New-&gt;Maven Project，然后弹出页面记得勾选Create a simple project 的选项，操作如下图然后点击finish，就创建好了项目，这时候你发现很坑爹怎么没有WEB-INF与META-INF目录，没事你只要右击项目选择properties-&gt;Project Facets，然后勾选掉Dynamic Web Module 点击Apply，再点击 Dynamic Web Module ，就出现了 Futher configuration available… 的字眼，点击它 然后点击OK，一个Maven项目的web目录就搭建好了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2019%2F08%2F29%2FFirst%2F</url>
    <content type="text"><![CDATA[之前搞的博客，发现上传方式很难受，后来我又看了下炳强的博客后，又开始重新搞了个 欢迎大家去看他写的，很详细，基本上把next主题翻译了]]></content>
      <categories>
        <category>java</category>
        <category>github</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
