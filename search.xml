<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基数排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法基数排序(Radix Sort)是桶排序的扩展基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 时间复杂度与空间复杂度和稳定性基数排序在最坏，平均情况下时间复杂度为O(d(r+n))，最好情况为O(d(n+rd))，空间复杂度是 O(rd+n)，稳定性为稳定 排序思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;53, 3, 542, 748, 14, 214&#125;; radixSort(arr); &#125; //基数排序 public static void radixSort(int[] arr) &#123; int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; int maxLength = (max + "").length(); //定义一哥二维数组，表示10个桶 int[][] bucket = new int[10][arr.length]; int[] bucketElementCounts = new int[10]; for (int i = 0; i &lt; maxLength; i++) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int digitOfElement = arr[j]/ (int)Math.pow(10,i)% 10; //放入到对应的同种 bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j]; bucketElementCounts[digitOfElement]++; &#125; int index = 0; for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123; if (bucketElementCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123; //取出元素放入到arr arr[index++] = bucket[k][l]; &#125; &#125; bucketElementCounts[k] = 0; &#125; System.out.println("第"+(i+1)+"轮，对个位的排序处理arr =" + Arrays.toString(arr)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 时间复杂度与空间复杂度和稳定性归并排序在平均和最好及最坏情况下的时间复杂度是 O(nlog2n)，空间复杂度是 O(1)，稳定性为稳定 排序思想 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MergeSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int temp[] = new int[arr.length]; mergeSort(arr, 0, arr.length - 1, temp); System.out.println(Arrays.toString(arr)); &#125; //分+合的方法 public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2;//中间索引 //向左递归进行分解 mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; //合并的方法 /** * @param arr 原始数组 * @param left 左边索引 * @param mid 中间索引 * @param right 右边索引 * @param temp 中转数组 */ public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; // 初始化i,左边有序序列的初始索引 int j = mid + 1; //初始化j，右边有序序列的初始索引 int t = 0; //指向temp数组的当前索引 while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; //继续 if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; //反之 temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; while (i &lt;= mid) &#123;//左边的有序序列还有剩余的元素，就全部填充到temp temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; t = 0; int tempLeft = left; System.out.println("tempLeft=" + tempLeft + " right=" + right); while (tempLeft &lt;= right) &#123; arr[tempLeft] = temp[t]; t += 1; tempLeft += 1; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍快速排序（Quicksort）是对冒泡排序的一种改进时间复杂度与空间复杂度和稳定性快速排序在最坏情况下的时间复杂度是 O(n^2)，最好和平均情况下是 O(nlog2n)，空间复杂度是 O(nlog2n)，稳定性为不稳定 排序思想通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 图解 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class QuickSort &#123; public static void main(String[] args) &#123;// int[] arr = &#123;-9, 78, 0, 1, -3, 23, -567, 70,11,23,-111,-23&#125;; int [] arr = new int[800000]; for(int i = 0;i&lt;800000;i++)&#123; arr[i]= (int)(Math.random()*80000); &#125; long l = System.currentTimeMillis(); quickSort(arr, 0, arr.length - 1); System.out.println(System.currentTimeMillis()-l);// System.out.println(Arrays.toString(arr)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; int l = left;//左下表 int r = right;//右下标 int pivot = arr[(left + right) / 2]; int temp = 0; while (l &lt; r) &#123; //在pivot的左边一直找，找到大于等于pivot的值，才退出 while (arr[l] &lt; pivot) &#123; l += 1; &#125; //在pivot的右边一直找，找到小于等于pivot的值，才退出 while (arr[r] &gt; pivot) &#123; r -= 1; &#125; //如果l&gt;=r 说明privot 左右两边值排好 if (l &gt;= r) &#123; break; &#125; // temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; //如果交换完，发现这个arr【l]==privot值 相等 迁移 if (arr[l] == pivot) &#123; r -= 1; &#125; if (arr[r] == pivot) &#123; l += 1; &#125; &#125; //如果 if (l == r) &#123; l += 1; r -= 1; &#125; if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。时间复杂度与空间复杂度和稳定性希尔排序在最坏情况时间复杂度是 O(n^2)，在最好情况下是O(n^1.3),平均为O(n),空间复杂度是 O(1），稳定性为不稳定 排序思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 图解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.nano.sort;/** * @author Nano * @create 2020 -04 -20 14:25 */public class ShellSort &#123; //更高效的插入排序 public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; shellSort2(arr); &#125; //使用逐步推导方式进行shell排序 //交换法// public static void shellSort(int[] arr) &#123;// //因为第一轮排序，将10个数据分成5组// int temp = 0;// int count = 0;// for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123;// for (int i = gap; i &lt; arr.length; i++) &#123;// for (int j = i - gap; j &gt;= 0; j -= gap) &#123;// //如果当前元素大于家上步长后的那个元素// if (arr[j] &gt; arr[j + gap]) &#123;// temp = arr[j];// arr[j] = arr[j + gap];// arr[j + gap] = temp;// &#125;// &#125;// &#125;//// System.out.println("希尔排序" + (++count) + "轮后" + Arrays.toString(arr));// &#125;// &#125; //移位法 public static void shellSort2(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[j]; if (arr[j] &lt; arr[j - gap]) &#123; while (j - gap &gt;= 0 &amp;&amp; temp &lt; arr[j - gap]) &#123; arr[j] = arr[j - gap]; j -= gap; &#125; //当退出while 就给temp找到插入的额外i子 arr[j] = temp; &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。时间复杂度与空间复杂度和稳定性插入排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 排序思想把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 图解 代码123456789101112131415161718192021222324252627282930313233public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34,52,12, 119, 1&#125;; insertSort(arr); &#125; //插入排序 public static void insertSort(int[] arr) &#123; //定义待插入的数 int insertVal = 0; int insertIndex = 0;//即arr[1]的前面数的下标 for (int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i - 1;//即arr[1]的前面数的下标 //给insertVal 找到插入的位置 //1.insertIndex &gt;=0 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; //当退出while循环时，说明插入的位置找到，indexIndex+1 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; System.out.println("第" + i + "论插入"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选择排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。时间复杂度与空间复杂度和稳定性选择排序在平均和最坏情况下及最好情况下的时间复杂度是 O(n^2)，空间复杂度是 O(1），稳定性为不稳定 排序思想第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 图解 代码1234567891011121314151617181920212223242526272829303132public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;101, 34, 119, 1&#125;; selectSort(arr); &#125; //选择排序 public static void selectSort(int[] arr) &#123; //使用逐步推到方式 for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; //说明最小值不是最小 min = arr[j];//重置min minIndex = j;//重置minIndex &#125; &#125; //将最小值，和arr[j]交换 if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println("第" + (i + 1) + "轮后"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。时间复杂度与空间复杂度和稳定性 冒泡排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1)，稳定性为稳定 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; //为了容易理解，我们把过程展示出来 //第一堂排序就是将最大的数排在最后 int temp = 0; boolean flag = false; //表示变量 表示是否进行锅交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); if (!flag) &#123; break; &#125; else &#123; flag = false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新开始]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[好久没写博客，发现写博客还是一个比较好的 学习方法，从今天起开始更新 立个flag]]></content>
      <categories>
        <category>杂说</category>
      </categories>
      <tags>
        <tag>个人瞎说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好东西分享下]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%A5%BD%E4%B8%9C%E8%A5%BF%E5%88%86%E4%BA%AB%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事，想搞下安全，权限框架，然后发现springsecurity以我现在的水平学来，很吃力，于是网上搜索，发现有一个博主写的springsecurity的文章很适合新手上手，故来分享下，只能待我日后搞明白了自己再专门写篇文章。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring，springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 如何集成 Swagger]]></title>
    <url>%2F2019%2F09%2F26%2FSpringboot-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90-Swagger%2F</url>
    <content type="text"><![CDATA[随着本人摸鱼天数的增加，本人开始学习各种东西，今天说一个比较好用的工具Swagger。这个工具的好处是可以将后台的API接口直接暴露出来，这样前端工程师写接口传参的时候，就可以很快也很方便了。Springboot如何集成Swagger首先你需要在pom.xml中加入以下代码123456789101112&lt;!-- 集成swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 具体要加入什么版本，大家自己可以去maven仓库中寻找，本人写的时候最新是2.9.2就用它了。 然后创建一个配置类Swagger2Config.java 123456789101112131415161718192021222324252627282930313233343536package com.nano.roupian.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.nano.roupian")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("肉片系统Restful API") .description("肉片系统Restful API") .termsOfServiceUrl("http://127.0.0.1:8080/") .version("1.0") .build(); &#125; &#125; 其中basePackage后面 跟的参数是你要扫描的包，而termsofServiceUrl后面跟的是swaggerUI展示的地址，这些搞好后你，你只需要去http://localhost:8080/swagger-ui.html 中就能查看到后台API了。更多详情请大家自己去官网学习把。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat 怎么将属性值设为null]]></title>
    <url>%2F2019%2F09%2F26%2FNavicat-%E6%80%8E%E4%B9%88%E5%B0%86%E5%B1%9E%E6%80%A7%E5%80%BC%E8%AE%BE%E4%B8%BAnull%2F</url>
    <content type="text"><![CDATA[最近本人在搞代码自测时，被一个很蠢的坑搞了，故今天分享并mark，以让自己以后不犯傻。这个坑，主要形成是这样的，作者将mysql表中的一个属性的属性值删除了，结果以为这个属性值为空了，却没想到其实为空串，于是让本人犯了一个较为愚蠢的NullPoint异常，现在就说下怎么才能删的干净。怎么用navicat改为null 由于这是涉及简单操作的事情，所以我就用图来解释把。 First Second鼠标点击那个值然后右击]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Java连接微信公众号后台，获取接口，与token]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8Etoken%2F</url>
    <content type="text"><![CDATA[如何打开微信公众号开发者模式相信如果如果玩过公众号都知道，要打开公众号配置，需要一个服务器地址，不过大部分人玩它是用来搞测试的，所以我就介绍一个免费的用来反向代理的软件 ngork，用它你就可以将自己8080 端口暴露给外网，而且使用简单，只需要打开它然后输入ngrok http 8080 命令就行了 java来写接入代码这代码我是从网上看哔哩哔哩写的 如果，有兴趣可以直接哔哩哔哩 java微信公众号就能收到了，首先创建一个servlet，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package WeiXinServlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import Service.WxService;/** * Servlet implementation class wxServlet */@WebServlet("/wxServlet")public class wxServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public wxServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.print("--------------------------------------"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); String echostr = request.getParameter("echostr"); //较验证请求 if(WxService.check(timestamp,nonce,signature)) &#123; PrintWriter out = response.getWriter(); //原样返回echostr参数 out.println(echostr); out.flush(); out.close(); System.out.println("接入成功"); &#125;else &#123; System.out.println("接入失败"); &#125; &#125;&#125; 通过get方法来接收传来的参数，因为微信公众号开发需要通过这三个参数，通过SHA1加密认证. 再写个service来做SHA1加密认证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String APPID = "wxf2a10b83349c22a3"; //这个为你在配置页得到的自己的APPID private static final String APPSECRET = "749b5f9f551d30723a7d20646749cddb"; //这个为你在配置页得到的自己的APPSECRE private static final String TOKEN = "abc"; //这个为你在配置页提阿涅的TOKEN&#125;/** * * 验证签名 */ public static boolean check(String timestamp,String nonce , String signature) &#123; //1. 将token、timestamp、nonce三个蚕食进行字典序排序 String[] strs = new String[] &#123;TOKEN,timestamp,nonce&#125;; Arrays.sort(strs); //2. 将三个参数字符串拼接成一个字符串进行sha1加密 String str = strs[0]+strs[1]+strs[2]; String mysia = sha1(str); System.out.println("到达check方法中！"); System.out.println(mysia); System.out.println(signature); //3. 开发者获得加密后的字符串与signature对比，标识该请求来源于微信 return mysia.equalsIgnoreCase(signature); &#125; private static String sha1(String src) &#123; try &#123; //获取加密对象 MessageDigest md = MessageDigest.getInstance("sha1"); //加密 byte[] digest = md.digest(src.getBytes()); char[] chars = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; StringBuilder sb = new StringBuilder(); //处理加密结果 for(byte b:digest) &#123; sb.append(chars[(b&gt;&gt;4)&amp;15]); sb.append(chars[b&amp;15]); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println("error:"+e.getMessage()); &#125; return null; &#125; /** * 获取signature * 特别注意的是调用微信js，url必须是当前页面(转发的不行) * @throws Exception */ public static String getSignature(String url) throws Exception&#123;// 第三步:对密钥进行sha1加密 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String ticket = getJsApiTicket(); long time = System.currentTimeMillis()/1000; String randomStr = "1485965214789631"; String str = "jsapi_ticket=" + ticket + "&amp;noncestr=" + randomStr+ "&amp;timestamp=" + time + "&amp;url="+url; String signature = ""; try &#123; MessageDigest crypt = MessageDigest.getInstance("SHA-1"); crypt.reset(); crypt.update(str.getBytes("UTF-8")); //对string1 字符串进行SHA-1加密处理 signature = byteToHex(crypt.digest()); //对加密后字符串转成16进制// signature = sha1(str); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("signature生成失败!"); &#125; map.put("timeStamp", String.valueOf(time)); map.put("randomStr", randomStr); map.put("signature", signature); System.out.println("ticket:"+ticket+",result:"+com.alibaba.fastjson.JSONObject.toJSONString(map)); return com.alibaba.fastjson.JSON.toJSONString(map); &#125; private static String byteToHex(final byte[] hash) &#123; Formatter formatter = new Formatter(); for (byte b : hash) &#123; formatter.format("%02x", b); &#125; String result = formatter.toString(); formatter.close(); return result; &#125; 然后再接口配置信息填写ngrok改的URL 再点击确认 就可以了，这期间需要点时间等候 用java写获取token的方法因为微信公众号大部分功能需要获取token才能搞的，所以这里写下方法 创建个AccessToken的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.whale.weixin.entity;/** * 保存Token（只有俩个小时的时限） * * */public class AccessToken &#123; private String accessToken; //计算过期时间 private long expireTime; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(long expireTime) &#123; this.expireTime = expireTime; &#125; public AccessToken(String accessToken, String expireIn) &#123; super(); this.accessToken = accessToken; this.expireTime = System.currentTimeMillis()+Integer.parseInt(expireIn)*1000; &#125; /** * 判断token是否过期 * @return */ public boolean isExpired() &#123; return System.currentTimeMillis()&gt;expireTime; &#125; &#125; 创建个工具类来发get与post 请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.whale.weixin.util;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class Util &#123; // 用于存储token /** * 向指定的地址发送get请求 用于获取微信Token * * @param url * @return */ public static String get(String url) &#123; try &#123; URL urlObj = new URL(url); // 开链接 URLConnection connection = urlObj.openConnection(); InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125; /** * 向指定地址发送一个post请求，待着data数据 * * @param url * @param data * @return */ public static String post(String url, String data) &#123; try &#123; URL urlObject = new URL(url); URLConnection connection = urlObject.openConnection(); // 要发鸿数据出去，必须要发送可发送数据状态 connection.setDoOutput(true); // 获取输出流 OutputStream os = connection.getOutputStream(); // 写出数据 os.write(data.getBytes()); os.close(); // 获取输入流 InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125;&#125; 在service中编写获取token的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String GET_TOKENURL_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET"; //用于存储token private static AccessToken at; /** * 获取token */ private static void getToken() &#123; String url = GET_TOKENURL_URL.replace("APPID", APPID).replace("APPSECRET", APPSECRET); String tokenStr = Utils.get(url);// System.out.println(tokenStr); JSONObject jsonObject = JSONObject.fromObject(tokenStr); String token = jsonObject.getString("access_token"); String expireIn = jsonObject.getString("expires_in"); //创建token对象，并存起来。 at = new AccessToken(token, expireIn); &#125; /** * 向外暴露的获取token的方法 * @return */ public static String getAccessToken() &#123; if(null==at||at.isExpired()) &#123; getToken(); &#125; return at.getAccessToken(); &#125;&#125; 以上便是简易的java来写微信后台的代码，由于大部分代码我是通过看别人视频获得的，所以也不详细写了，有兴趣的话可以去bilibli上搜索看看]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用springboot快速建立helloworld项目]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%A6%82%E4%BD%95%E7%94%A8springboot%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8Bhelloworld%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[什么是springbootspringboot是一个spring微服务框架，具体是什么，大家可以去spring官网上进行了解如何快速的创建helloworld项目通过springboot快速构建网站创建maven项目进入springboot快速建立网站，Project选择Maven Project，SpringBoot版本选择2.1.7，我写这篇的时候，2.1.7为稳定版，请大家自行选择当前稳定版，如不知道可以去springboot指南中去看，看见红色GA结尾的就是稳定版，然后选择依赖，也就是Dependencies，这里我们只选择Web中的SpringWebStarter。 创建helloworld将刚刚创建出来的maven项目解压缩，并导入项目，修改主目录自动生成的Application.java中的代码如下 1234567891011121314@Controller@EnableAutoConfiguration@SpringBootApplicationpublic class TestApplication &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 然后右键项目-&gt;Run as-&gt;Spring Boot App 进入localhost:8080下就能看到helloworld了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用maven快速建立个web工程]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A6%82%E4%BD%95%E7%94%A8maven%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E4%B8%AAweb%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事天天看视频，发现自己以前用maven建工程方式貌似有点瓜皮，所以写个文章在记录，也方便工作学习什么是maven工程maven是一个很方便构建项目的工具，有了它就可以不用到处找jar包了，而且现在越来越多的技术，貌似都是直接用maven导入的所以，我觉得还是需要搞的，而它中配置jar的地方主要是在pom.xml中写，而如果你想找要加什么东西进去，可以去maven市场中寻找。 如何配置maven环境maven是一个java搞的东西，所以你要配置java环境，不过我觉得这个东西大家估计都会就不说了，然后是配置maven的环境，感觉和配置java一样简单，所以也不说了 如何配置maven为阿里私服由于默认maven服务器下载起来很慢，所以一般国内我还是推荐修改为阿里的私服，这样会快点，修改文件为maven解压路径下conf目录下的setting文件，需要在mirrors节点加入 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如下图所示 如何在eclipse中配置maven环境点击window-&gt;preferences-&gt;maven这里需要修改的配置有两个地方，一个在Installations，一个在User Settings中， 如何用eclipse快速建立maven的web工程点击 File-&gt;New-&gt;Maven Project，然后弹出页面记得勾选Create a simple project 的选项，操作如下图然后点击finish，就创建好了项目，这时候你发现很坑爹怎么没有WEB-INF与META-INF目录，没事你只要右击项目选择properties-&gt;Project Facets，然后勾选掉Dynamic Web Module 点击Apply，再点击 Dynamic Web Module ，就出现了 Futher configuration available… 的字眼，点击它 然后点击OK，一个Maven项目的web目录就搭建好了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2019%2F08%2F29%2FFirst%2F</url>
    <content type="text"><![CDATA[之前搞的博客，发现上传方式很难受，后来我又看了下炳强的博客后，又开始重新搞了个 欢迎大家去看他写的，很详细，基本上把next主题翻译了]]></content>
      <categories>
        <category>java</category>
        <category>github</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
