<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[插入排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。时间复杂度与空间复杂度插入排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1） 排序思想第一次从arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]-arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]-arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]-arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]-arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 图解 代码1234567891011121314151617181920212223242526272829303132public class InsertSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; insertSort(arr); &#125; //插入排序 public static void insertSort(int[] arr) &#123; //定义待插入的数 int insertVal = 0; int insertIndex = 0;//即arr[1]的前面数的下标 for (int i = 1; i &lt; arr.length; i++) &#123; insertVal = arr[i]; insertIndex = i - 1;//即arr[1]的前面数的下标 //给insertVal 找到插入的位置 //1.insertIndex &gt;=0 while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; //当退出while循环时，说明插入的位置找到，indexIndex+1 if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; System.out.println("第" + i + "论插入"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冒泡排序]]></title>
    <url>%2F2020%2F07%2F02%2F%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取基本介绍冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。时间复杂度与空间复杂度 冒泡排序在平均和最坏情况下的时间复杂度是 O(n^2)，最好情况下是 O(n)，空间复杂度是 O(1) 优化因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。 图解 代码12345678910111213141516171819202122232425262728public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; //为了容易理解，我们把过程展示出来 //第一堂排序就是将最大的数排在最后 int temp = 0; boolean flag = false; //表示变量 表示是否进行锅交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println("第" + (i + 1) + "趟排序后的数组"); System.out.println(Arrays.toString(arr)); if (!flag) &#123; break; &#125; else &#123; flag = false; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重新开始]]></title>
    <url>%2F2020%2F07%2F02%2F%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[好久没写博客，发现写博客还是一个比较好的 学习方法，从今天起开始更新 立个flag]]></content>
      <categories>
        <category>杂说</category>
      </categories>
      <tags>
        <tag>个人瞎说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好东西分享下]]></title>
    <url>%2F2019%2F09%2F27%2F%E5%A5%BD%E4%B8%9C%E8%A5%BF%E5%88%86%E4%BA%AB%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事，想搞下安全，权限框架，然后发现springsecurity以我现在的水平学来，很吃力，于是网上搜索，发现有一个博主写的springsecurity的文章很适合新手上手，故来分享下，只能待我日后搞明白了自己再专门写篇文章。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>spring，springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot 如何集成 Swagger]]></title>
    <url>%2F2019%2F09%2F26%2FSpringboot-%E5%A6%82%E4%BD%95%E9%9B%86%E6%88%90-Swagger%2F</url>
    <content type="text"><![CDATA[随着本人摸鱼天数的增加，本人开始学习各种东西，今天说一个比较好用的工具Swagger。这个工具的好处是可以将后台的API接口直接暴露出来，这样前端工程师写接口传参的时候，就可以很快也很方便了。Springboot如何集成Swagger首先你需要在pom.xml中加入以下代码123456789101112&lt;!-- 集成swagger --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; 具体要加入什么版本，大家自己可以去maven仓库中寻找，本人写的时候最新是2.9.2就用它了。 然后创建一个配置类Swagger2Config.java 123456789101112131415161718192021222324252627282930313233343536package com.nano.roupian.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.nano.roupian")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("肉片系统Restful API") .description("肉片系统Restful API") .termsOfServiceUrl("http://127.0.0.1:8080/") .version("1.0") .build(); &#125; &#125; 其中basePackage后面 跟的参数是你要扫描的包，而termsofServiceUrl后面跟的是swaggerUI展示的地址，这些搞好后你，你只需要去http://localhost:8080/swagger-ui.html 中就能查看到后台API了。更多详情请大家自己去官网学习把。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springboot</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat 怎么将属性值设为null]]></title>
    <url>%2F2019%2F09%2F26%2FNavicat-%E6%80%8E%E4%B9%88%E5%B0%86%E5%B1%9E%E6%80%A7%E5%80%BC%E8%AE%BE%E4%B8%BAnull%2F</url>
    <content type="text"><![CDATA[最近本人在搞代码自测时，被一个很蠢的坑搞了，故今天分享并mark，以让自己以后不犯傻。这个坑，主要形成是这样的，作者将mysql表中的一个属性的属性值删除了，结果以为这个属性值为空了，却没想到其实为空串，于是让本人犯了一个较为愚蠢的NullPoint异常，现在就说下怎么才能删的干净。怎么用navicat改为null 由于这是涉及简单操作的事情，所以我就用图来解释把。 First Second鼠标点击那个值然后右击]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>navicat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Java连接微信公众号后台，获取接口，与token]]></title>
    <url>%2F2019%2F09%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8Java%E8%BF%9E%E6%8E%A5%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%90%8E%E5%8F%B0%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%8Etoken%2F</url>
    <content type="text"><![CDATA[如何打开微信公众号开发者模式相信如果如果玩过公众号都知道，要打开公众号配置，需要一个服务器地址，不过大部分人玩它是用来搞测试的，所以我就介绍一个免费的用来反向代理的软件 ngork，用它你就可以将自己8080 端口暴露给外网，而且使用简单，只需要打开它然后输入ngrok http 8080 命令就行了 java来写接入代码这代码我是从网上看哔哩哔哩写的 如果，有兴趣可以直接哔哩哔哩 java微信公众号就能收到了，首先创建一个servlet，如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package WeiXinServlet;import java.io.IOException;import java.io.PrintWriter;import java.util.Map;import javax.servlet.ServletException;import javax.servlet.ServletInputStream;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import Service.WxService;/** * Servlet implementation class wxServlet */@WebServlet("/wxServlet")public class wxServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public wxServlet() &#123; super(); // TODO Auto-generated constructor stub &#125; /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub System.out.print("--------------------------------------"); String signature = request.getParameter("signature"); String timestamp = request.getParameter("timestamp"); String nonce = request.getParameter("nonce"); String echostr = request.getParameter("echostr"); //较验证请求 if(WxService.check(timestamp,nonce,signature)) &#123; PrintWriter out = response.getWriter(); //原样返回echostr参数 out.println(echostr); out.flush(); out.close(); System.out.println("接入成功"); &#125;else &#123; System.out.println("接入失败"); &#125; &#125;&#125; 通过get方法来接收传来的参数，因为微信公众号开发需要通过这三个参数，通过SHA1加密认证. 再写个service来做SHA1加密认证123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String APPID = "wxf2a10b83349c22a3"; //这个为你在配置页得到的自己的APPID private static final String APPSECRET = "749b5f9f551d30723a7d20646749cddb"; //这个为你在配置页得到的自己的APPSECRE private static final String TOKEN = "abc"; //这个为你在配置页提阿涅的TOKEN&#125;/** * * 验证签名 */ public static boolean check(String timestamp,String nonce , String signature) &#123; //1. 将token、timestamp、nonce三个蚕食进行字典序排序 String[] strs = new String[] &#123;TOKEN,timestamp,nonce&#125;; Arrays.sort(strs); //2. 将三个参数字符串拼接成一个字符串进行sha1加密 String str = strs[0]+strs[1]+strs[2]; String mysia = sha1(str); System.out.println("到达check方法中！"); System.out.println(mysia); System.out.println(signature); //3. 开发者获得加密后的字符串与signature对比，标识该请求来源于微信 return mysia.equalsIgnoreCase(signature); &#125; private static String sha1(String src) &#123; try &#123; //获取加密对象 MessageDigest md = MessageDigest.getInstance("sha1"); //加密 byte[] digest = md.digest(src.getBytes()); char[] chars = &#123;'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'&#125;; StringBuilder sb = new StringBuilder(); //处理加密结果 for(byte b:digest) &#123; sb.append(chars[(b&gt;&gt;4)&amp;15]); sb.append(chars[b&amp;15]); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception System.out.println("error:"+e.getMessage()); &#125; return null; &#125; /** * 获取signature * 特别注意的是调用微信js，url必须是当前页面(转发的不行) * @throws Exception */ public static String getSignature(String url) throws Exception&#123;// 第三步:对密钥进行sha1加密 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); String ticket = getJsApiTicket(); long time = System.currentTimeMillis()/1000; String randomStr = "1485965214789631"; String str = "jsapi_ticket=" + ticket + "&amp;noncestr=" + randomStr+ "&amp;timestamp=" + time + "&amp;url="+url; String signature = ""; try &#123; MessageDigest crypt = MessageDigest.getInstance("SHA-1"); crypt.reset(); crypt.update(str.getBytes("UTF-8")); //对string1 字符串进行SHA-1加密处理 signature = byteToHex(crypt.digest()); //对加密后字符串转成16进制// signature = sha1(str); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new Exception("signature生成失败!"); &#125; map.put("timeStamp", String.valueOf(time)); map.put("randomStr", randomStr); map.put("signature", signature); System.out.println("ticket:"+ticket+",result:"+com.alibaba.fastjson.JSONObject.toJSONString(map)); return com.alibaba.fastjson.JSON.toJSONString(map); &#125; private static String byteToHex(final byte[] hash) &#123; Formatter formatter = new Formatter(); for (byte b : hash) &#123; formatter.format("%02x", b); &#125; String result = formatter.toString(); formatter.close(); return result; &#125; 然后再接口配置信息填写ngrok改的URL 再点击确认 就可以了，这期间需要点时间等候 用java写获取token的方法因为微信公众号大部分功能需要获取token才能搞的，所以这里写下方法 创建个AccessToken的实体类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package org.whale.weixin.entity;/** * 保存Token（只有俩个小时的时限） * * */public class AccessToken &#123; private String accessToken; //计算过期时间 private long expireTime; public String getAccessToken() &#123; return accessToken; &#125; public void setAccessToken(String accessToken) &#123; this.accessToken = accessToken; &#125; public long getExpireTime() &#123; return expireTime; &#125; public void setExpireTime(long expireTime) &#123; this.expireTime = expireTime; &#125; public AccessToken(String accessToken, String expireIn) &#123; super(); this.accessToken = accessToken; this.expireTime = System.currentTimeMillis()+Integer.parseInt(expireIn)*1000; &#125; /** * 判断token是否过期 * @return */ public boolean isExpired() &#123; return System.currentTimeMillis()&gt;expireTime; &#125; &#125; 创建个工具类来发get与post 请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package org.whale.weixin.util;import java.io.InputStream;import java.io.OutputStream;import java.net.URL;import java.net.URLConnection;public class Util &#123; // 用于存储token /** * 向指定的地址发送get请求 用于获取微信Token * * @param url * @return */ public static String get(String url) &#123; try &#123; URL urlObj = new URL(url); // 开链接 URLConnection connection = urlObj.openConnection(); InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125; /** * 向指定地址发送一个post请求，待着data数据 * * @param url * @param data * @return */ public static String post(String url, String data) &#123; try &#123; URL urlObject = new URL(url); URLConnection connection = urlObject.openConnection(); // 要发鸿数据出去，必须要发送可发送数据状态 connection.setDoOutput(true); // 获取输出流 OutputStream os = connection.getOutputStream(); // 写出数据 os.write(data.getBytes()); os.close(); // 获取输入流 InputStream is = connection.getInputStream(); byte[] b = new byte[1024]; int len; StringBuilder sb = new StringBuilder(); while ((len = is.read(b)) != -1) &#123; sb.append(new String(b, 0, len)); &#125; return sb.toString(); &#125; catch (Exception e) &#123; // TODO: handle exception &#125; return null; &#125;&#125; 在service中编写获取token的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package Service;import java.io.InputStream;import java.io.UnsupportedEncodingException;import java.security.MessageDigest;import java.util.regex.Pattern;import java.util.*;import org.dom4j.Element;import org.dom4j.io.SAXReader;import com.mysql.cj.Constants;import com.mysql.cj.util.StringUtils;import com.thoughtworks.xstream.XStream;import entity.AccessToken;import entity.Article;import entity.BaseMessage;import entity.ImageMessage;import entity.MusicMessage;import entity.NewsMessage;import entity.TextMessage;import entity.VideoMessage;import entity.VoiceMessage;import net.sf.json.JSON;import net.sf.json.JSONObject;import util.Utils;public class WxService &#123; private static final String GET_TOKENURL_URL = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET"; //用于存储token private static AccessToken at; /** * 获取token */ private static void getToken() &#123; String url = GET_TOKENURL_URL.replace("APPID", APPID).replace("APPSECRET", APPSECRET); String tokenStr = Utils.get(url);// System.out.println(tokenStr); JSONObject jsonObject = JSONObject.fromObject(tokenStr); String token = jsonObject.getString("access_token"); String expireIn = jsonObject.getString("expires_in"); //创建token对象，并存起来。 at = new AccessToken(token, expireIn); &#125; /** * 向外暴露的获取token的方法 * @return */ public static String getAccessToken() &#123; if(null==at||at.isExpired()) &#123; getToken(); &#125; return at.getAccessToken(); &#125;&#125; 以上便是简易的java来写微信后台的代码，由于大部分代码我是通过看别人视频获得的，所以也不详细写了，有兴趣的话可以去bilibli上搜索看看]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用springboot快速建立helloworld项目]]></title>
    <url>%2F2019%2F09%2F03%2F%E5%A6%82%E4%BD%95%E7%94%A8springboot%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8Bhelloworld%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[什么是springbootspringboot是一个spring微服务框架，具体是什么，大家可以去spring官网上进行了解如何快速的创建helloworld项目通过springboot快速构建网站创建maven项目进入springboot快速建立网站，Project选择Maven Project，SpringBoot版本选择2.1.7，我写这篇的时候，2.1.7为稳定版，请大家自行选择当前稳定版，如不知道可以去springboot指南中去看，看见红色GA结尾的就是稳定版，然后选择依赖，也就是Dependencies，这里我们只选择Web中的SpringWebStarter。 创建helloworld将刚刚创建出来的maven项目解压缩，并导入项目，修改主目录自动生成的Application.java中的代码如下 1234567891011121314@Controller@EnableAutoConfiguration@SpringBootApplicationpublic class TestApplication &#123; @RequestMapping("/") @ResponseBody String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) &#123; SpringApplication.run(TestApplication.class, args); &#125;&#125; 然后右键项目-&gt;Run as-&gt;Spring Boot App 进入localhost:8080下就能看到helloworld了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用maven快速建立个web工程]]></title>
    <url>%2F2019%2F08%2F30%2F%E5%A6%82%E4%BD%95%E7%94%A8maven%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%8B%E4%B8%AAweb%E5%B7%A5%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[最近闲来无事天天看视频，发现自己以前用maven建工程方式貌似有点瓜皮，所以写个文章在记录，也方便工作学习什么是maven工程maven是一个很方便构建项目的工具，有了它就可以不用到处找jar包了，而且现在越来越多的技术，貌似都是直接用maven导入的所以，我觉得还是需要搞的，而它中配置jar的地方主要是在pom.xml中写，而如果你想找要加什么东西进去，可以去maven市场中寻找。 如何配置maven环境maven是一个java搞的东西，所以你要配置java环境，不过我觉得这个东西大家估计都会就不说了，然后是配置maven的环境，感觉和配置java一样简单，所以也不说了 如何配置maven为阿里私服由于默认maven服务器下载起来很慢，所以一般国内我还是推荐修改为阿里的私服，这样会快点，修改文件为maven解压路径下conf目录下的setting文件，需要在mirrors节点加入 123456&lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;&lt;/mirror&gt; 如下图所示 如何在eclipse中配置maven环境点击window-&gt;preferences-&gt;maven这里需要修改的配置有两个地方，一个在Installations，一个在User Settings中， 如何用eclipse快速建立maven的web工程点击 File-&gt;New-&gt;Maven Project，然后弹出页面记得勾选Create a simple project 的选项，操作如下图然后点击finish，就创建好了项目，这时候你发现很坑爹怎么没有WEB-INF与META-INF目录，没事你只要右击项目选择properties-&gt;Project Facets，然后勾选掉Dynamic Web Module 点击Apply，再点击 Dynamic Web Module ，就出现了 Futher configuration available… 的字眼，点击它 然后点击OK，一个Maven项目的web目录就搭建好了]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First]]></title>
    <url>%2F2019%2F08%2F29%2FFirst%2F</url>
    <content type="text"><![CDATA[之前搞的博客，发现上传方式很难受，后来我又看了下炳强的博客后，又开始重新搞了个 欢迎大家去看他写的，很详细，基本上把next主题翻译了]]></content>
      <categories>
        <category>java</category>
        <category>github</category>
        <category>next</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>github</tag>
        <tag>next</tag>
      </tags>
  </entry>
</search>
