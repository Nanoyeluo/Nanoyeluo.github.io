<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叶落</title>
  
  <subtitle>论美貌你是赢不过我的</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-23T06:25:00.194Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nano</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stream</title>
    <link href="http://yoursite.com/2020/07/23/Stream/"/>
    <id>http://yoursite.com/2020/07/23/Stream/</id>
    <published>2020-07-23T02:36:48.000Z</published>
    <updated>2020-07-23T06:25:00.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><p><strong>Stream到底是什么呢？</strong></p><p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p><p>“集合讲的是数据，Stream讲的是计算！”</p><p><strong>注意：</strong></p><p>①Stream 自己不会存储元素。</p><p>②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 </p><p>③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><a id="more"></a><h3 id="Stream-的操作三个步骤"><a href="#Stream-的操作三个步骤" class="headerlink" title="Stream 的操作三个步骤"></a><strong>Stream</strong> 的操作三个步骤</h3><p><strong>1-</strong> <strong>创建</strong> <strong>Stream</strong></p><p>一个数据源（如：集合、数组），获取一个流</p><p> <strong>2-</strong> <strong>中间操作</strong></p><p>一个中间操作链，对数据源的数据进行处理</p><p> <strong>3-</strong> <strong>终止操作</strong>(<strong>终端操作</strong>)</p><p>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p><h4 id="创建-Stream的方法"><a href="#创建-Stream的方法" class="headerlink" title="创建 Stream的方法"></a>创建 Stream的方法</h4><ol><li><p>Collection 提供了两个方法  stream() 与 parallelStream()</p></li><li><p>通过 Arrays 中的 stream() 获取一个数组流</p></li><li><p>通过 Stream 类中静态方法 of()</p></li><li><p>创建无限流</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建 Stream</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//1. Collection 提供了两个方法  stream() 与 parallelStream()</span></span><br><span class="line">   List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">   Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2. 通过 Arrays 中的 stream() 获取一个数组流</span></span><br><span class="line">   Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">   Stream&lt;Integer&gt; stream1 = Arrays.stream(nums);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 通过 Stream 类中静态方法 of()</span></span><br><span class="line">   Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//4. 创建无限流</span></span><br><span class="line">   <span class="comment">//迭代</span></span><br><span class="line">   Stream&lt;Integer&gt; stream3 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>);</span><br><span class="line">   stream3.forEach(System.out::println);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//生成</span></span><br><span class="line">   Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">   stream4.forEach(System.out::println);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><h5 id="筛选与切片"><a href="#筛选与切片" class="headerlink" title="筛选与切片"></a>筛选与切片</h5><p>filter——接收 Lambda ， 从流中排除某些元素。<br>limit——截断流，使其元素不超过给定数量。<br>skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补<br>distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   emps.stream()</span><br><span class="line">      .filter((e) -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">"短路！"</span>); <span class="comment">// &amp;&amp;  ||</span></span><br><span class="line">         <span class="keyword">return</span> e.getSalary() &gt;= <span class="number">5000</span>;</span><br><span class="line">      &#125;).limit(<span class="number">3</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">   emps.parallelStream()</span><br><span class="line">      .filter((e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>)</span><br><span class="line">      .skip(<span class="number">2</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">   emps.stream()</span><br><span class="line">      .distinct()</span><br><span class="line">      .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。<br>flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Stream&lt;String&gt; str = emps.stream()</span><br><span class="line">      .map((e) -&gt; e.getName());</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   List&lt;String&gt; strList = Arrays.asList(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>, <span class="string">"ddd"</span>, <span class="string">"eee"</span>);</span><br><span class="line">   </span><br><span class="line">   Stream&lt;String&gt; stream = strList.stream()</span><br><span class="line">         .map(String::toUpperCase);</span><br><span class="line">   </span><br><span class="line">   stream.forEach(System.out::println);</span><br><span class="line">   </span><br><span class="line">   Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream()</span><br><span class="line">         .map(TestStreamAPI1::filterCharacter);</span><br><span class="line">   </span><br><span class="line">   stream2.forEach((sm) -&gt; &#123;</span><br><span class="line">      sm.forEach(System.out::println);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Stream&lt;Character&gt; stream3 = strList.stream()</span><br><span class="line">         .flatMap(TestStreamAPI1::filterCharacter);</span><br><span class="line">   </span><br><span class="line">   stream3.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">list.add(ch);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p>sorted()——自然排序<br>sorted(Comparator com)——定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      emps.stream()</span><br><span class="line">         .map(Employee::getName)</span><br><span class="line">         .sorted()</span><br><span class="line">         .forEach(System.out::println);</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">      </span><br><span class="line">      emps.stream()</span><br><span class="line">         .sorted((x, y) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(x.getAge() == y.getAge())&#123;</span><br><span class="line">               <span class="keyword">return</span> x.getName().compareTo(y.getName());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> Integer.compare(x.getAge(), y.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;).forEach(System.out::println);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="终止操作"><a href="#终止操作" class="headerlink" title="终止操作"></a>终止操作</h4><p>allMatch——检查是否匹配所有元素<br>anyMatch——检查是否至少匹配一个元素<br>noneMatch——检查是否没有匹配的元素<br>findFirst——返回第一个元素<br>findAny——返回当前流中的任意元素<br>count——返回流中元素的总个数<br>max——返回流中最大值<br>min——返回流中最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>, Status.VOCATION),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.BUSY),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line"><span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>, Status.BUSY)</span><br><span class="line">);</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> bl = emps.stream()</span><br><span class="line">         .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">      </span><br><span class="line">      System.out.println(bl);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">boolean</span> bl1 = emps.stream()</span><br><span class="line">         .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">      </span><br><span class="line">      System.out.println(bl1);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">boolean</span> bl2 = emps.stream()</span><br><span class="line">         .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">      </span><br><span class="line">      System.out.println(bl2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">      .sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))</span><br><span class="line">      .findFirst();</span><br><span class="line">   </span><br><span class="line">   System.out.println(op.get());</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Optional&lt;Employee&gt; op2 = emps.parallelStream()</span><br><span class="line">      .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">      .findAny();</span><br><span class="line">   </span><br><span class="line">   System.out.println(op2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> count = emps.stream()</span><br><span class="line">                .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">                .count();</span><br><span class="line">   </span><br><span class="line">   System.out.println(count);</span><br><span class="line">   </span><br><span class="line">   Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">      .map(Employee::getSalary)</span><br><span class="line">      .max(Double::compare);</span><br><span class="line">   </span><br><span class="line">   System.out.println(op.get());</span><br><span class="line">   </span><br><span class="line">   Optional&lt;Employee&gt; op2 = emps.stream()</span><br><span class="line">      .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">   </span><br><span class="line">   System.out.println(op2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h5><p>reduce(T identity, BinaryOperator) / reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">   </span><br><span class="line">   Integer sum = list.stream()</span><br><span class="line">      .reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">   </span><br><span class="line">   System.out.println(sum);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">      .map(Employee::getSalary)</span><br><span class="line">      .reduce(Double::sum);</span><br><span class="line">   </span><br><span class="line">   System.out.println(op.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h5><p>collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;String&gt; list = emps.stream()</span><br><span class="line">      .map(Employee::getName)</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">   </span><br><span class="line">   list.forEach(System.out::println);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Set&lt;String&gt; set = emps.stream()</span><br><span class="line">      .map(Employee::getName)</span><br><span class="line">      .collect(Collectors.toSet());</span><br><span class="line">   </span><br><span class="line">   set.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   HashSet&lt;String&gt; hs = emps.stream()</span><br><span class="line">      .map(Employee::getName)</span><br><span class="line">      .collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">   </span><br><span class="line">   hs.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">Optional&lt;Double&gt; max = emps.stream()</span><br><span class="line">.map(Employee::getSalary)</span><br><span class="line">.collect(Collectors.maxBy(Double::compare));</span><br><span class="line"></span><br><span class="line">System.out.println(max.get());</span><br><span class="line"></span><br><span class="line">Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">.collect(Collectors.minBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line"></span><br><span class="line">System.out.println(op.get());</span><br><span class="line"></span><br><span class="line">Double sum = emps.stream()</span><br><span class="line">.collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line">Double avg = emps.stream()</span><br><span class="line">.collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(avg);</span><br><span class="line"></span><br><span class="line">Long count = emps.stream()</span><br><span class="line">.collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line">System.out.println(count);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">DoubleSummaryStatistics dss = emps.stream()</span><br><span class="line">.collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line"></span><br><span class="line">System.out.println(dss.getMax());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是Stream&quot;&gt;&lt;a href=&quot;#什么是Stream&quot; class=&quot;headerlink&quot; title=&quot;什么是Stream&quot;&gt;&lt;/a&gt;什么是Stream&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Stream到底是什么呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。&lt;/p&gt;&lt;p&gt;“集合讲的是数据，Stream讲的是计算！”&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;①Stream 自己不会存储元素。&lt;/p&gt;&lt;p&gt;②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 &lt;/p&gt;&lt;p&gt;③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java8新特性" scheme="http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>方法引用与构造器引用</title>
    <link href="http://yoursite.com/2020/07/23/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%B8%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2020/07/23/方法引用与构造器引用/</id>
    <published>2020-07-23T01:33:26.000Z</published>
    <updated>2020-07-23T02:27:34.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法引用用法"><a href="#方法引用用法" class="headerlink" title="方法引用用法"></a>方法引用用法</h3><p>方法引用：若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式）</p><h3 id="主要的语法格式"><a href="#主要的语法格式" class="headerlink" title="主要的语法格式"></a>主要的语法格式</h3><ol><li><p>对象的引用 :: 实例方法名</p></li><li><p>类名 :: 静态方法名</p></li><li><p>类名 :: 实例方法名</p></li></ol><h4 id="对象-实例方法名"><a href="#对象-实例方法名" class="headerlink" title="对象::实例方法名"></a>对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   PrintStream ps = System.out;</span><br><span class="line">   Consumer&lt;String&gt; con = (str) -&gt; ps.println(str);</span><br><span class="line">   con.accept(<span class="string">"Hello World！"</span>);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">   con2.accept(<span class="string">"Hello Java8！"</span>);</span><br><span class="line">   </span><br><span class="line">   Consumer&lt;String&gt; con3 = System.out::println;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名 :: 静态方法名"></a>类名 :: 静态方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名 :: 实例方法名"></a>类名 :: 实例方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">   BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">   System.out.println(bp.test(<span class="string">"abcde"</span>, <span class="string">"abcde"</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class="line">   System.out.println(bp2.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();</span><br><span class="line">   System.out.println(fun.apply(<span class="keyword">new</span> Employee()));</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Function&lt;Employee, String&gt; fun2 = Employee::show;</span><br><span class="line">   System.out.println(fun2.apply(<span class="keyword">new</span> Employee()));</span><br></pre></td></tr></table></figure><h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>构造器引用 :构造器的参数列表，需要与函数式接口中参数列表保持一致！</p><h4 id="类名-new"><a href="#类名-new" class="headerlink" title="类名 :: new"></a>类名 :: new</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Function&lt;String, Employee&gt; fun = Employee::<span class="keyword">new</span>;</span><br><span class="line">   </span><br><span class="line">   BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Supplier&lt;Employee&gt; sup = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">   System.out.println(sup.get());</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">   System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组引用"><a href="#数组引用" class="headerlink" title="数组引用"></a>数组引用</h4><h4 id="类型-new"><a href="#类型-new" class="headerlink" title="类型[] :: new"></a>类型[] :: new</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Function&lt;Integer, String[]&gt; fun = (args) -&gt; <span class="keyword">new</span> String[args];</span><br><span class="line">   String[] strs = fun.apply(<span class="number">10</span>);</span><br><span class="line">   System.out.println(strs.length);</span><br><span class="line">   </span><br><span class="line">   System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line">   </span><br><span class="line">   Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: <span class="keyword">new</span>;</span><br><span class="line">   Employee[] emps = fun2.apply(<span class="number">20</span>);</span><br><span class="line">   System.out.println(emps.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方法引用用法&quot;&gt;&lt;a href=&quot;#方法引用用法&quot; class=&quot;headerlink&quot; title=&quot;方法引用用法&quot;&gt;&lt;/a&gt;方法引用用法&lt;/h3&gt;&lt;p&gt;方法引用：若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式）&lt;/p&gt;&lt;h3 id=&quot;主要的语法格式&quot;&gt;&lt;a href=&quot;#主要的语法格式&quot; class=&quot;headerlink&quot; title=&quot;主要的语法格式&quot;&gt;&lt;/a&gt;主要的语法格式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对象的引用 :: 实例方法名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类名 :: 静态方法名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类名 :: 实例方法名&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;对象-实例方法名&quot;&gt;&lt;a href=&quot;#对象-实例方法名&quot; class=&quot;headerlink&quot; title=&quot;对象::实例方法名&quot;&gt;&lt;/a&gt;对象::实例方法名&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   PrintStream ps = System.out;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Consumer&amp;lt;String&amp;gt; con = (str) -&amp;gt; ps.println(str);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   con.accept(&lt;span class=&quot;string&quot;&gt;&quot;Hello World！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;--------------------------------&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Consumer&amp;lt;String&amp;gt; con2 = ps::println;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   con2.accept(&lt;span class=&quot;string&quot;&gt;&quot;Hello Java8！&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   Consumer&amp;lt;String&amp;gt; con3 = System.out::println;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java8新特性" scheme="http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="http://yoursite.com/2020/07/22/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/07/22/注解/</id>
    <published>2020-07-22T06:27:45.000Z</published>
    <updated>2020-07-22T06:47:29.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注解-Annotation-概述"><a href="#注解-Annotation-概述" class="headerlink" title="注解 (Annotation) 概述"></a><strong>注解</strong> <strong>(Annotation)</strong> 概述</h2><p>从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) </p><p>Annotation 其实就是代码里的<strong>特殊标记</strong>, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</p><a id="more"></a><p>Annotation 可以像修饰符一样被使用, 可用于修饰包,类,构造器,方法,成员变量, 参数,局部变量的声明, 这些信息被保存在 Annotation 的 “name=value” 对中</p><h3 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a><strong>自定义</strong> Annotation</h3><p> 定义新的 Annotation 类型使用 <strong>@interface</strong> 关键字</p><p>自定义注解自动继承了<strong>java.lang.annotation.Annotation接口</strong></p><p>Annotation 的成员变量在 Annotation 定义中以无参数方法的形式来声明。其</p><p>方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能</p><p>是八种基本数据类型、<strong>String</strong>类型、<strong>Class</strong>类型、<strong>enum</strong>类型、<strong>Annotation</strong>类型以上所有类型的数组。 </p><p> 可以在定义 Annotation 的成员变量时为其指定初始值, 指定成员变量的初始</p><p>值可使用 <strong>default</strong> <strong>关键字</strong></p><p>如果只有一个参数成员，建议使用<strong>参数名为</strong>value</p><p>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认</p><p>值。格式是“参数名 = 参数值”，如果只有一个参数成员，且名称为value，</p><p>可以省略“value=” </p><p>没有成员定义的 Annotation 称为<strong>标记</strong>; 包含成员变量的 Annotation 称为元数</p><p>据 Annotation</p><p>注意：自定义注解必须配上注解的信息处理流程才有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable</span>(MyAnnotations.class)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//jdk 8之前的写法：</span></span><br><span class="line"><span class="comment">//@MyAnnotations(&#123;@MyAnnotation(value="hi"),@MyAnnotation(value="hi")&#125;)</span></span><br><span class="line"><span class="meta">@MyAnnotation</span>(value=<span class="string">"hi"</span>)</span><br><span class="line"><span class="meta">@MyAnnotation</span>(value=<span class="string">"abc"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人走路"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"人吃饭"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK中的元注解"><a href="#JDK中的元注解" class="headerlink" title="JDK中的元注解"></a>JDK中的元注解</h3><h4 id="JDK-的元-Annotation-用于修饰其他-Annotation-定义"><a href="#JDK-的元-Annotation-用于修饰其他-Annotation-定义" class="headerlink" title="JDK 的元 Annotation 用于修饰其他 Annotation 定义"></a>JDK 的元 Annotation 用于修饰其他 Annotation 定义</h4><h4 id="JDK5-0提供了4个标准的meta-annotation类型，分别是："><a href="#JDK5-0提供了4个标准的meta-annotation类型，分别是：" class="headerlink" title="JDK5.0提供了4个标准的meta-annotation类型，分别是："></a>JDK5.0提供了4个标准的meta-annotation类型，分别是：</h4><p><strong>Retention</strong></p><p><strong>Target</strong></p><p><strong>Documented</strong></p><p><strong>Inherited</strong></p><h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention:"></a>@Retention:</h4><p>只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命</p><p>周期, @Rentention 包含一个 <strong>RetentionPolicy</strong> 类型的成员变量, 使用</p><p>@Rentention 时必须为该 value 成员变量指定值: </p><p><strong>RetentionPolicy.SOURCE:</strong>在源文件中有效（即源文件保留），编译器直接丢弃这种策略的</p><p>注释</p><p><strong>RetentionPolicy.CLASS</strong>:在class文件中有效（即class保留） ， 当运行 Java 程序时, JVM </p><p>不会保留注解。 这是默认值</p><p><strong>RetentionPolicy.RUNTIME:</strong>在运行时有效（即运行时保留），<strong>当运行</strong> <strong>Java</strong> <strong>程序时</strong>, JVM <strong>会</strong></p><p><strong>保留注释。程序可以通过反射获取该注释。</strong></p><h4 id="Target"><a href="#Target" class="headerlink" title="@Target:"></a><strong>@Target</strong>:</h4><p>用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰哪些程序元素。 @Target 也包含一个名为 value 的成员变量。</p><h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented:"></a>@Documented:</h4><p>用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。 </p><p>定义为Documented的注解必须设置Retention值为RUNTIME。 </p><h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited:"></a>@Inherited:</h4><p>被它修饰的 Annotation 将具有<strong>继承性</strong>。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p><p>比如：如果把标有@Inherited注解的自定义的注解标注在类级别上，子类则可以</p><p>继承父类类级别的注解</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注解-Annotation-概述&quot;&gt;&lt;a href=&quot;#注解-Annotation-概述&quot; class=&quot;headerlink&quot; title=&quot;注解 (Annotation) 概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;注解&lt;/strong&gt; &lt;strong&gt;(Annotation)&lt;/strong&gt; 概述&lt;/h2&gt;&lt;p&gt;从 JDK 5.0 开始, Java 增加了对元数据(MetaData) 的支持, 也就是Annotation(注解) &lt;/p&gt;&lt;p&gt;Annotation 其实就是代码里的&lt;strong&gt;特殊标记&lt;/strong&gt;, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举</title>
    <link href="http://yoursite.com/2020/07/22/%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/2020/07/22/枚举/</id>
    <published>2020-07-22T02:03:31.000Z</published>
    <updated>2020-07-22T05:52:55.551Z</updated>
    
    <content type="html"><![CDATA[<h6 id="当需要定义一组常量时，强烈建议使用枚举类"><a href="#当需要定义一组常量时，强烈建议使用枚举类" class="headerlink" title="当需要定义一组常量时，强烈建议使用枚举类"></a>当需要定义一组常量时，强烈建议使用枚举类</h6><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类</p><p>枚举类的构造器只能使用 private 权限修饰符枚举类的所有实例必须在枚举类中显式列出(<strong>,</strong> 分隔</p><p>;结尾)。列出的实例系统会自动添加 public static final 修饰</p><a id="more"></a><p>必须在枚举类的第一行声明枚举类对象</p><p>JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定。</p><h3 id="Enum类的主要方法："><a href="#Enum类的主要方法：" class="headerlink" title="Enum类的主要方法："></a>Enum类的主要方法：</h3><h4 id="values-方法："><a href="#values-方法：" class="headerlink" title="values()方法："></a>values()方法：</h4><p>返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p><h4 id="valueOf-String-str-："><a href="#valueOf-String-str-：" class="headerlink" title="valueOf(String str)："></a>valueOf(String str)：</h4><p>可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。 </p><h4 id="toString-："><a href="#toString-：" class="headerlink" title="toString()："></a>toString()：</h4><p>返回当前枚举类对象常量的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> Season1 implements Info&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用","隔开，末尾对象";"结束</span></span><br><span class="line">    SPRING(<span class="string">"春天"</span>,<span class="string">"春暖花开"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"春天在哪里？"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">"夏天"</span>,<span class="string">"夏日炎炎"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"宁夏"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">"秋天"</span>,<span class="string">"秋高气爽"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"秋天不回来"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">"冬天"</span>,<span class="string">"冰天雪地"</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"大约在冬季"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season1</span><span class="params">(String seasonName,String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //4.其他诉求1：提供toString()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return "Season1&#123;" +</span></span><br><span class="line"><span class="comment">//                "seasonName='" + seasonName + '\'' +</span></span><br><span class="line"><span class="comment">//                ", seasonDesc='" + seasonDesc + '\'' +</span></span><br><span class="line"><span class="comment">//                '&#125;';</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public void show() &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println("这是一个季节");</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;当需要定义一组常量时，强烈建议使用枚举类&quot;&gt;&lt;a href=&quot;#当需要定义一组常量时，强烈建议使用枚举类&quot; class=&quot;headerlink&quot; title=&quot;当需要定义一组常量时，强烈建议使用枚举类&quot;&gt;&lt;/a&gt;当需要定义一组常量时，强烈建议使用枚举类&lt;/h6&gt;&lt;h3 id=&quot;使用说明&quot;&gt;&lt;a href=&quot;#使用说明&quot; class=&quot;headerlink&quot; title=&quot;使用说明&quot;&gt;&lt;/a&gt;使用说明&lt;/h3&gt;&lt;p&gt;使用 enum 定义的枚举类默认继承了 java.lang.Enum类，因此不能再继承其他类&lt;/p&gt;&lt;p&gt;枚举类的构造器只能使用 private 权限修饰符枚举类的所有实例必须在枚举类中显式列出(&lt;strong&gt;,&lt;/strong&gt; 分隔&lt;/p&gt;&lt;p&gt;;结尾)。列出的实例系统会自动添加 public static final 修饰&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>泛型</title>
    <link href="http://yoursite.com/2020/07/21/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/21/泛型/</id>
    <published>2020-07-21T08:08:44.000Z</published>
    <updated>2020-07-22T02:36:49.024Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h2><p>​     所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类</p><p>型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，</p><p>继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实</p><p>际的类型参数，也称为类型实参）。 </p><p>​     从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，</p><a id="more"></a><p>允许我们在创建集合时再指定集合元素的类型，正如：List<string>，这表明</string></p><p>该List只能保存字符串类型的对象。 </p><p>​    JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，</p><p>从而可以在声明集合变量、创建集合对象时传入类型实参。</p><h3 id="在集合中使用泛型"><a href="#在集合中使用泛型" class="headerlink" title="在集合中使用泛型"></a>在集合中使用泛型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="number">78</span>);</span><br><span class="line">        list.add(<span class="number">87</span>);</span><br><span class="line">        list.add(<span class="number">99</span>);</span><br><span class="line">        list.add(<span class="number">65</span>);</span><br><span class="line">        <span class="comment">//编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line"><span class="comment">//        list.add("Tom");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        for(Integer score : list)&#123;</span></span><br><span class="line"><span class="comment">//            //避免了强转操作</span></span><br><span class="line"><span class="comment">//            int stuScore = score;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            System.out.println(stuScore);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> stuScore = iterator.next();</span><br><span class="line">            System.out.println(stuScore);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Java泛型中的标记符含义："><a href="#Java泛型中的标记符含义：" class="headerlink" title="Java泛型中的标记符含义："></a>Java泛型中的标记符含义：</h3><p> <strong>E</strong> - Element (在集合中使用，因为集合中存放的是元素)</p><p> <strong>T</strong> - Type（Java 类）</p><p> <strong>K</strong> - Key（键）</p><p> <strong>V</strong> - Value（值）</p><p> <strong>N</strong> - Number（数值类型）</p><p><strong>？</strong> - 表示不确定的java类型</p><h3 id="Java继承父类泛型的情况："><a href="#Java继承父类泛型的情况：" class="headerlink" title="Java继承父类泛型的情况："></a>Java继承父类泛型的情况：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Father&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 子类不保留父类的泛型</span><br><span class="line">// 1)没有类型 擦除</span><br><span class="line">class Son1 extends Father &#123;</span><br><span class="line">// 等价于class Son extends Father&lt;Object,Object&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line">// 2)具体类型</span><br><span class="line">class Son2 extends Father&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 子类保留父类的泛型</span><br><span class="line">// 1)全部保留</span><br><span class="line">class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; </span><br><span class="line">&#125;</span><br><span class="line">// 2)部分保留</span><br><span class="line">class Son4&lt;T2&gt;** extends Father&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">class Father&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 子类不保留父类的泛型</span><br><span class="line">// 1)没有类型 擦除</span><br><span class="line">class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line">// 2)具体类型</span><br><span class="line">class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 子类保留父类的泛型</span><br><span class="line">// 1)全部保留</span><br><span class="line">class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">// 2)部分保留</span><br><span class="line">class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</span></span><br><span class="line"><span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line"><span class="comment">//泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt;  <span class="function">List&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(E e : arr)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line"><span class="comment">//        print(list1);</span></span><br><span class="line"><span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">"AA"</span>);</span><br><span class="line">        list3.add(<span class="string">"BB"</span>);</span><br><span class="line">        list3.add(<span class="string">"CC"</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">        <span class="comment">//除了添加null之外。</span></span><br><span class="line"><span class="comment">//        list.add("DD");</span></span><br><span class="line"><span class="comment">//        list.add('?');</span></span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">        Object o = list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="有限制的通配符"><a href="#有限制的通配符" class="headerlink" title="有限制的通配符"></a>有限制的通配符</h3><h5 id="lt-extends-Number-gt-无穷小-Number"><a href="#lt-extends-Number-gt-无穷小-Number" class="headerlink" title="&lt;? extends Number&gt; (无穷小, Number]"></a>&lt;? extends Number&gt; (无穷小, Number]</h5><p>只允许泛型为Number及Number子类的引用调用</p><h5 id="lt-super-Number-gt-Number-无穷大"><a href="#lt-super-Number-gt-Number-无穷大" class="headerlink" title="&lt;? super Number&gt; [Number , 无穷大)"></a><strong>&lt;? super Number&gt; [Number ,</strong> 无穷大)</h5><p>只允许泛型为Number及Number父类的引用调用</p><h5 id="lt-extends-Comparable-gt"><a href="#lt-extends-Comparable-gt" class="headerlink" title="&lt;? extends Comparable&gt;"></a>&lt;? extends Comparable&gt;</h5><p>只允许泛型为实现Comparable接口的实现类的引用调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Student&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">        List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">        List&lt;Object&gt; list5 = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list1 = list4;</span><br><span class="line"><span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        list2 = list3;</span></span><br><span class="line">        list2 = list4;</span><br><span class="line">        list2 = list5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据：</span></span><br><span class="line">        list1 = list3;</span><br><span class="line">        Person p = list1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">        list2 = list4;</span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">////编译不通过</span></span><br><span class="line"><span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据：</span></span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//编译通过</span></span><br><span class="line">        list2.add(<span class="keyword">new</span> Person());</span><br><span class="line">        list2.add(<span class="keyword">new</span> Student());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型的概念&quot;&gt;&lt;a href=&quot;#泛型的概念&quot; class=&quot;headerlink&quot; title=&quot;泛型的概念&quot;&gt;&lt;/a&gt;泛型的概念&lt;/h2&gt;&lt;p&gt;​     所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类&lt;/p&gt;&lt;p&gt;型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，&lt;/p&gt;&lt;p&gt;继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实&lt;/p&gt;&lt;p&gt;际的类型参数，也称为类型实参）。 &lt;/p&gt;&lt;p&gt;​     从JDK1.5以后，Java引入了“参数化类型（Parameterized type）”的概念，&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux常用快捷键</title>
    <link href="http://yoursite.com/2020/07/21/Linux%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/21/Linux常用快捷键/</id>
    <published>2020-07-21T05:55:31.000Z</published>
    <updated>2020-07-22T02:21:16.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux常用快捷键"><a href="#Linux常用快捷键" class="headerlink" title="Linux常用快捷键"></a>Linux常用快捷键</h2><h4 id="查看内存使用情况-top-和-free"><a href="#查看内存使用情况-top-和-free" class="headerlink" title="查看内存使用情况: top 和 free"></a>查看内存使用情况: top 和 free</h4><p><code>top</code>:命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.</p><p><code>free</code>:命令用来显示内存的使用情况</p><h2 id="Vim常用快捷键"><a href="#Vim常用快捷键" class="headerlink" title="Vim常用快捷键"></a>Vim常用快捷键</h2><h4 id="快速查询"><a href="#快速查询" class="headerlink" title="快速查询: /"></a>快速查询: /</h4><p>在normal模式下按下<code>/</code>即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下<code>n</code>查找下一个，按下<code>N</code>查找上一个。</p><a id="more"></a><h4 id="快速到达顶部和底部"><a href="#快速到达顶部和底部" class="headerlink" title="快速到达顶部和底部: /"></a>快速到达顶部和底部: /</h4><p>在normal模式下按下<code>G</code>即可到达底部，双击两下<code>g</code>即可到达顶部。</p><h1 id="未完待续。。。-不定期更新"><a href="#未完待续。。。-不定期更新" class="headerlink" title="未完待续。。。 不定期更新"></a>未完待续。。。 不定期更新</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux常用快捷键&quot;&gt;&lt;a href=&quot;#Linux常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Linux常用快捷键&quot;&gt;&lt;/a&gt;Linux常用快捷键&lt;/h2&gt;&lt;h4 id=&quot;查看内存使用情况-top-和-free&quot;&gt;&lt;a href=&quot;#查看内存使用情况-top-和-free&quot; class=&quot;headerlink&quot; title=&quot;查看内存使用情况: top 和 free&quot;&gt;&lt;/a&gt;查看内存使用情况: top 和 free&lt;/h4&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt;:命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.&lt;/p&gt;&lt;p&gt;&lt;code&gt;free&lt;/code&gt;:命令用来显示内存的使用情况&lt;/p&gt;&lt;h2 id=&quot;Vim常用快捷键&quot;&gt;&lt;a href=&quot;#Vim常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;Vim常用快捷键&quot;&gt;&lt;/a&gt;Vim常用快捷键&lt;/h2&gt;&lt;h4 id=&quot;快速查询&quot;&gt;&lt;a href=&quot;#快速查询&quot; class=&quot;headerlink&quot; title=&quot;快速查询: /&quot;&gt;&lt;/a&gt;快速查询: /&lt;/h4&gt;&lt;p&gt;在normal模式下按下&lt;code&gt;/&lt;/code&gt;即可进入查找模式，输入要查找的字符串并按下回车。 Vim会跳转到第一个匹配。按下&lt;code&gt;n&lt;/code&gt;查找下一个，按下&lt;code&gt;N&lt;/code&gt;查找上一个。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>IDEA常用快捷键</title>
    <link href="http://yoursite.com/2020/07/21/IDEA%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/21/IDEA常用快捷键/</id>
    <published>2020-07-21T04:29:03.000Z</published>
    <updated>2020-07-22T06:15:32.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h2><h4 id="打开的文件和工具窗口之间切换-Ctrl-Tab"><a href="#打开的文件和工具窗口之间切换-Ctrl-Tab" class="headerlink" title="打开的文件和工具窗口之间切换:Ctrl + Tab"></a>打开的文件和工具窗口之间切换:Ctrl + Tab</h4><p>要在打开的文件和工具窗口之间切换，请使用切换器Ctrl + Tab。 要进行导航，请按住Ctrl键（Windows和Linux）或Command键（macOS）并使用向上和向下箭头键或Tab和Shift + Tab和Alt。<br>按Delete或BackSpace关闭编辑器选项卡或隐藏工具窗口。</p><a id="more"></a><h4 id="快速包装代码块-Ctrl-Alt-T"><a href="#快速包装代码块-Ctrl-Alt-T" class="headerlink" title="快速包装代码块: Ctrl+Alt+T"></a>快速包装代码块: Ctrl+Alt+T</h4><p>要在结构中快速包装代码块，请在编辑器中将其选中，然后按Ctrl + Alt + T（“代码” |“环绕”）。<br>可用选项（“包装器”）的列表是上下文相关的，并且取决于语言。 例如，您可以用标签将html块包围，依此类推。</p><h4 id="使用UML类图探索包的结构-Ctrl-Alt-Shift-U"><a href="#使用UML类图探索包的结构-Ctrl-Alt-Shift-U" class="headerlink" title="使用UML类图探索包的结构: Ctrl + Alt + Shift + U"></a>使用UML类图探索包的结构: Ctrl + Alt + Shift + U</h4><p>使用UML类图探索包的结构，查看其组成类，子包和依赖项。 在“项目”视图中右键单击一个包，然后从上下文菜单中选择“显示类图”，或按Ctrl + Alt + Shift + U。<br>您还可以使用“类”图创建可视模型，并用节点元素和成员填充该模型，并绘制链接。 IntelliJ IDEA将生成源代码，并使其始终与模型保持同步。</p><h4 id="使用UML类图探索包的结构-Ctrl-Alt-Shift-U-1"><a href="#使用UML类图探索包的结构-Ctrl-Alt-Shift-U-1" class="headerlink" title="使用UML类图探索包的结构: Ctrl + Alt + Shift + U"></a>使用UML类图探索包的结构: Ctrl + Alt + Shift + U</h4><p>使用UML类图探索包的结构，查看其组成类，子包和依赖项。 在“项目”视图中右键单击一个包，然后从上下文菜单中选择“显示类图”，或按Ctrl + Alt + Shift + U。<br>您还可以使用“类”图创建可视模型，并用节点元素和成员填充该模型，并绘制链接。 IntelliJ IDEA将生成源代码，并使其始终与模型保持同步。</p><h4 id="查看快捷键-Ctrl-Shift-A"><a href="#查看快捷键-Ctrl-Shift-A" class="headerlink" title="查看快捷键: Ctrl + Shift + A"></a>查看快捷键: Ctrl + Shift + A</h4><p>如果您不记得如何调用动作，请按Ctrl + Shift + A并开始输入动作名称。</p><h4 id="跳转至下个TODO-Ctrl-ALT-向下箭头"><a href="#跳转至下个TODO-Ctrl-ALT-向下箭头" class="headerlink" title="跳转至下个TODO: Ctrl + ALT+向下箭头"></a>跳转至下个TODO: Ctrl + ALT+向下箭头</h4><p>跳转至下一个TODO</p><h4 id="快速找到所有在符号处引用该符号的代码-Alt-F7"><a href="#快速找到所有在符号处引用该符号的代码-Alt-F7" class="headerlink" title="快速找到所有在符号处引用该符号的代码: Alt + F7"></a>快速找到所有在符号处引用该符号的代码: Alt + F7</h4><p> 按Alt + F7键可以快速找到所有在符号处引用该符号的代码，无论该符号是类，方法，字段，参数还是其他语句的一部分。</p><h4 id="折叠所有代码-crtl-shift-减号"><a href="#折叠所有代码-crtl-shift-减号" class="headerlink" title="折叠所有代码: crtl + shift+ 减号"></a>折叠所有代码: crtl + shift+ 减号</h4><p> 将所有代码折叠</p><h4 id="折叠选中代码-crtl-减号"><a href="#折叠选中代码-crtl-减号" class="headerlink" title="折叠选中代码: crtl + 减号"></a>折叠选中代码: crtl + 减号</h4><p> 将选中代码折叠</p><h4 id="展开所有代码-crtl-shift-加号"><a href="#展开所有代码-crtl-shift-加号" class="headerlink" title="展开所有代码: crtl + shift+ 加号"></a>展开所有代码: crtl + shift+ 加号</h4><p> 将所有代码展开</p><h4 id="展开选中代码-crtl-加号"><a href="#展开选中代码-crtl-加号" class="headerlink" title="展开选中代码: crtl + 加号"></a>展开选中代码: crtl + 加号</h4><p> 将选中代码展开</p><h4 id="运行-shift-F10"><a href="#运行-shift-F10" class="headerlink" title="运行: shift+ F10"></a>运行: shift+ F10</h4><p> 运行当前的程序</p><h4 id="当前文件查找-ctrl-F"><a href="#当前文件查找-ctrl-F" class="headerlink" title="当前文件查找: ctrl+ F"></a>当前文件查找: ctrl+ F</h4><p>在当前文件查找</p><h4 id="当前文件替换-ctrl-R"><a href="#当前文件替换-ctrl-R" class="headerlink" title="当前文件替换: ctrl+ R"></a>当前文件替换: ctrl+ R</h4><p>在当前文件替换</p><h4 id="当前窗口全屏与原先大小切换-ctrl-shift-F12"><a href="#当前窗口全屏与原先大小切换-ctrl-shift-F12" class="headerlink" title="当前窗口全屏与原先大小切换: ctrl+ shift+F12"></a>当前窗口全屏与原先大小切换: ctrl+ shift+F12</h4><p>使当前窗口全屏和缩小</p><h4 id="使用快捷键查找错误和警告-F2"><a href="#使用快捷键查找错误和警告-F2" class="headerlink" title="使用快捷键查找错误和警告: F2"></a>使用快捷键查找错误和警告: F2</h4><p>我们可以用<code>F2/Shift+F2</code>来快速定位错误和警告，这在几百行代码中定位错误是非常方便的。</p><h1 id="未完待续。。。-不定期更新"><a href="#未完待续。。。-不定期更新" class="headerlink" title="未完待续。。。 不定期更新"></a>未完待续。。。 不定期更新</h1>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;IDEA常用快捷键&quot;&gt;&lt;a href=&quot;#IDEA常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;IDEA常用快捷键&quot;&gt;&lt;/a&gt;IDEA常用快捷键&lt;/h2&gt;&lt;h4 id=&quot;打开的文件和工具窗口之间切换-Ctrl-Tab&quot;&gt;&lt;a href=&quot;#打开的文件和工具窗口之间切换-Ctrl-Tab&quot; class=&quot;headerlink&quot; title=&quot;打开的文件和工具窗口之间切换:Ctrl + Tab&quot;&gt;&lt;/a&gt;打开的文件和工具窗口之间切换:Ctrl + Tab&lt;/h4&gt;&lt;p&gt;要在打开的文件和工具窗口之间切换，请使用切换器Ctrl + Tab。 要进行导航，请按住Ctrl键（Windows和Linux）或Command键（macOS）并使用向上和向下箭头键或Tab和Shift + Tab和Alt。&lt;br&gt;按Delete或BackSpace关闭编辑器选项卡或隐藏工具窗口。&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>lambda表达式</title>
    <link href="http://yoursite.com/2020/07/21/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/21/lambda表达式/</id>
    <published>2020-07-21T02:33:59.000Z</published>
    <updated>2020-07-22T02:21:12.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambal-表达式用法"><a href="#Lambal-表达式用法" class="headerlink" title="Lambal 表达式用法"></a>Lambal 表达式用法</h2><h3 id="一、Lambda-表达式的基础语法："><a href="#一、Lambda-表达式的基础语法：" class="headerlink" title="一、Lambda 表达式的基础语法："></a>一、Lambda 表达式的基础语法：</h3><p>Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符</p><p>箭头操作符将 Lambda 表达式拆分成两部分：</p><p>左侧：Lambda 表达式的参数列表</p><p>右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体</p><a id="more"></a><p>语法格式一：无参数，无返回值</p><p>() -&gt; System.out.println(“Hello Lambda!”);</p><p>语法格式二：有一个参数，并且无返回值</p><p>(x) -&gt; System.out.println(x)</p><p>语法格式三：若只有一个参数，小括号可以省略不写</p><p>x -&gt; System.out.println(x)</p><p>语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句</p><p>Comparator<integer> com = (x, y) -&gt; {</integer></p><p>System.out.println(“函数式接口”);</p><p>return Integer.compare(x, y);</p><p>};</p><p>语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写</p><p>Comparator<integer> com = (x, y) -&gt; Integer.compare(x, y);</integer></p><p>语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</p><p>(Integer x, Integer y) -&gt; Integer.compare(x, y);</p><p>上联：左右遇一括号省</p><p>下联：左侧推断类型省</p><p>横批：能省则省</p><h3 id="二、Lambda-表达式需要“函数式接口”的支持"><a href="#二、Lambda-表达式需要“函数式接口”的支持" class="headerlink" title="二、Lambda 表达式需要“函数式接口”的支持"></a>二、Lambda 表达式需要“函数式接口”的支持</h3><p>函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰</p><p>可以检查是否是函数式接口</p><h3 id="三、代码"><a href="#三、代码" class="headerlink" title="三、代码"></a>三、代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLambda2</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">0</span>;<span class="comment">//jdk 1.7 前，必须是 final</span></span><br><span class="line">      </span><br><span class="line">      Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World!"</span> + num);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      </span><br><span class="line">      r.run();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">      </span><br><span class="line">      Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello Lambda!"</span>);</span><br><span class="line">      r1.run();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Consumer&lt;String&gt; con = x -&gt; System.out.println(x);</span><br><span class="line">      con.accept(<span class="string">"我大尚硅谷威武！"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">"函数式接口"</span>);</span><br><span class="line">         <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">      &#125;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">      Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//    String[] strs;</span></span><br><span class="line"><span class="comment">//    strs = &#123;"aaa", "bbb", "ccc"&#125;;</span></span><br><span class="line">      </span><br><span class="line">      List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      </span><br><span class="line">      show(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Map&lt;String, Integer&gt; map)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//需求：对一个数进行运算</span></span><br><span class="line"><span class="comment">// @Test</span></span><br><span class="line"><span class="comment">// public void test6()&#123;</span></span><br><span class="line"><span class="comment">//    Integer num = operation(100, (x) -&gt; x * x);</span></span><br><span class="line"><span class="comment">//    System.out.println(num);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    System.out.println(operation(200, (y) -&gt; y + 200));</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// public Integer operation(Integer num, MyFun mf)&#123;</span></span><br><span class="line"><span class="comment">//    return mf.getValue(num);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java8-内置的四大核心函数式接口"><a href="#Java8-内置的四大核心函数式接口" class="headerlink" title="Java8 内置的四大核心函数式接口"></a>Java8 内置的四大核心函数式接口</h2><h3 id="Consumer-消费型接口"><a href="#Consumer-消费型接口" class="headerlink" title="Consumer : 消费型接口"></a>Consumer<t> : 消费型接口</t></h3><p>void accept(T t); 用来返回值为void</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   happy(<span class="number">10000</span>, (m) -&gt; System.out.println(<span class="string">"你们刚哥喜欢大宝剑，每次消费："</span> + m + <span class="string">"元"</span>));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">   con.accept(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Supplier-供给型接口"><a href="#Supplier-供给型接口" class="headerlink" title="Supplier 供给型接口"></a>Supplier<t> 供给型接口</t></h3><p>T get(); 用来有返回值无传入值的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Supplier&lt;T&gt; 供给型接口 :</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：产生指定个数的整数，并放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">   List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">      Integer n = sup.get();</span><br><span class="line">      list.add(n);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Function-lt-T-R-gt-函数型接口"><a href="#Function-lt-T-R-gt-函数型接口" class="headerlink" title="Function&lt;T, R&gt; : 函数型接口"></a>Function&lt;T, R&gt; : 函数型接口</h3><p>R apply(T t); 传入一个参数，返回一个对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function&lt;T, R&gt; 函数型接口：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">   String newStr = strHandler(<span class="string">"\t\t\t 我大尚硅谷威武   "</span>, (str) -&gt; str.trim());</span><br><span class="line">   System.out.println(newStr);</span><br><span class="line">   </span><br><span class="line">   String subStr = strHandler(<span class="string">"我大尚硅谷威武"</span>, (str) -&gt; str.substring(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">   System.out.println(subStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：用于处理字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; fun)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Predicate-断言型接口"><a href="#Predicate-断言型接口" class="headerlink" title="Predicate : 断言型接口"></a>Predicate<t> : 断言型接口</t></h3><p>boolean test(T t); 传入一个参数 ，返回一个boolean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Predicate&lt;T&gt; 断言型接口：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">   List&lt;String&gt; list = Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"atguigu"</span>, <span class="string">"Lambda"</span>, <span class="string">"www"</span>, <span class="string">"ok"</span>);</span><br><span class="line">   List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：将满足条件的字符串，放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">   List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">         strList.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> strList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambal-表达式用法&quot;&gt;&lt;a href=&quot;#Lambal-表达式用法&quot; class=&quot;headerlink&quot; title=&quot;Lambal 表达式用法&quot;&gt;&lt;/a&gt;Lambal 表达式用法&lt;/h2&gt;&lt;h3 id=&quot;一、Lambda-表达式的基础语法：&quot;&gt;&lt;a href=&quot;#一、Lambda-表达式的基础语法：&quot; class=&quot;headerlink&quot; title=&quot;一、Lambda 表达式的基础语法：&quot;&gt;&lt;/a&gt;一、Lambda 表达式的基础语法：&lt;/h3&gt;&lt;p&gt;Java8中引入了一个新的操作符 “-&amp;gt;” 该操作符称为箭头操作符或 Lambda 操作符&lt;/p&gt;&lt;p&gt;箭头操作符将 Lambda 表达式拆分成两部分：&lt;/p&gt;&lt;p&gt;左侧：Lambda 表达式的参数列表&lt;/p&gt;&lt;p&gt;右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java8新特性" scheme="http://yoursite.com/tags/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>线程同步</title>
    <link href="http://yoursite.com/2020/07/17/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/07/17/线程同步/</id>
    <published>2020-07-17T02:41:05.000Z</published>
    <updated>2020-07-22T02:21:04.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Synchronized的使用方法"><a href="#Synchronized的使用方法" class="headerlink" title="Synchronized的使用方法"></a>Synchronized的使用方法</h2><h3 id="同步锁机制："><a href="#同步锁机制：" class="headerlink" title="同步锁机制："></a><strong>同步锁机制：</strong></h3><h4 id="同步机制中的锁"><a href="#同步机制中的锁" class="headerlink" title="同步机制中的锁"></a>同步机制中的锁</h4><p>​    在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防</p><p>​    止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法</p><p>​    就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须</p><a id="more"></a><p>​    锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁</p><p>​    之时，另一个任务就可以锁定并使用它了。 </p><h4 id="synchronized的锁是什么？"><a href="#synchronized的锁是什么？" class="headerlink" title="synchronized的锁是什么？"></a>synchronized的锁是什么？</h4><p>​     任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 </p><pre><code>同步方法的锁：静态方法（类名.class）、非静态方法（this） 同步代码块：自己指定，很多时候也是指定为this或类名.class</code></pre><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>​    必须确保使用同一个资源的<strong>多个线程共用一把锁</strong>，这个非常重要，否则就</p><p>​    无法保证共享资源的安全</p><p>​     一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方</p><p>​    法共用同一把锁（this），同步代码块（指定需谨慎）</p><h3 id="使用同步代码块的方式处理Runable方法的"><a href="#使用同步代码块的方式处理Runable方法的" class="headerlink" title="使用同步代码块的方式处理Runable方法的"></a>使用同步代码块的方式处理Runable方法的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子：创建三个窗口卖票，总票数为100张.使用实现Runnable接口的方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.问题：卖票过程中，出现了重票、错票 --&gt;出现了线程的安全问题</span></span><br><span class="line"><span class="comment"> * 2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</span></span><br><span class="line"><span class="comment"> * 3.如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他</span></span><br><span class="line"><span class="comment"> *            线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4.在Java中，我们通过同步机制，来解决线程的安全问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  方式一：同步代码块</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   synchronized(同步监视器)&#123;</span></span><br><span class="line"><span class="comment"> *      //需要被同步的代码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *  说明：1.操作共享数据的代码，即为需要被同步的代码。  --&gt;不能包含代码多了，也不能包含代码少了。</span></span><br><span class="line"><span class="comment"> *       2.共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</span></span><br><span class="line"><span class="comment"> *       3.同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</span></span><br><span class="line"><span class="comment"> *          要求：多个线程必须要共用同一把锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *       补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</span></span><br><span class="line"><span class="comment"> *  方式二：同步方法。</span></span><br><span class="line"><span class="comment"> *     如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  5.同步的方式，解决了线程的安全问题。---好处</span></span><br><span class="line"><span class="comment"> *    操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-13 下午 4:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//    Object obj = new Object();</span></span><br><span class="line"><span class="comment">//    Dog dog = new Dog();</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//        Object obj = new Object();</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;<span class="comment">//此时的this:唯一的Window1的对象   //方式二：synchronized (dog) &#123;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":卖票，票号为："</span> + ticket);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window1 w = <span class="keyword">new</span> Window1();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用同步代码块的方式处理继承方法的"><a href="#使用同步代码块的方式处理继承方法的" class="headerlink" title="使用同步代码块的方式处理继承方法的"></a>使用同步代码块的方式处理继承方法的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 上午 11:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步代码块解决继承Thread类的方式的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 例子：创建三个窗口卖票，总票数为100张.使用继承Thread类的方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-13 下午 4:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window2</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//正确的</span></span><br><span class="line"><span class="comment">//            synchronized (obj)&#123;</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Window2.class)&#123;<span class="comment">//Class clazz = Window2.class,Window2.class只会加载一次</span></span><br><span class="line">                <span class="comment">//错误的方式：this代表着t1,t2,t3三个对象</span></span><br><span class="line"><span class="comment">//              synchronized (this)&#123;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(getName() + <span class="string">"：卖票，票号为："</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window2 t1 = <span class="keyword">new</span> Window2();</span><br><span class="line">        Window2 t2 = <span class="keyword">new</span> Window2();</span><br><span class="line">        Window2 t3 = <span class="keyword">new</span> Window2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用同步方法的方式处理Runable方法的"><a href="#使用同步方法的方式处理Runable方法的" class="headerlink" title="使用同步方法的方式处理Runable方法的"></a>使用同步方法的方式处理Runable方法的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步方法解决实现Runnable接口的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  关于同步方法的总结：</span></span><br><span class="line"><span class="comment"> *  1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</span></span><br><span class="line"><span class="comment"> *  2. 非静态的同步方法，同步监视器是：this</span></span><br><span class="line"><span class="comment"> *     静态的同步方法，同步监视器是：当前类本身</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 上午 11:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="comment">//synchronized (this)&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":卖票，票号为："</span> + ticket);</span><br><span class="line"></span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window3 w = <span class="keyword">new</span> Window3();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用同步方法的方式处理继承方法的"><a href="#使用同步方法的方式处理继承方法的" class="headerlink" title="使用同步方法的方式处理继承方法的"></a>使用同步方法的方式处理继承方法的</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用同步方法处理继承Thread类的方式中的线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019-02-15 上午 11:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window4</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//同步监视器：Window4.class</span></span><br><span class="line">        <span class="comment">//private synchronized void show()&#123; //同步监视器：t1,t2,t3。此种解决方式是错误的</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"：卖票，票号为："</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window4 t1 = <span class="keyword">new</span> Window4();</span><br><span class="line">        Window4 t2 = <span class="keyword">new</span> Window4();</span><br><span class="line">        Window4 t3 = <span class="keyword">new</span> Window4();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">        t2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">        t3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Synchronized的使用方法&quot;&gt;&lt;a href=&quot;#Synchronized的使用方法&quot; class=&quot;headerlink&quot; title=&quot;Synchronized的使用方法&quot;&gt;&lt;/a&gt;Synchronized的使用方法&lt;/h2&gt;&lt;h3 id=&quot;同步锁机制：&quot;&gt;&lt;a href=&quot;#同步锁机制：&quot; class=&quot;headerlink&quot; title=&quot;同步锁机制：&quot;&gt;&lt;/a&gt;&lt;strong&gt;同步锁机制：&lt;/strong&gt;&lt;/h3&gt;&lt;h4 id=&quot;同步机制中的锁&quot;&gt;&lt;a href=&quot;#同步机制中的锁&quot; class=&quot;headerlink&quot; title=&quot;同步机制中的锁&quot;&gt;&lt;/a&gt;同步机制中的锁&lt;/h4&gt;&lt;p&gt;​    在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防&lt;/p&gt;&lt;p&gt;​    止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法&lt;/p&gt;&lt;p&gt;​    就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://yoursite.com/2020/07/16/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/16/单例模式/</id>
    <published>2020-07-16T07:37:38.000Z</published>
    <updated>2020-07-22T02:20:42.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类</p><p><strong>只能存在一个对象实例</strong>，并且该类只提供一个取得其对象实例的方法(静态方法)。</p><p>比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session</p><p>对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个</p><a id="more"></a><p>SessionFactory就够，这是就会使用到单例模式</p><h2 id="单例设计模式八种方式"><a href="#单例设计模式八种方式" class="headerlink" title="单例设计模式八种方式"></a>单例设计模式八种方式</h2><p>单例模式有八种方式：</p><p><strong>1) 饿汉式(静态常量)</strong></p><p><strong>2) 饿汉式（静态代码块）</strong></p><p>3) 懒汉式(线程不安全)</p><p>4) 懒汉式(线程安全，同步方法)</p><p>5) 懒汉式(线程安全，同步代码块)</p><p><strong>6) 双重检查</strong></p><p><strong>7) 静态内部类</strong></p><p>8) 枚举</p><h2 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式(静态变量)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//1. 构造器私有化, 外部能new</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.本类内部创建对象实例</span></span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中，创建单例对象</span></span><br><span class="line">      instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//3. 提供一个公有的静态方法，返回实例对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明："><a href="#优缺点说明：" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) 优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同</p><p>​    步问题。</p><p>2) 缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始</p><p>​    至终从未使用过这个实例，则会造成内存的浪费</p><p>3) 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载</p><p>​    时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载</p><p>​    的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类</p><p>​    装载，这时候初始化instance就没有达到lazy loading的效果</p><p>4) 结论：这种单例模式<strong>可用</strong>，<strong>可能</strong>造成内存浪费</p><h2 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，当使用到该方法时，才去创建 instance</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明：-1"><a href="#优缺点说明：-1" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) 起到了Lazy Loading的效果，但是只能在单线程下使用。</p><p>2) 如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及</p><p>​    往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以</p><p>​    在多线程环境下不可使用这种方式</p><p>3) 结论：在实际开发中，不要使用这种方式.</p><h2 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题</span></span><br><span class="line">   <span class="comment">//即懒汉式</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明：-2"><a href="#优缺点说明：-2" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) 解决了线程不安全问题</p><p>2) 效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行</p><p>​    同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，</p><p>​    直接return就行了。方法进行同步效率太低</p><p>3) 结论：在实际开发中，不推荐使用这种方式</p><h2 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式(线程安全，同步方法)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，加入双重检查代码，解决线程安全问题, 同时解决懒加载问题</span></span><br><span class="line">   <span class="comment">//同时保证了效率, 推荐使用</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明：-3"><a href="#优缺点说明：-3" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两</p><p>​    次if (singleton == null)检查，这样就可以保证线程安全了。</p><p>2) 这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，</p><p>​    直接return实例化对象，也避免的反复进行方法同步.</p><p>3) 线程安全；延迟加载；效率较高</p><p>4) 结论：在实际开发中，推荐使用这种单例设计模式</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态内部类完成， 推荐使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//构造器私有化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//写一个静态内部类,该类中有一个静态属性 Singleton</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton(); </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//提供一个静态的公有方法，直接返回SingletonInstance.INSTANCE</span></span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明：-4"><a href="#优缺点说明：-4" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。</p><p>2) 静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化</p><p>​    时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的</p><p>​    实例化。</p><p>3) 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们</p><p>​    保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</p><p>4) 优点：避免了<strong>线程不安全</strong>，利用静态内部类特点实现延迟加载，效率高</p><p>5) 结论：推荐使用.</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用枚举，可以实现单例, 推荐</span></span><br><span class="line"><span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">   INSTANCE; <span class="comment">//属性</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayOK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"ok~"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点说明：-5"><a href="#优缺点说明：-5" class="headerlink" title="优缺点说明："></a>优缺点说明：</h3><p>1) 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而</p><p>​    且还能防止反序列化重新创建新的对象。</p><p>2) 这种方式是Effective Java作者Josh Bloch 提倡的方式</p><p>3) 结论：推荐使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单例设计模式介绍&quot;&gt;&lt;a href=&quot;#单例设计模式介绍&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式介绍&quot;&gt;&lt;/a&gt;单例设计模式介绍&lt;/h2&gt;&lt;p&gt;所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类&lt;/p&gt;&lt;p&gt;&lt;strong&gt;只能存在一个对象实例&lt;/strong&gt;，并且该类只提供一个取得其对象实例的方法(静态方法)。&lt;/p&gt;&lt;p&gt;比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建Session&lt;/p&gt;&lt;p&gt;对象。SessionFactory并不是轻量级的，一般情况下，一个项目通常只需要一个&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程的基础</title>
    <link href="http://yoursite.com/2020/07/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E9%94%AE/"/>
    <id>http://yoursite.com/2020/07/15/多线程的创键/</id>
    <published>2020-07-15T06:59:37.000Z</published>
    <updated>2020-07-22T02:20:04.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程常用的方法"><a href="#线程常用的方法" class="headerlink" title="线程常用的方法"></a>线程常用的方法</h2><ol><li><p>start():启动当前线程；调用当前线程的run()</p></li><li><p>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread():静态方法，返回执行当前代码的线程</p></li><li><p>getName():获取当前线程的名字</p></li><li><p>setName():设置当前线程的名字</p></li><li><p>yield():释放当前cpu的执行权</p></li><li><p>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p></li><li><p>stop():已过时。当执行此方法时，强制结束当前线程。</p></li><li><p>sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前</p></li></ol><a id="more"></a><p>线程是阻塞状态。</p><ol start="10"><li>isAlive():判断当前线程是否存活</li></ol><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>1.优先级</p><p>​    MAX_PRIORITY：10</p><p>​    MIN _PRIORITY：1</p><p>​    NORM_PRIORITY：5  –&gt;默认优先级</p><p>2.如何获取和设置当前线程的优先级：</p><p>​    getPriority():获取线程的优先级</p><p>​    setPriority(int p):设置线程的优先级</p><p>说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</p><h2 id="用继承的方式创键线程"><a href="#用继承的方式创键线程" class="headerlink" title="用继承的方式创键线程"></a>用继承的方式创键线程</h2><ul><li><ol><li>创建一个继承于Thread类的子类</li></ol></li><li><ol start="2"><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li></ol></li><li><ol start="3"><li>创建Thread类的子类的对象</li></ol></li><li><ol start="4"><li>通过此对象调用start()</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//问题一：我们不能通过直接调用run()的方式启动线程。</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException</span></span><br><span class="line"><span class="comment">//        t1.start();</span></span><br><span class="line">        <span class="comment">//我们需要重新创建一个线程的对象</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下操作仍然是在main线程中执行的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i + <span class="string">"***********main()************"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Runnable接口实现线程"><a href="#使用Runnable接口实现线程" class="headerlink" title="使用Runnable接口实现线程"></a>使用Runnable接口实现线程</h2><ol><li><p>创建一个实现了Runnable接口的类</p></li><li><p>实现类去实现Runnable中的抽象方法：run()</p></li><li><p>创建实现类的对象</p></li><li><p>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</p></li><li><p>通过Thread类的对象调用start()</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        MThread mThread = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t1.setName(<span class="string">"线程1"</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()--&gt;调用了Runnable类型的target的run()</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再启动一个线程，遍历100以内的偶数</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mThread);</span><br><span class="line">        t2.setName(<span class="string">"线程2"</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程常用的方法&quot;&gt;&lt;a href=&quot;#线程常用的方法&quot; class=&quot;headerlink&quot; title=&quot;线程常用的方法&quot;&gt;&lt;/a&gt;线程常用的方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;start():启动当前线程；调用当前线程的run()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;currentThread():静态方法，返回执行当前代码的线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getName():获取当前线程的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;setName():设置当前线程的名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;yield():释放当前cpu的执行权&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;stop():已过时。当执行此方法时，强制结束当前线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="http://yoursite.com/2020/07/13/%E9%80%92%E5%BD%92/"/>
    <id>http://yoursite.com/2020/07/13/递归/</id>
    <published>2020-07-13T08:20:15.000Z</published>
    <updated>2020-07-22T02:20:45.707Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p><h2 id="递归需要遵守的重要规则"><a href="#递归需要遵守的重要规则" class="headerlink" title="递归需要遵守的重要规则"></a>递归需要遵守的重要规则</h2><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)<br>方法的局部变量是独立的，不会相互影响, 比如n变量<br>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.<br>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)<br>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p><a id="more"></a><h2 id="递归-迷宫问题"><a href="#递归-迷宫问题" class="headerlink" title="递归-迷宫问题"></a>递归-迷宫问题</h2><p><img src="/images/Digui_1.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiGong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line"><span class="comment">// 地图</span></span><br><span class="line"><span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line"><span class="comment">// 使用1 表示墙</span></span><br><span class="line"><span class="comment">// 上下全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右全部置为1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">map[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">map[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//map[1][2] = 1;</span></span><br><span class="line"><span class="comment">//map[2][2] = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出地图</span></span><br><span class="line">System.out.println(<span class="string">"地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line"><span class="comment">//setWay(map, 1, 1);</span></span><br><span class="line">setWay2(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">System.out.println(<span class="string">"小球走过，并标识过的 地图的情况"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">System.out.print(map[i][j] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. map 表示地图</span></span><br><span class="line"><span class="comment">//2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment">//3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment">//4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment">//5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 从哪个位置开始找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左  走</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span>(setWay(map, i+<span class="number">1</span>, j)) &#123;<span class="comment">//向下走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j+<span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i-<span class="number">1</span>, j)) &#123; <span class="comment">//向上</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(map, i, j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改找路的策略，改成 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay2</span><span class="params">(<span class="keyword">int</span>[][] map, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>] == <span class="number">2</span>) &#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(map[i][j] == <span class="number">0</span>) &#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line"><span class="comment">//按照策略 上-&gt;右-&gt;下-&gt;左</span></span><br><span class="line">map[i][j] = <span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line"><span class="keyword">if</span>(setWay2(map, i-<span class="number">1</span>, j)) &#123;<span class="comment">//向上走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j+<span class="number">1</span>)) &#123; <span class="comment">//向右走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i+<span class="number">1</span>, j)) &#123; <span class="comment">//向下</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay2(map, i, j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">map[i][j] = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归-八皇后问题-回溯算法"><a href="#递归-八皇后问题-回溯算法" class="headerlink" title="递归-八皇后问题(回溯算法)"></a>递归-八皇后问题(回溯算法)</h2><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个max表示共有多少个皇后</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125; </span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> judgeCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把 ， 8皇后是否正确</span></span><br><span class="line">Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">queue8.check(<span class="number">0</span>);</span><br><span class="line">System.out.printf(<span class="string">"一共有%d解法"</span>, count);</span><br><span class="line">System.out.printf(<span class="string">"一共判断冲突的次数%d次"</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">//特别注意： check 是 每一次递归时，进入到check中都有  for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == max) &#123;  <span class="comment">//n = 8 , 其实8个皇后就既然放好</span></span><br><span class="line">print();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依次放入皇后，并判断是否冲突</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line"><span class="comment">//先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">array[n] = i;</span><br><span class="line"><span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line"><span class="keyword">if</span>(judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line"><span class="comment">//接着放n+1个皇后,即开始递归</span></span><br><span class="line">check(n+<span class="number">1</span>); <span class="comment">//  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">judgeCount++;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">//1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line"><span class="comment">//2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line"><span class="comment">// n = 1  放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line"><span class="comment">// Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line"><span class="comment">//3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line"><span class="keyword">if</span>(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i]) ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;简单的说: 递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。&lt;/p&gt;&lt;h2 id=&quot;递归需要遵守的重要规则&quot;&gt;&lt;a href=&quot;#递归需要遵守的重要规则&quot; class=&quot;headerlink&quot; title=&quot;递归需要遵守的重要规则&quot;&gt;&lt;/a&gt;递归需要遵守的重要规则&lt;/h2&gt;&lt;p&gt;执行一个方法时，就创建一个新的受保护的独立空间(栈空间)&lt;br&gt;方法的局部变量是独立的，不会相互影响, 比如n变量&lt;br&gt;如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.&lt;br&gt;递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)&lt;br&gt;当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>前缀、中缀、后缀表达式</title>
    <link href="http://yoursite.com/2020/07/03/%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/07/03/前缀、中缀、后缀表达式/</id>
    <published>2020-07-03T03:14:36.000Z</published>
    <updated>2020-07-22T02:11:09.443Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="前缀表达式介绍"><a href="#前缀表达式介绍" class="headerlink" title="前缀表达式介绍"></a>前缀表达式介绍</h2><p>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前<br>举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6</p><h2 id="前缀表达式的计算机求值"><a href="#前缀表达式的计算机求值" class="headerlink" title="前缀表达式的计算机求值"></a>前缀表达式的计算机求值</h2><p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p><a id="more"></a><p>例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:</p><p>从右至左扫描，将6、5、4、3压入堆栈<br>遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈<br>接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈<br>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</p><h2 id="中缀表达式介绍"><a href="#中缀表达式介绍" class="headerlink" title="中缀表达式介绍"></a>中缀表达式介绍</h2><p>中缀表达式就是常见的运算表达式，如(3+4)×5-6</p><p>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)</p><h2 id="后缀表达式介绍"><a href="#后缀表达式介绍" class="headerlink" title="后缀表达式介绍"></a>后缀表达式介绍</h2><p>后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后</p><p>中举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –</p><h2 id="后缀表达式的计算机求值"><a href="#后缀表达式的计算机求值" class="headerlink" title="后缀表达式的计算机求值"></a>后缀表达式的计算机求值</h2><p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p><p>例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:</p><p>从左至右扫描，将3和4压入堆栈；<br>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；<br>将5入栈；<br>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；<br>将6入栈；<br>最后是-运算符，计算出35-6的值，即29，由此得出最终结果    </p><h2 id="逆波兰表达式计算器代码"><a href="#逆波兰表达式计算器代码" class="headerlink" title="逆波兰表达式计算器代码"></a>逆波兰表达式计算器代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReversePolishMultiCalc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String SYMBOL = <span class="string">"\\+|-|\\*|/|\\(|\\)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String LEFT = <span class="string">"("</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String RIGHT = <span class="string">")"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ADD = <span class="string">"+"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">"-"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String TIMES = <span class="string">"*"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DIVISION = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_01 = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_02 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LEVEL_HIGH = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceAllBlank</span><span class="params">(String s )</span></span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">"\\s+"</span>,<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">"^[-\\+]?[.\\d]*$"</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymbol</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calcLevel</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"+"</span>.equals(s) || <span class="string">"-"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"*"</span>.equals(s) || <span class="string">"/"</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || <span class="string">""</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data is empty"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">""</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data illeagle,start not with a number"</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">""</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">""</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">""</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"data not match number"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> ArrayList&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doCalc</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Double d = <span class="number">0</span>d;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                Double d1 = doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">""</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span></span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String math = "9+(3-1)*3+10/2";</span></span><br><span class="line">        String math = <span class="string">"12.8 + (2 - 3.55)*4+10/5.0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolandNotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 1+((2+3)×4)-5 =&gt; 转成  1 2 3 + 4 × + 5 –</span></span><br><span class="line"><span class="comment">//2. 因为直接对str 进行操作，不方便，因此 先将  "1+((2+3)×4)-5" =》 中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">//   即 "1+((2+3)×4)-5" =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"><span class="comment">//3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="comment">//   即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"></span><br><span class="line">String expression = <span class="string">"1+((2+3)*4)-5"</span>;<span class="comment">//注意表达式 </span></span><br><span class="line">List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">System.out.println(<span class="string">"中缀表达式对应的List="</span> + infixExpressionList); <span class="comment">// ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">System.out.println(<span class="string">"后缀表达式对应的List"</span> + suffixExpreesionList); <span class="comment">//ArrayList [1,2,3,+,4,*,+,5,–] </span></span><br><span class="line"></span><br><span class="line">System.out.printf(<span class="string">"expression=%d"</span>, calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line"><span class="comment">//(30+4)×5-6  =&gt; 30 4 + 5 × 6 - =&gt; 164</span></span><br><span class="line"><span class="comment">// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + </span></span><br><span class="line"><span class="comment">//测试 </span></span><br><span class="line"><span class="comment">//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span></span><br><span class="line"><span class="comment">//String suffixExpression = "30 4 + 5 * 6 -";</span></span><br><span class="line"><span class="comment">String suffixExpression = "4 5 * 8 - 60 + 8 2 / +"; // 76</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 先将 "3 4 + 5 × 6 - " =&gt; 放到ArrayList中</span></span><br><span class="line"><span class="comment">//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">List&lt;String&gt; list = getListString(suffixExpression);</span></span><br><span class="line"><span class="comment">System.out.println("rpnList=" + list);</span></span><br><span class="line"><span class="comment">int res = calculate(list);</span></span><br><span class="line"><span class="comment">System.out.println("计算的结果是=" + res);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]  =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"><span class="comment">//方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个栈</span></span><br><span class="line">Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;String&gt;(); <span class="comment">// 符号栈</span></span><br><span class="line"><span class="comment">//说明：因为s2 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line"><span class="comment">//因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; s2</span></span><br><span class="line"><span class="comment">//Stack&lt;String&gt; s2 = new Stack&lt;String&gt;(); // 储存中间结果的栈s2</span></span><br><span class="line">List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;String&gt;(); <span class="comment">// 储存中间结果的Lists2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历ls</span></span><br><span class="line"><span class="keyword">for</span>(String item: ls) &#123;</span><br><span class="line"><span class="comment">//如果是一个数，加入s2</span></span><br><span class="line"><span class="keyword">if</span>(item.matches(<span class="string">"\\d+"</span>)) &#123;</span><br><span class="line">s2.add(item);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s1.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">")"</span>)) &#123;</span><br><span class="line"><span class="comment">//如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line"><span class="keyword">while</span>(!s1.peek().equals(<span class="string">"("</span>)) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line">s1.pop();<span class="comment">//!!! 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//当item的优先级小于等于s1栈顶运算符, 将s1栈顶的运算符弹出并加入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较</span></span><br><span class="line"><span class="comment">//问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item) ) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//还需要将item压入栈</span></span><br><span class="line">s1.push(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line"><span class="keyword">while</span>(s1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">s2.add(s1.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s2; <span class="comment">//注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：将 中缀表达式转成对应的List</span></span><br><span class="line"><span class="comment">//  s="1+((2+3)×4)-5";</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpressionList</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">List&lt;String&gt; ls = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//这时是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">String str; <span class="comment">// 对多位数的拼接</span></span><br><span class="line"><span class="keyword">char</span> c; <span class="comment">// 每遍历到一个字符，就放入到c</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="comment">//如果c是一个非数字，我需要加入到ls</span></span><br><span class="line"><span class="keyword">if</span>((c=s.charAt(i)) &lt; <span class="number">48</span> ||  (c=s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">ls.add(<span class="string">""</span> + c);</span><br><span class="line">i++; <span class="comment">//i需要后移</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//如果是一个数，需要考虑多位数</span></span><br><span class="line">str = <span class="string">""</span>; <span class="comment">//先将str 置成"" '0'[48]-&gt;'9'[57]</span></span><br><span class="line"><span class="keyword">while</span>(i &lt; s.length() &amp;&amp; (c=s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c=s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">str += c;<span class="comment">//拼接</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ls.add(str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(i &lt; s.length());</span><br><span class="line"><span class="keyword">return</span> ls;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String suffixExpression)</span> </span>&#123;</span><br><span class="line"><span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">String[] split = suffixExpression.split(<span class="string">" "</span>);</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">for</span>(String ele: split) &#123;</span><br><span class="line">list.add(ele);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1)从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">3)将5入栈；</span></span><br><span class="line"><span class="comment">4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">5)将6入栈；</span></span><br><span class="line"><span class="comment">6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;String&gt;();</span><br><span class="line"><span class="comment">// 遍历 ls</span></span><br><span class="line"><span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line"><span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line"><span class="keyword">if</span> (item.matches(<span class="string">"\\d+"</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line"><span class="comment">// 入栈</span></span><br><span class="line">stack.push(item);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line"><span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (item.equals(<span class="string">"+"</span>)) &#123;</span><br><span class="line">res = num1 + num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"-"</span>)) &#123;</span><br><span class="line">res = num1 - num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">res = num1 * num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">"/"</span>)) &#123;</span><br><span class="line">res = num1 / num2;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"运算符有误"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把res 入栈</span></span><br><span class="line">stack.push(<span class="string">""</span> + res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line"><span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写一个方法，返回对应的优先级数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String operation)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (operation) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">result = ADD;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">result = SUB;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">result = MUL;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">result = DIV;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"不存在该运算符"</span> + operation);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;&lt;h2 id=&quot;前缀表达式介绍&quot;&gt;&lt;a href=&quot;#前缀表达式介绍&quot; class=&quot;headerlink&quot; title=&quot;前缀表达式介绍&quot;&gt;&lt;/a&gt;前缀表达式介绍&lt;/h2&gt;&lt;p&gt;前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前&lt;br&gt;举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6&lt;/p&gt;&lt;h2 id=&quot;前缀表达式的计算机求值&quot;&gt;&lt;a href=&quot;#前缀表达式的计算机求值&quot; class=&quot;headerlink&quot; title=&quot;前缀表达式的计算机求值&quot;&gt;&lt;/a&gt;前缀表达式的计算机求值&lt;/h2&gt;&lt;p&gt;从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://yoursite.com/2020/07/03/%E6%A0%88/"/>
    <id>http://yoursite.com/2020/07/03/栈/</id>
    <published>2020-07-03T03:04:26.000Z</published>
    <updated>2020-07-22T02:12:35.947Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>栈的英文为(stack)<br>栈是一个先入后出(FILO-First In Last Out)的有序列表。<br>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。<br>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p><a id="more"></a><p><img src="/images/statck.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一下ArrayStack 是否正确</span></span><br><span class="line"><span class="comment">//先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">ArrayStack stack = <span class="keyword">new</span> ArrayStack(<span class="number">4</span>);</span><br><span class="line">String key = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>; <span class="comment">//控制是否退出菜单</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"show: 表示显示栈"</span>);</span><br><span class="line">System.out.println(<span class="string">"exit: 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"push: 表示添加数据到栈(入栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"pop: 表示从栈取出数据(出栈)"</span>);</span><br><span class="line">System.out.println(<span class="string">"请输入你的选择"</span>);</span><br><span class="line">key = scanner.next();</span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"show"</span>:</span><br><span class="line">stack.list();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"push"</span>:</span><br><span class="line">System.out.println(<span class="string">"请输入一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">stack.push(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"pop"</span>:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = stack.pop();</span><br><span class="line">System.out.printf(<span class="string">"出栈的数据是 %d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"exit"</span>:</span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 ArrayStack 表示栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//栈满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入栈-push</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否满</span></span><br><span class="line"><span class="keyword">if</span>(isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈满"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line">stack[top] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出栈-pop, 将栈顶的数据返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//先判断栈是否空</span></span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line"><span class="comment">//抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"栈空，没有数据~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value = stack[top];</span><br><span class="line">top--;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"栈空，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要从栈顶开始显示数据</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">System.out.printf(<span class="string">"stack[%d]=%d\n"</span>, i, stack[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;栈的英文为(stack)&lt;br&gt;栈是一个先入后出(FILO-First In Last Out)的有序列表。&lt;br&gt;栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。&lt;br&gt;根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://yoursite.com/2020/07/03/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/07/03/链表/</id>
    <published>2020-07-03T02:53:29.000Z</published>
    <updated>2020-07-22T02:10:27.182Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>链表是以节点的方式来存储,是链式存储<br>每个节点包含 data 域， next 域：指向下一个节点.<br>如图：发现链表的各个节点不一定是连续存储.<br>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p><a id="more"></a><p><img src="/images/LinkList1.png" alt></p><h2 id="单链表介绍"><a href="#单链表介绍" class="headerlink" title="单链表介绍"></a>单链表介绍</h2><p><img src="/images/LinkList2.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//进行测试</span></span><br><span class="line"><span class="comment">//先创建节点</span></span><br><span class="line">HeroNode hero1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode hero2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode hero3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode hero4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建要给链表</span></span><br><span class="line">SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加入</span></span><br><span class="line">singleLinkedList.add(hero1);</span><br><span class="line">singleLinkedList.add(hero4);</span><br><span class="line">singleLinkedList.add(hero2);</span><br><span class="line">singleLinkedList.add(hero3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试一下单链表的反转功能</span></span><br><span class="line">System.out.println(<span class="string">"原来链表的情况~~"</span>);</span><br><span class="line">singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println("反转单链表~~");</span></span><br><span class="line"><span class="comment">//reversetList(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"测试逆序打印单链表, 没有改变链表的结构~~"</span>);</span><br><span class="line">reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//加入按照编号的顺序</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero1);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero4);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero2);</span></span><br><span class="line"><span class="comment">singleLinkedList.addByOrder(hero3);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//显示一把</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试修改节点的代码</span></span><br><span class="line"><span class="comment">HeroNode newHeroNode = new HeroNode(2, "小卢", "玉麒麟~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.update(newHeroNode);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">System.out.println("修改后的链表情况~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//删除一个节点</span></span><br><span class="line"><span class="comment">singleLinkedList.del(1);</span></span><br><span class="line"><span class="comment">singleLinkedList.del(4);</span></span><br><span class="line"><span class="comment">System.out.println("删除后的链表情况~~");</span></span><br><span class="line"><span class="comment">singleLinkedList.list();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一下 求单链表中有效节点的个数</span></span><br><span class="line"><span class="comment">System.out.println("有效的节点个数=" + getLength(singleLinkedList.getHead()));//2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line"><span class="comment">HeroNode res = findLastIndexNode(singleLinkedList.getHead(), 3);</span></span><br><span class="line"><span class="comment">System.out.println("res=" + res);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2：</span></span><br><span class="line"><span class="comment">//可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//空链表，不能打印</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">stack.push(cur);</span><br><span class="line">cur = cur.next; <span class="comment">//cur后移，这样就可以压入下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将栈中的节点进行打印,pop 出栈</span></span><br><span class="line"><span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(stack.pop()); <span class="comment">//stack的特点是先进后出</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将单链表反转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line">HeroNode next = <span class="keyword">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">HeroNode reverseHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line"><span class="comment">//动脑筋</span></span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123; </span><br><span class="line">next = cur.next;<span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">cur.next = reverseHead.next;<span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">reverseHead.next = cur; <span class="comment">//将cur 连接到新的链表上</span></span><br><span class="line">cur = next;<span class="comment">//让cur后移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">head.next = reverseHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. 编写一个方法，接收head节点，同时接收一个index </span></span><br><span class="line"><span class="comment">//2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">//3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">//4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">//5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findLastIndexNode</span><span class="params">(HeroNode head, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断如果链表为空，返回null</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//没有找到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line"><span class="keyword">int</span> size = getLength(head);</span><br><span class="line"><span class="comment">//第二次遍历  size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line"><span class="comment">//先做一个index的校验</span></span><br><span class="line"><span class="keyword">if</span>(index &lt;=<span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义给辅助变量， for 循环定位到倒数的index</span></span><br><span class="line">HeroNode cur = head.next; <span class="comment">//3 // 3 - 1 = 2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt; size - index; i++) &#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123; <span class="comment">//空链表</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">HeroNode cur = head.next;</span><br><span class="line"><span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">length++;</span><br><span class="line">cur = cur.next; <span class="comment">//遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">//先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加节点到单向链表</span></span><br><span class="line"><span class="comment">//思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">//1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">//2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="comment">//遍历链表，找到最后</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//找到链表的最后</span></span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">//将最后这个节点的next 指向 新的节点</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">//(如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line"><span class="comment">//因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//说明temp已经在链表的最后</span></span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(temp.next.no &gt; heroNode.no) &#123; <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">//说明希望添加的heroNode的编号已然存在</span></span><br><span class="line"></span><br><span class="line">flag = <span class="keyword">true</span>; <span class="comment">//说明编号存在</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">//后移，遍历当前链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断flag 的值</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123; <span class="comment">//不能添加，说明编号存在</span></span><br><span class="line">System.out.printf(<span class="string">"准备插入的英雄的编号 %d 已经存在了, 不能加入\n"</span>, heroNode.no);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//插入到链表中, temp的后面</span></span><br><span class="line">heroNode.next = temp.next;</span><br><span class="line">temp.next = heroNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断是否空</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">//定义一个辅助变量</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">//表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//已经遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">//找到</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有找到</span></span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="comment">//思路</span></span><br><span class="line"><span class="comment">//1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">//2. 说明我们在比较时，是temp.next.no 和  需要删除的节点的no比较</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">HeroNode temp = head;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(temp.next == <span class="keyword">null</span>) &#123; <span class="comment">//已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(temp.next.no == no) &#123;</span><br><span class="line"><span class="comment">//找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">//temp后移，遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断flag</span></span><br><span class="line"><span class="keyword">if</span>(flag) &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//可以删除</span></span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span>(head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode temp = head.next;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span>(temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">//将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode next; <span class="comment">//指向下一个节点</span></span><br><span class="line"><span class="comment">//构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双向链表介绍"><a href="#双向链表介绍" class="headerlink" title="双向链表介绍"></a>双向链表介绍</h2><p><img src="/images/LinkList3.png" alt></p><h2 id="双向链表代码"><a href="#双向链表代码" class="headerlink" title="双向链表代码"></a>双向链表代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">System.out.println(<span class="string">"双向链表的测试"</span>);</span><br><span class="line"><span class="comment">// 先创建节点</span></span><br><span class="line">HeroNode2 hero1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">"宋江"</span>, <span class="string">"及时雨"</span>);</span><br><span class="line">HeroNode2 hero2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">"卢俊义"</span>, <span class="string">"玉麒麟"</span>);</span><br><span class="line">HeroNode2 hero3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">"吴用"</span>, <span class="string">"智多星"</span>);</span><br><span class="line">HeroNode2 hero4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"林冲"</span>, <span class="string">"豹子头"</span>);</span><br><span class="line"><span class="comment">// 创建一个双向链表</span></span><br><span class="line">DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">doubleLinkedList.add(hero1);</span><br><span class="line">doubleLinkedList.add(hero2);</span><br><span class="line">doubleLinkedList.add(hero3);</span><br><span class="line">doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">HeroNode2 newHeroNode = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">"公孙胜"</span>, <span class="string">"入云龙"</span>);</span><br><span class="line">doubleLinkedList.update(newHeroNode);</span><br><span class="line">System.out.println(<span class="string">"修改后的链表情况"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"删除后的链表情况~~"</span>);</span><br><span class="line">doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line"><span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回头节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历双向链表的方法</span></span><br><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 判断是否到链表最后</span></span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出节点的信息</span></span><br><span class="line">System.out.println(temp);</span><br><span class="line"><span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">HeroNode2 temp = head;</span><br><span class="line"><span class="comment">// 遍历链表，找到最后</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 找到链表的最后</span></span><br><span class="line"><span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;<span class="comment">//</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line"><span class="comment">// 形成一个双向链表</span></span><br><span class="line">temp.next = heroNode;</span><br><span class="line">heroNode.pre = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line"><span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断是否空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"链表为空~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line"><span class="comment">// 定义一个辅助变量</span></span><br><span class="line">HeroNode2 temp = head.next;</span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line"><span class="comment">// 找到</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">temp.name = newHeroNode.name;</span><br><span class="line">temp.nickname = newHeroNode.nickname;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">System.out.printf(<span class="string">"没有找到 编号 %d 的节点，不能修改\n"</span>, newHeroNode.no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">System.out.println(<span class="string">"链表为空，无法删除"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HeroNode2 temp = head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line"><span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断flag</span></span><br><span class="line"><span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line"><span class="comment">// 可以删除</span></span><br><span class="line"><span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">temp.pre.next = temp.next;</span><br><span class="line"><span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line"><span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line"><span class="keyword">if</span> (temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp.next.pre = temp.pre;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.printf(<span class="string">"要删除的 %d 节点不存在\n"</span>, no);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode2 ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> String nickname;</span><br><span class="line"><span class="keyword">public</span> HeroNode2 next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line"><span class="keyword">public</span> HeroNode2 pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">", nickname="</span> + nickname + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单向环形链表介绍"><a href="#单向环形链表介绍" class="headerlink" title="单向环形链表介绍"></a>单向环形链表介绍</h2><p><img src="/images/LinkList4.png" alt></p><h2 id="单向环形链表代码"><a href="#单向环形链表代码" class="headerlink" title="单向环形链表代码"></a>单向环形链表代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josepfu</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">CircleSingleLinkedList circleSingleLinkedList = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">circleSingleLinkedList.addBoy(<span class="number">125</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把小孩出圈是否正确</span></span><br><span class="line">circleSingleLinkedList.countBoy(<span class="number">10</span>, <span class="number">20</span>, <span class="number">125</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line"><span class="comment">//String str = "7*2*2-5+1-5+3-3";</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line"><span class="keyword">private</span> Boy first = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// nums 做一个数据校验</span></span><br><span class="line"><span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"nums的值不正确"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Boy curBoy = <span class="keyword">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line"><span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line"><span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line"><span class="comment">// 如果是第一个小孩</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">first = boy;</span><br><span class="line">first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curBoy.setNext(boy);<span class="comment">//</span></span><br><span class="line">boy.setNext(first);<span class="comment">//</span></span><br><span class="line">curBoy = boy;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历当前的环形链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断链表是否为空</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"没有任何小孩~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">Boy curBoy = first;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.printf(<span class="string">"小孩的编号 %d \n"</span>, curBoy.getNo());</span><br><span class="line"><span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo</span></span><br><span class="line"><span class="comment"> *            表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum</span></span><br><span class="line"><span class="comment"> *            表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> *            表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 先对数据进行校验</span></span><br><span class="line"><span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">System.out.println(<span class="string">"参数输入有误， 请重新输入"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">Boy helper = first;</span><br><span class="line"><span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小孩报数前，先让 first 和  helper 移动 k - 1次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当小孩报数时，让first 和 helper 指针同时 的移动  m  - 1 次, 然后出圈</span></span><br><span class="line"><span class="comment">//这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(helper == first) &#123; <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">first = first.getNext();</span><br><span class="line">helper = helper.getNext();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">System.out.printf(<span class="string">"小孩%d出圈\n"</span>, first.getNo());</span><br><span class="line"><span class="comment">//这时将first指向的小孩节点出圈</span></span><br><span class="line">first = first.getNext();</span><br><span class="line">helper.setNext(first); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"最后留在圈中的小孩编号%d \n"</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> no;<span class="comment">// 编号</span></span><br><span class="line"><span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.no = no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>## </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;链表是以节点的方式来存储,是链式存储&lt;br&gt;每个节点包含 data 域， next 域：指向下一个节点.&lt;br&gt;如图：发现链表的各个节点不一定是连续存储.&lt;br&gt;链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="http://yoursite.com/2020/07/03/%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/07/03/队列/</id>
    <published>2020-07-03T02:43:50.000Z</published>
    <updated>2020-07-22T02:07:34.536Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>队列是一个有序列表，可以用数组或是链表来实现。<br>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</p><h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。</p><a id="more"></a><p>因为队列的输出、输入是分别从前后端来处理，因此需要两个变量 front及 rear分别记录队列前后端的下标，front 会随着数据输出而改变，而 rear则是随着数据输入而改变</p><p><img src="/images/ArrayQueue.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line"><span class="comment">//创建一个队列</span></span><br><span class="line">ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">//接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span>(loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">//接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">//取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">//查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">//退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建队列的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">maxSize = arrMaxSize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">rear++; <span class="comment">// 让rear 后移</span></span><br><span class="line">arr[rear] = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line">front++; <span class="comment">// front后移</span></span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h2><p>尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意 (rear + 1) % maxSize == front 满]<br>rear == front [空]</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircleArrayQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一把</span></span><br><span class="line">System.out.println(<span class="string">"测试数组模拟环形队列的案例~~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形队列</span></span><br><span class="line">CircleArray queue = <span class="keyword">new</span> CircleArray(<span class="number">4</span>); <span class="comment">//说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line"><span class="keyword">char</span> key = <span class="string">' '</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">Scanner scanner = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//</span></span><br><span class="line"><span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 输出一个菜单</span></span><br><span class="line"><span class="keyword">while</span> (loop) &#123;</span><br><span class="line">System.out.println(<span class="string">"s(show): 显示队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"e(exit): 退出程序"</span>);</span><br><span class="line">System.out.println(<span class="string">"a(add): 添加数据到队列"</span>);</span><br><span class="line">System.out.println(<span class="string">"g(get): 从队列取出数据"</span>);</span><br><span class="line">System.out.println(<span class="string">"h(head): 查看队列头的数据"</span>);</span><br><span class="line">key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line"><span class="keyword">switch</span> (key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">queue.showQueue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">System.out.println(<span class="string">"输出一个数"</span>);</span><br><span class="line"><span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">queue.addQueue(value);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>: <span class="comment">// 取出数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.getQueue();</span><br><span class="line">System.out.printf(<span class="string">"取出的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'h'</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> res = queue.headQueue();</span><br><span class="line">System.out.printf(<span class="string">"队列头的数据是%d\n"</span>, res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'e'</span>: <span class="comment">// 退出</span></span><br><span class="line">scanner.close();</span><br><span class="line">loop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"程序退出~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleArray</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line"><span class="comment">//front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素 </span></span><br><span class="line"><span class="comment">//front 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> front; </span><br><span class="line"><span class="comment">//rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line"><span class="comment">//rear 的初始值 = 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CircleArray</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span> </span>&#123;</span><br><span class="line">maxSize = arrMaxSize;</span><br><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (rear  + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> rear == front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加数据到队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否满</span></span><br><span class="line"><span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列满，不能加入数据~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//直接将数据加入</span></span><br><span class="line">arr[rear] = n;</span><br><span class="line"><span class="comment">//将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断队列是否空</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 通过抛出异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空，不能取数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line"><span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line"><span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line"><span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line"><span class="keyword">int</span> value = arr[front];</span><br><span class="line">front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的所有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line"><span class="comment">// 动脑筋</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size() ; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"arr[%d]=%d\n"</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// rear = 2</span></span><br><span class="line"><span class="comment">// front = 1</span></span><br><span class="line"><span class="comment">// maxSize = 3 </span></span><br><span class="line"><span class="keyword">return</span> (rear + maxSize - front) % maxSize;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"队列空的，没有数据~~"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr[front];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;队列是一个有序列表，可以用数组或是链表来实现。&lt;br&gt;遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出&lt;/p&gt;&lt;h2 id=&quot;数组模拟队列&quot;&gt;&lt;a href=&quot;#数组模拟队列&quot; class=&quot;headerlink&quot; title=&quot;数组模拟队列&quot;&gt;&lt;/a&gt;数组模拟队列&lt;/h2&gt;&lt;p&gt;队列本身是有序列表，若使用数组的结构来存储队列的数据，则队列数组的声明如下图, 其中 maxSize 是该队列的最大容量。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>稀疏数组</title>
    <link href="http://yoursite.com/2020/07/03/%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2020/07/03/稀疏数组/</id>
    <published>2020-07-03T01:47:08.000Z</published>
    <updated>2020-07-22T02:12:19.903Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是:<br>记录数组一共有几行几列，有多少个不同的值<br>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p><a id="more"></a><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><p><img src="/images/SparseArray.png" alt></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparseArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line"><span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line"><span class="keyword">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出原始的二维数组</span></span><br><span class="line">System.out.println(<span class="string">"原始的二维数组~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr1) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line"><span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line"><span class="keyword">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//count 用于记录是第几个非0数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">11</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">count++;</span><br><span class="line">sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"得到稀疏数组为~~~~"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t%d\t%d\t\n"</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的  chessArr2 = int [11][11]</span></span><br><span class="line"><span class="comment">2. 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="keyword">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"恢复后的二维数组"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span>[] row : chessArr2) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> data : row) &#123;</span><br><span class="line">System.out.printf(<span class="string">"%d\t"</span>, data);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。&lt;/p&gt;&lt;p&gt;稀疏数组的处理方法是:&lt;br&gt;记录数组一共有几行几列，有多少个不同的值&lt;br&gt;把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>斐波拉契查找</title>
    <link href="http://yoursite.com/2020/07/03/%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/07/03/斐波拉契查找/</id>
    <published>2020-07-03T01:31:33.000Z</published>
    <updated>2020-07-22T02:08:52.492Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/images/fiboraSearch.png" alt></p><a id="more"></a> <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> [] arr = &#123;<span class="number">1</span>,<span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"index="</span> + fibSearch(arr, <span class="number">189</span>));<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line"><span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fib() &#123;</span><br><span class="line"><span class="keyword">int</span>[] f = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">//使用非递归的方式编写算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a  数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = a.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>; <span class="comment">//存放mid值</span></span><br><span class="line"><span class="keyword">int</span> f[] = fib(); <span class="comment">//获取到斐波那契数列</span></span><br><span class="line"><span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line"><span class="keyword">while</span>(high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line"><span class="comment">//不足的部分会使用0填充</span></span><br><span class="line"><span class="keyword">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line"><span class="comment">//实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line"><span class="comment">//举例:</span></span><br><span class="line"><span class="comment">//temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125;  =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234, 1234,&#125;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">temp[i] = a[high];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line"><span class="keyword">while</span> (low &lt;= high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(key &lt; temp[mid]) &#123; <span class="comment">//我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">high = mid - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为甚是 k--</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//因为 前面有 f[k-1]个元素,所以可以继续拆分 f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line"><span class="comment">//即 在 f[k-1] 的前面继续查找 k--</span></span><br><span class="line"><span class="comment">//即下次循环 mid = f[k-1-1]-1</span></span><br><span class="line">k--;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">low = mid + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//为什么是k -=2</span></span><br><span class="line"><span class="comment">//说明</span></span><br><span class="line"><span class="comment">//1. 全部元素 = 前面的元素 + 后边元素</span></span><br><span class="line"><span class="comment">//2. f[k] = f[k-1] + f[k-2]</span></span><br><span class="line"><span class="comment">//3. 因为后面我们有f[k-2] 所以可以继续拆分 f[k-1] = f[k-3] + f[k-4]</span></span><br><span class="line"><span class="comment">//4. 即在f[k-2] 的前面进行查找 k -=2</span></span><br><span class="line"><span class="comment">//5. 即下次循环 mid = f[k - 1 - 2] - 1</span></span><br><span class="line">k -= <span class="number">2</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//找到</span></span><br><span class="line"><span class="comment">//需要确定，返回的是哪个下标</span></span><br><span class="line"><span class="keyword">if</span>(mid &lt;= high) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> high;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/fiboraSearch.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>插值查找</title>
    <link href="http://yoursite.com/2020/07/03/%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/07/03/插值查找/</id>
    <published>2020-07-03T01:27:38.000Z</published>
    <updated>2020-07-22T02:09:36.541Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><img src="/images/insertValueQuery.png" alt></p><a id="more"></a> <h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertValueSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int [] arr = new int[100];</span></span><br><span class="line"><span class="comment">//for(int i = 0; i &lt; 100; i++) &#123;</span></span><br><span class="line"><span class="comment">//arr[i] = i + 1;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>,<span class="number">1000</span>,<span class="number">1000</span>, <span class="number">1234</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1234</span>);</span><br><span class="line"><span class="comment">//int index = binarySearch(arr, 0, arr.length, 1);</span></span><br><span class="line">System.out.println(<span class="string">"index = "</span> + index);</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"二分查找被调用~"</span>);</span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写插值查找算法</span></span><br><span class="line"><span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insertValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"插值查找次数~~"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：findVal &lt; arr[0]  和  findVal &gt; arr[arr.length - 1] 必须需要</span></span><br><span class="line"><span class="comment">//否则我们得到的 mid 可能越界</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出mid, 自适应</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line"><span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;
&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/insertValueQuery.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://yoursite.com/2020/07/03/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/07/03/二分查找/</id>
    <published>2020-07-03T01:20:14.000Z</published>
    <updated>2020-07-22T02:09:05.523Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>首先，假设表中元素是按升序排列，将表中间位置记录的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lhbPplK7lrZc=" title="https://baike.baidu.com/item/关键字">关键字<i class="fa fa-external-link"></i></span>与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/orrDlvZUvMTgzNzc1OA==" title="https://baike.baidu.com/item/记录/1837758">记录<i class="fa fa-external-link"></i></span>将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/orrDlvZUvMTgzNzc1OA==" title="https://baike.baidu.com/item/记录/1837758">记录<i class="fa fa-external-link"></i></span>，使查找成功，或直到子表不存在为止，此时查找不成功。</p><a id="more"></a><h2 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//int arr[] = &#123; 1, 8, 10, 89,1000,1000, 1234 &#125;;</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> , <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int resIndex = binarySearch(arr, 0, arr.length - 1, 1000);</span></span><br><span class="line"><span class="comment">//System.out.println("resIndex=" + resIndex);</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexList = binarySearch2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"resIndexList="</span> + resIndexList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找算法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> *            数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> *            左边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> *            右边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal</span></span><br><span class="line"><span class="comment"> *            要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成一个课后思考题:</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中，</span></span><br><span class="line"><span class="comment"> * 有多个相同的数值时，如何将所有的数值都查找到，比如这里的 1000</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 思路分析</span></span><br><span class="line"><span class="comment"> * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment"> * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment"> * 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"hello~"</span>);</span><br><span class="line"><span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line"><span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line"><span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// * 思路分析</span></span><br><span class="line"><span class="comment">// * 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line"><span class="comment">// * 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">// * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">// * 4. 将Arraylist返回</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp -= <span class="number">1</span>; <span class="comment">//temp左移</span></span><br><span class="line">&#125;</span><br><span class="line">resIndexlist.add(mid);  <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">temp = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;<span class="comment">//退出</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//否则，就temp 放入到 resIndexlist</span></span><br><span class="line">resIndexlist.add(temp);</span><br><span class="line">temp += <span class="number">1</span>; <span class="comment">//temp右移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> resIndexlist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归代码"><a href="#非递归代码" class="headerlink" title="非递归代码"></a>非递归代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecur</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = binarySearch(arr, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"index="</span> + index);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找的非递归实现</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 待查找的数组, arr是升序排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 需要查找的数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对应下标，-1表示没有找到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//说明继续查找</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(arr[mid] == target) &#123;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( arr[mid] &gt; target) &#123;</span><br><span class="line">right = mid - <span class="number">1</span>;<span class="comment">//需要向左边查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">left = mid + <span class="number">1</span>; <span class="comment">//需要向右边查找</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看了下算法，就想将其记录下来，方便自己以后查找，内容大部分从尚硅谷视频中获取&lt;/p&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h2&gt;&lt;p&gt;首先，假设表中元素是按升序排列，将表中间位置记录的&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/lhbPplK7lrZc=&quot; title=&quot;https://baike.baidu.com/item/关键字&quot;&gt;关键字&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/orrDlvZUvMTgzNzc1OA==&quot; title=&quot;https://baike.baidu.com/item/记录/1837758&quot;&gt;记录&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS/orrDlvZUvMTgzNzc1OA==&quot; title=&quot;https://baike.baidu.com/item/记录/1837758&quot;&gt;记录&lt;i class=&quot;fa fa-external-link&quot;&gt;&lt;/i&gt;&lt;/span&gt;，使查找成功，或直到子表不存在为止，此时查找不成功。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="查找" scheme="http://yoursite.com/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
